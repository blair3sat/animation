// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderer = WebGLRenderer;
exports.FogExp2 = FogExp2;
exports.Fog = Fog;
exports.Scene = Scene;
exports.Sprite = Sprite;
exports.LOD = LOD;
exports.SkinnedMesh = SkinnedMesh;
exports.Skeleton = Skeleton;
exports.Bone = Bone;
exports.Mesh = Mesh;
exports.LineSegments = LineSegments;
exports.LineLoop = LineLoop;
exports.Line = Line;
exports.Points = Points;
exports.Group = Group;
exports.VideoTexture = VideoTexture;
exports.DataTexture = DataTexture;
exports.DataTexture3D = DataTexture3D;
exports.CompressedTexture = CompressedTexture;
exports.CubeTexture = CubeTexture;
exports.CanvasTexture = CanvasTexture;
exports.DepthTexture = DepthTexture;
exports.Texture = Texture;
exports.AnimationLoader = AnimationLoader;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.DataTextureLoader = DataTextureLoader;
exports.CubeTextureLoader = CubeTextureLoader;
exports.TextureLoader = TextureLoader;
exports.ObjectLoader = ObjectLoader;
exports.MaterialLoader = MaterialLoader;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.LoadingManager = LoadingManager;
exports.ImageLoader = ImageLoader;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.FontLoader = FontLoader;
exports.FileLoader = FileLoader;
exports.Loader = Loader;
exports.AudioLoader = AudioLoader;
exports.SpotLightShadow = SpotLightShadow;
exports.SpotLight = SpotLight;
exports.PointLight = PointLight;
exports.RectAreaLight = RectAreaLight;
exports.HemisphereLight = HemisphereLight;
exports.DirectionalLightShadow = DirectionalLightShadow;
exports.DirectionalLight = DirectionalLight;
exports.AmbientLight = AmbientLight;
exports.LightShadow = LightShadow;
exports.Light = Light;
exports.StereoCamera = StereoCamera;
exports.PerspectiveCamera = PerspectiveCamera;
exports.OrthographicCamera = OrthographicCamera;
exports.CubeCamera = CubeCamera;
exports.ArrayCamera = ArrayCamera;
exports.Camera = Camera;
exports.AudioListener = AudioListener;
exports.PositionalAudio = PositionalAudio;
exports.AudioAnalyser = AudioAnalyser;
exports.Audio = Audio;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.PropertyMixer = PropertyMixer;
exports.PropertyBinding = PropertyBinding;
exports.KeyframeTrack = KeyframeTrack;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.AnimationMixer = AnimationMixer;
exports.AnimationClip = AnimationClip;
exports.Uniform = Uniform;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.BufferGeometry = BufferGeometry;
exports.Geometry = Geometry;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.Face3 = Face3;
exports.Object3D = Object3D;
exports.Raycaster = Raycaster;
exports.Layers = Layers;
exports.EventDispatcher = EventDispatcher;
exports.Clock = Clock;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.LinearInterpolant = LinearInterpolant;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.CubicInterpolant = CubicInterpolant;
exports.Interpolant = Interpolant;
exports.Triangle = Triangle;
exports.Spherical = Spherical;
exports.Cylindrical = Cylindrical;
exports.Plane = Plane;
exports.Frustum = Frustum;
exports.Sphere = Sphere;
exports.Ray = Ray;
exports.Matrix4 = Matrix4;
exports.Matrix3 = Matrix3;
exports.Box3 = Box3;
exports.Box2 = Box2;
exports.Line3 = Line3;
exports.Euler = Euler;
exports.Vector4 = Vector4;
exports.Vector3 = Vector3;
exports.Vector2 = Vector2;
exports.Quaternion = Quaternion;
exports.Color = Color;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.VertexNormalsHelper = VertexNormalsHelper;
exports.SpotLightHelper = SpotLightHelper;
exports.SkeletonHelper = SkeletonHelper;
exports.PointLightHelper = PointLightHelper;
exports.RectAreaLightHelper = RectAreaLightHelper;
exports.HemisphereLightHelper = HemisphereLightHelper;
exports.GridHelper = GridHelper;
exports.PolarGridHelper = PolarGridHelper;
exports.PositionalAudioHelper = PositionalAudioHelper;
exports.FaceNormalsHelper = FaceNormalsHelper;
exports.DirectionalLightHelper = DirectionalLightHelper;
exports.CameraHelper = CameraHelper;
exports.BoxHelper = BoxHelper;
exports.Box3Helper = Box3Helper;
exports.PlaneHelper = PlaneHelper;
exports.ArrowHelper = ArrowHelper;
exports.AxesHelper = AxesHelper;
exports.Shape = Shape;
exports.Path = Path;
exports.ShapePath = ShapePath;
exports.Font = Font;
exports.CurvePath = CurvePath;
exports.Curve = Curve;
exports.WebGLUtils = WebGLUtils;
exports.WireframeGeometry = WireframeGeometry;
exports.ParametricGeometry = ParametricGeometry;
exports.ParametricBufferGeometry = ParametricBufferGeometry;
exports.TetrahedronGeometry = TetrahedronGeometry;
exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
exports.OctahedronGeometry = OctahedronGeometry;
exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
exports.IcosahedronGeometry = IcosahedronGeometry;
exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
exports.DodecahedronGeometry = DodecahedronGeometry;
exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
exports.PolyhedronGeometry = PolyhedronGeometry;
exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
exports.TubeGeometry = TubeGeometry;
exports.TubeBufferGeometry = TubeBufferGeometry;
exports.TorusKnotGeometry = TorusKnotGeometry;
exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
exports.TorusGeometry = TorusGeometry;
exports.TorusBufferGeometry = TorusBufferGeometry;
exports.TextGeometry = TextGeometry;
exports.TextBufferGeometry = TextBufferGeometry;
exports.SphereGeometry = SphereGeometry;
exports.SphereBufferGeometry = SphereBufferGeometry;
exports.RingGeometry = RingGeometry;
exports.RingBufferGeometry = RingBufferGeometry;
exports.PlaneGeometry = PlaneGeometry;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.LatheGeometry = LatheGeometry;
exports.LatheBufferGeometry = LatheBufferGeometry;
exports.ShapeGeometry = ShapeGeometry;
exports.ShapeBufferGeometry = ShapeBufferGeometry;
exports.ExtrudeGeometry = ExtrudeGeometry;
exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
exports.EdgesGeometry = EdgesGeometry;
exports.ConeGeometry = ConeGeometry;
exports.ConeBufferGeometry = ConeBufferGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.CylinderBufferGeometry = CylinderBufferGeometry;
exports.CircleGeometry = CircleGeometry;
exports.CircleBufferGeometry = CircleBufferGeometry;
exports.CubeGeometry = exports.BoxGeometry = BoxGeometry;
exports.BoxBufferGeometry = BoxBufferGeometry;
exports.ShadowMaterial = ShadowMaterial;
exports.SpriteMaterial = SpriteMaterial;
exports.RawShaderMaterial = RawShaderMaterial;
exports.ShaderMaterial = ShaderMaterial;
exports.PointsMaterial = PointsMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineBasicMaterial = LineBasicMaterial;
exports.Material = Material;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.BufferAttribute = BufferAttribute;
exports.ArcCurve = ArcCurve;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.EllipseCurve = EllipseCurve;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.SplineCurve = SplineCurve;
exports.Face4 = Face4;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MultiMaterial = MultiMaterial;
exports.PointCloud = PointCloud;
exports.Particle = Particle;
exports.ParticleSystem = ParticleSystem;
exports.PointCloudMaterial = PointCloudMaterial;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Vertex = Vertex;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.Int8Attribute = Int8Attribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Int16Attribute = Int16Attribute;
exports.Uint16Attribute = Uint16Attribute;
exports.Int32Attribute = Int32Attribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Float32Attribute = Float32Attribute;
exports.Float64Attribute = Float64Attribute;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.SplineCurve3 = SplineCurve3;
exports.Spline = Spline;
exports.AxisHelper = AxisHelper;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.EdgesHelper = EdgesHelper;
exports.WireframeHelper = WireframeHelper;
exports.XHRLoader = XHRLoader;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.Projector = Projector;
exports.CanvasRenderer = CanvasRenderer;
exports.JSONLoader = JSONLoader;
exports.LensFlare = LensFlare;
exports.AlphaFormat = exports.UnsignedInt248Type = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.HalfFloatType = exports.FloatType = exports.UnsignedIntType = exports.IntType = exports.UnsignedShortType = exports.ShortType = exports.ByteType = exports.UnsignedByteType = exports.LinearMipMapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearFilter = exports.NearestMipMapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestFilter = exports.MirroredRepeatWrapping = exports.ClampToEdgeWrapping = exports.RepeatWrapping = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.SphericalReflectionMapping = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.UVMapping = exports.ACESFilmicToneMapping = exports.CineonToneMapping = exports.Uncharted2ToneMapping = exports.ReinhardToneMapping = exports.LinearToneMapping = exports.NoToneMapping = exports.AddOperation = exports.MixOperation = exports.MultiplyOperation = exports.NotEqualDepth = exports.GreaterDepth = exports.GreaterEqualDepth = exports.EqualDepth = exports.LessEqualDepth = exports.LessDepth = exports.AlwaysDepth = exports.NeverDepth = exports.SrcAlphaSaturateFactor = exports.OneMinusDstColorFactor = exports.DstColorFactor = exports.OneMinusDstAlphaFactor = exports.DstAlphaFactor = exports.OneMinusSrcAlphaFactor = exports.SrcAlphaFactor = exports.OneMinusSrcColorFactor = exports.SrcColorFactor = exports.OneFactor = exports.ZeroFactor = exports.MaxEquation = exports.MinEquation = exports.ReverseSubtractEquation = exports.SubtractEquation = exports.AddEquation = exports.CustomBlending = exports.MultiplyBlending = exports.SubtractiveBlending = exports.AdditiveBlending = exports.NormalBlending = exports.NoBlending = exports.VertexColors = exports.FaceColors = exports.NoColors = exports.SmoothShading = exports.FlatShading = exports.DoubleSide = exports.BackSide = exports.FrontSide = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.BasicShadowMap = exports.FrontFaceDirectionCCW = exports.FrontFaceDirectionCW = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CullFaceNone = exports.MOUSE = exports.REVISION = exports.ShapeUtils = exports.ImageUtils = exports.Math = exports.AnimationUtils = exports.AudioContext = exports.Cache = exports.LoaderUtils = exports.DefaultLoadingManager = exports.ShaderChunk = exports.UniformsUtils = exports.UniformsLib = exports.ShaderLib = void 0;
exports.SceneUtils = exports.GeometryUtils = exports.LinePieces = exports.LineStrip = exports.ObjectSpaceNormalMap = exports.TangentSpaceNormalMap = exports.RGBADepthPacking = exports.BasicDepthPacking = exports.RGBDEncoding = exports.RGBM16Encoding = exports.RGBM7Encoding = exports.LogLuvEncoding = exports.RGBEEncoding = exports.GammaEncoding = exports.sRGBEncoding = exports.LinearEncoding = exports.TriangleFanDrawMode = exports.TriangleStripDrawMode = exports.TrianglesDrawMode = exports.WrapAroundEnding = exports.ZeroSlopeEnding = exports.ZeroCurvatureEnding = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.LoopPingPong = exports.LoopRepeat = exports.LoopOnce = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGB_ETC1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGB_S3TC_DXT1_Format = exports.RedFormat = exports.DepthStencilFormat = exports.DepthFormat = exports.RGBEFormat = exports.LuminanceAlphaFormat = exports.LuminanceFormat = exports.RGBAFormat = exports.RGBFormat = void 0;

// Polyfills
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}

if (Number.isInteger === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger = function (value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
} //


if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}

if ('name' in Function.prototype === false) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}

if (Object.assign === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  (function () {
    Object.assign = function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  })();
}
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */


function EventDispatcher() {}

Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    var listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    var listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      var index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;
      var array = listenerArray.slice(0);

      for (var i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
var REVISION = '102';
exports.REVISION = REVISION;
var MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
exports.MOUSE = MOUSE;
var CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
var CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
var CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
var CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
var FrontFaceDirectionCW = 0;
exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
var FrontFaceDirectionCCW = 1;
exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
var BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
var PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
var PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
var FrontSide = 0;
exports.FrontSide = FrontSide;
var BackSide = 1;
exports.BackSide = BackSide;
var DoubleSide = 2;
exports.DoubleSide = DoubleSide;
var FlatShading = 1;
exports.FlatShading = FlatShading;
var SmoothShading = 2;
exports.SmoothShading = SmoothShading;
var NoColors = 0;
exports.NoColors = NoColors;
var FaceColors = 1;
exports.FaceColors = FaceColors;
var VertexColors = 2;
exports.VertexColors = VertexColors;
var NoBlending = 0;
exports.NoBlending = NoBlending;
var NormalBlending = 1;
exports.NormalBlending = NormalBlending;
var AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
var SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
var MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
var CustomBlending = 5;
exports.CustomBlending = CustomBlending;
var AddEquation = 100;
exports.AddEquation = AddEquation;
var SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
var ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
var MinEquation = 103;
exports.MinEquation = MinEquation;
var MaxEquation = 104;
exports.MaxEquation = MaxEquation;
var ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
var OneFactor = 201;
exports.OneFactor = OneFactor;
var SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
var OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
var SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
var OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
var DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
var OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
var DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
var OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
var SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
var NeverDepth = 0;
exports.NeverDepth = NeverDepth;
var AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
var LessDepth = 2;
exports.LessDepth = LessDepth;
var LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
var EqualDepth = 4;
exports.EqualDepth = EqualDepth;
var GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
var GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
var NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
var MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
var MixOperation = 1;
exports.MixOperation = MixOperation;
var AddOperation = 2;
exports.AddOperation = AddOperation;
var NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
var LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
var ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
var Uncharted2ToneMapping = 3;
exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
var CineonToneMapping = 4;
exports.CineonToneMapping = CineonToneMapping;
var ACESFilmicToneMapping = 5;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
var UVMapping = 300;
exports.UVMapping = UVMapping;
var CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
var CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
var EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
var EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
var SphericalReflectionMapping = 305;
exports.SphericalReflectionMapping = SphericalReflectionMapping;
var CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
var CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
var RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
var ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
var MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
var NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
var NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
var NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
var LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
var LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
var LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
var UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
var ByteType = 1010;
exports.ByteType = ByteType;
var ShortType = 1011;
exports.ShortType = ShortType;
var UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
var IntType = 1013;
exports.IntType = IntType;
var UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
var FloatType = 1015;
exports.FloatType = FloatType;
var HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
var UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
var UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
var UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
var UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
var AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
var RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
var RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
var LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
var LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
var RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
var DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
var DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
var RedFormat = 1028;
exports.RedFormat = RedFormat;
var RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
var RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
var RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
var RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
var RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
var RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
var RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
var RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
var RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
var RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
var RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
var RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
var RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
var RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
var RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
var RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
var RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
var RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
var RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
var RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
var RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
var RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
var RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
var LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
var LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
var LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
var InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
var InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
var InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
var ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
var ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
var WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
var TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
var TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
var TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
var LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
var sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
var GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
var RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
var LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
var RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
var RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
var RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
var BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
var RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
var TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
var ObjectSpaceNormalMap = 1;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    var lut = [];

    for (var i = 0; i < 256; i++) {
      lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    }

    return function generateUUID() {
      var d0 = Math.random() * 0xffffffff | 0;
      var d1 = Math.random() * 0xffffffff | 0;
      var d2 = Math.random() * 0xffffffff | 0;
      var d3 = Math.random() * 0xffffffff | 0;
      var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

      return uuid.toUpperCase();
    };
  }(),
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function (degrees) {
    return degrees * _Math.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

exports.Math = _Math;

function Vector2(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}

Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function () {
      return this.x;
    },
    set: function (value) {
      this.x = value;
    }
  },
  "height": {
    get: function () {
      return this.y;
    },
    set: function (value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function () {
    var min = new Vector2();
    var max = new Vector2();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal);
      max.set(maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  cross: function (v) {
    return this.x * v.y - this.y * v.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    // computes the angle in radians with respect to the positive x-axis
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function (center, angle) {
    var c = Math.cos(angle),
        s = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function (m) {
    var te = this.elements,
        me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function (xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function () {
    var v1 = new Vector3();
    return function extractRotation(m) {
      // this method does not support reflection matrices
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    };
  }(),
  makeRotationFromEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    var te = this.elements;
    var x = euler.x,
        y = euler.y,
        z = euler.z;
    var a = Math.cos(x),
        b = Math.sin(x);
    var c = Math.cos(y),
        d = Math.sin(y);
    var e = Math.cos(z),
        f = Math.sin(z);

    if (euler.order === 'XYZ') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function () {
    var zero = new Vector3(0, 0, 0);
    var one = new Vector3(1, 1, 1);
    return function makeRotationFromQuaternion(q) {
      return this.compose(zero, q, one);
    };
  }(),
  lookAt: function () {
    var x = new Vector3();
    var y = new Vector3();
    var z = new Vector3();
    return function lookAt(eye, target, up) {
      var te = this.elements;
      z.subVectors(eye, target);

      if (z.lengthSq() === 0) {
        // eye and target are in the same position
        z.z = 1;
      }

      z.normalize();
      x.crossVectors(up, z);

      if (x.lengthSq() === 0) {
        // up and z are parallel
        if (Math.abs(up.z) === 1) {
          z.x += 0.0001;
        } else {
          z.z += 0.0001;
        }

        z.normalize();
        x.crossVectors(up, z);
      }

      x.normalize();
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
    var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
    var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
    var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
    var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
    var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
    var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
    var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToBufferAttribute: function () {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix4(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),
  determinant: function () {
    var te = this.elements;
    var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
    var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
    var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
    var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  setPosition: function (v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function (m, throwOnDegenerate) {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements,
        me = m.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n41 = me[3],
        n12 = me[4],
        n22 = me[5],
        n32 = me[6],
        n42 = me[7],
        n13 = me[8],
        n23 = me[9],
        n33 = me[10],
        n43 = me[11],
        n14 = me[12],
        n24 = me[13],
        n34 = me[14],
        n44 = me[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    if (det === 0) {
      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x,
        y = v.y,
        z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x,
        y = axis.y,
        z = axis.z;
    var tx = t * x,
        ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function (x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    var te = this.elements;
    var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
    var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
    var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
    var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
    var wx = w * x2,
        wy = w * y2,
        wz = w * z2;
    var sx = scale.x,
        sy = scale.y,
        sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function () {
    var vector = new Vector3();
    var matrix = new Matrix4();
    return function decompose(position, quaternion, scale) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14]; // scale the rotation part

      matrix.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    };
  }(),
  makePerspective: function (left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1.0 / (right - left);
    var h = 1.0 / (top - bottom);
    var p = 1.0 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
}

Object.assign(Quaternion, {
  slerp: function (qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3],
        x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t,
          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (value) {
      this._w = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: true,
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function (euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    var x = euler._x,
        y = euler._y,
        z = euler._z,
        order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    var cos = Math.cos;
    var sin = Math.sin;
    var c1 = cos(x / 2);
    var c2 = cos(y / 2);
    var c3 = cos(z / 2);
    var s1 = sin(x / 2);
    var s2 = sin(y / 2);
    var s3 = sin(z / 2);

    if (order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    if (update !== false) this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33,
        s;

    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function () {
    // assumes direction vectors vFrom and vTo are normalized
    var v1 = new Vector3();
    var r;
    var EPS = 0.000001;
    return function setFromUnitVectors(vFrom, vTo) {
      if (v1 === undefined) v1 = new Vector3();
      r = vFrom.dot(vTo) + 1;

      if (r < EPS) {
        r = 0;

        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      return this.normalize();
    };
  }(),
  angleTo: function (q) {
    return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function (q, step) {
    var angle = this.angleTo(q);
    if (angle === 0) return this;
    var t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  },
  inverse: function () {
    // quaternion is assumed to have unit length
    return this.conjugate();
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function (v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this.onChangeCallback();
    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  },
  premultiply: function (q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function (a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
    var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function (qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      var s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      return this.normalize();
    }

    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}

Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var quaternion = new Quaternion();
    return function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),
  applyAxisAngle: function () {
    var quaternion = new Quaternion();
    return function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w; // calculate quat * vector

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function (camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function () {
    var matrix = new Matrix4();
    return function unproject(camera) {
      return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
    };
  }(),
  transformDirection: function (m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function () {
    var min = new Vector3();
    var max = new Vector3();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  // TODO lengthSquared?
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  },
  crossVectors: function (a, b) {
    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function (vector) {
    var scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  },
  projectOnPlane: function () {
    var v1 = new Vector3();
    return function projectOnPlane(planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function () {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    var v1 = new Vector3();
    return function reflect(normal) {
      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),
  angleTo: function (v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq()); // clamp, to handle numerical problems

    return Math.acos(_Math.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function (s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  },
  setFromSphericalCoords: function (radius, phi, theta) {
    var sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function (c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  },
  setFromCylindricalCoords: function (radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function (m) {
    var e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function (m) {
    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function (m, index) {
    return this.fromArray(m.elements, index * 4);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {
  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function (m) {
    var me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToBufferAttribute: function () {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix3(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),
  multiply: function (m) {
    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[3],
        a13 = ae[6];
    var a21 = ae[1],
        a22 = ae[4],
        a23 = ae[7];
    var a31 = ae[2],
        a32 = ae[5],
        a33 = ae[8];
    var b11 = be[0],
        b12 = be[3],
        b13 = be[6];
    var b21 = be[1],
        b22 = be[4],
        b23 = be[7];
    var b31 = be[2],
        b32 = be[5],
        b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnDegenerate) {
    if (matrix && matrix.isMatrix4) {
      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    }

    var me = matrix.elements,
        te = this.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n12 = me[3],
        n22 = me[4],
        n32 = me[5],
        n13 = me[6],
        n23 = me[7],
        n33 = me[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;

    if (det === 0) {
      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function () {
    var tmp,
        m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
  },
  scale: function (sx, sy) {
    var te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function (theta) {
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var te = this.elements;
    var a11 = te[0],
        a12 = te[3],
        a13 = te[6];
    var a21 = te[1],
        a22 = te[4],
        a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  },
  translate: function (tx, ty) {
    var te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils = {
  getDataURL: function (image) {
    var canvas;

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    } else if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      var context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

exports.ImageUtils = ImageUtils;
var textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : RGBAFormat;
  this.type = type !== undefined ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.

  this.encoding = encoding !== undefined ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    var isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    var output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      var image = this.image;

      if (image.uuid === undefined) {
        image.uuid = _Math.generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        var url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (var i = 0, l = image.length; i < l; i++) {
            url.push(ImageUtils.getDataURL(image[i]));
          }
        } else {
          // process single image
          url = ImageUtils.getDataURL(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function (value) {
    if (value === true) this.version++;
  }
});
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
}

Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function (q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var angle,
        x,
        y,
        z,
        // variables for result
    epsilon = 0.01,
        // margin to allow for rounding errors
    epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees
    te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function () {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === undefined) {
        min = new Vector4();
        max = new Vector4();
      }

      min.set(minVal, minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
});
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}

WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function (source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com
 */

function WebGLRenderTargetCube(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
}

WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data,
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}

DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3(min, max) {
  this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}

Object.assign(Box3.prototype, {
  isBox3: true,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function (array) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = array.length; i < l; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function (attribute) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = attribute.count; i < l; i++) {
      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new Vector3();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function (object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function () {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    var scope, i, l;
    var v1 = new Vector3();

    function traverse(node) {
      var geometry = node.geometry;

      if (geometry !== undefined) {
        if (geometry.isGeometry) {
          var vertices = geometry.vertices;

          for (i = 0, l = vertices.length; i < l; i++) {
            v1.copy(vertices[i]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        } else if (geometry.isBufferGeometry) {
          var attribute = geometry.attributes.position;

          if (attribute !== undefined) {
            for (i = 0, l = attribute.count; i < l; i++) {
              v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          }
        }
      }
    }

    return function expandByObject(object) {
      scope = this;
      object.updateMatrixWorld(true);
      object.traverse(traverse);
      return this;
    };
  }(),
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function () {
    var closestPoint = new Vector3();
    return function intersectsSphere(sphere) {
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, closestPoint); // If that point is inside the sphere, the AABB and sphere intersect.

      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function (plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    var min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  },
  intersectsTriangle: function () {
    // triangle centered vertices
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3(); // triangle edge vectors

    var f0 = new Vector3();
    var f1 = new Vector3();
    var f2 = new Vector3();
    var testAxis = new Vector3();
    var center = new Vector3();
    var extents = new Vector3();
    var triangleNormal = new Vector3();

    function satForAxes(axes) {
      var i, j;

      for (i = 0, j = axes.length - 3; i <= j; i += 3) {
        testAxis.fromArray(axes, i); // project the aabb onto the seperating axis

        var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

        var p0 = v0.dot(testAxis);
        var p1 = v1.dot(testAxis);
        var p2 = v2.dot(testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          // points of the projected triangle are outside the projected half-length of the aabb
          // the axis is seperating and we can exit
          return false;
        }
      }

      return true;
    }

    return function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      } // compute box center and extents


      this.getCenter(center);
      extents.subVectors(this.max, center); // translate triangle to aabb origin

      v0.subVectors(triangle.a, center);
      v1.subVectors(triangle.b, center);
      v2.subVectors(triangle.c, center); // compute edge vectors for triangle

      f0.subVectors(v1, v0);
      f1.subVectors(v2, v1);
      f2.subVectors(v0, v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)

      var axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];

      if (!satForAxes(axes)) {
        return false;
      } // test 3 face normals from the aabb


      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

      if (!satForAxes(axes)) {
        return false;
      } // finally testing the face normal of the triangle
      // use already existing triangle edge vectors here


      triangleNormal.crossVectors(f0, f1);
      axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
      return satForAxes(axes);
    };
  }(),
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new Vector3();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function () {
    var v1 = new Vector3();
    return function getBoundingSphere(target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .getBoundingSphere() target is now required');
        target = new Sphere();
      }

      this.getCenter(target.center);
      target.radius = this.getSize(v1).length() * 0.5;
      return target;
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function () {
    var points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    return function applyMatrix4(matrix) {
      // transform of empty box is an empty box.
      if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000

      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001

      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010

      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011

      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100

      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101

      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110

      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere(center, radius) {
  this.center = center !== undefined ? center : new Vector3();
  this.radius = radius !== undefined ? radius : 0;
}

Object.assign(Sphere.prototype, {
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function () {
    var box = new Box3();
    return function setFromPoints(points, optionalCenter) {
      var center = this.center;

      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center);
      }

      var maxRadiusSq = 0;

      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }

      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function (box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function (plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  },
  getBoundingBox: function (target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});
/**
 * @author bhouston / http://clara.io
 */

function Plane(normal, constant) {
  // normal is assumed to be normalized
  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
}

Object.assign(Plane.prototype, {
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function setFromCoplanarPoints(a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    // Note: will lead to a divide by zero if the plane is invalid.
    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function () {
    var v1 = new Vector3();
    return function intersectLine(line, target) {
      if (target === undefined) {
        console.warn('THREE.Plane: .intersectLine() target is now required');
        target = new Vector3();
      }

      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);

      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        } // Unsure if this is the correct method to handle this case.


        return undefined;
      }

      var t = -(line.start.dot(this.normal) + this.constant) / denominator;

      if (t < 0 || t > 1) {
        return undefined;
      }

      return target.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  intersectsLine: function (line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function (box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function (sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var v1 = new Vector3();
    var m1 = new Matrix3();
    return function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    };
  }(),
  translate: function (offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
}

Object.assign(Frustum.prototype, {
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (frustum) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0],
        me1 = me[1],
        me2 = me[2],
        me3 = me[3];
    var me4 = me[4],
        me5 = me[5],
        me6 = me[6],
        me7 = me[7];
    var me8 = me[8],
        me9 = me[9],
        me10 = me[10],
        me11 = me[11];
    var me12 = me[12],
        me13 = me[13],
        me14 = me[14],
        me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function () {
    var sphere = new Sphere();
    return function intersectsObject(object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSprite: function () {
    var sphere = new Sphere();
    return function intersectsSprite(sprite) {
      sphere.center.set(0, 0, 0);
      sphere.radius = 0.7071067811865476;
      sphere.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;

    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  },
  intersectsBox: function () {
    var p = new Vector3();
    return function intersectsBox(box) {
      var planes = this.planes;

      for (var i = 0; i < 6; i++) {
        var plane = planes[i]; // corner at max distance

        p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        if (plane.distanceToPoint(p) < 0) {
          return false;
        }
      }

      return true;
    };
  }(),
  containsPoint: function (point) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }
});
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif";
var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};
/**
 * Uniform Utilities
 */

exports.ShaderChunk = ShaderChunk;

function cloneUniforms(src) {
  var dst = {};

  for (var u in src) {
    dst[u] = {};

    for (var p in src[u]) {
      var property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  var merged = {};

  for (var u = 0; u < uniforms.length; u++) {
    var tmp = cloneUniforms(uniforms[u]);

    for (var p in tmp) {
      merged[p] = tmp[p];
    }
  }

  return merged;
} // Legacy


var UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.UniformsUtils = UniformsUtils;
var ColorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};

function Color(r, g, b) {
  if (g === undefined && b === undefined) {
    // r is THREE.Color, hex or string
    return this.set(r);
  }

  return this.setRGB(r, g, b);
}

Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  },
  setScalar: function (scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function () {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }

    return function setHSL(h, s, l) {
      // h,s,l ranges are in 0.0 - 1.0
      h = _Math.euclideanModulo(h, 1);
      s = _Math.clamp(s, 0, 1);
      l = _Math.clamp(l, 0, 1);

      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }

      return this;
    };
  }(),
  setStyle: function (style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    var m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      var color;
      var name = m[1];
      var components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            var h = parseFloat(color[1]) / 360;
            var s = parseInt(color[2], 10) / 100;
            var l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      var hex = m[1];
      var size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      // color keywords
      var hex = ColorKeywords[style];

      if (hex !== undefined) {
        // red
        this.setHex(hex);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
    }

    return this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function (gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function (gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: function () {
    function SRGBToLinear(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }

    return function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    };
  }(),
  copyLinearToSRGB: function () {
    function LinearToSRGB(c) {
      return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }

    return function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    };
  }(),
  convertSRGBToLinear: function () {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function () {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    var r = this.r,
        g = this.g,
        b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function () {
    var hsl = {};
    return function (h, s, l) {
      this.getHSL(hsl);
      hsl.h += h;
      hsl.s += s;
      hsl.l += l;
      this.setHSL(hsl.h, hsl.s, hsl.l);
      return this;
    };
  }(),
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function (color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  lerpHSL: function () {
    var hslA = {
      h: 0,
      s: 0,
      l: 0
    };
    var hslB = {
      h: 0,
      s: 0,
      l: 0
    };
    return function lerpHSL(color, alpha) {
      this.getHSL(hslA);
      color.getHSL(hslB);

      var h = _Math.lerp(hslA.h, hslB.h, alpha);

      var s = _Math.lerp(hslA.s, hslB.s, alpha);

      var l = _Math.lerp(hslA.l, hslB.l, alpha);

      this.setHSL(h, s, l);
      return this;
    };
  }(),
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  toJSON: function () {
    return this.getHex();
  }
});
/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    }
  },
  points: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

exports.UniformsLib = UniformsLib;
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 0.5
      },
      metalness: {
        value: 0.5
      },
      envMapIntensity: {
        value: 1 // temporary

      }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: {
        value: null
      },
      tFlip: {
        value: -1
      },
      opacity: {
        value: 1.0
      }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearCoat: {
      value: 0
    },
    clearCoatRoughness: {
      value: 0
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation() {
  var context = null;
  var isAnimating = false;
  var animationLoop = null;

  function onAnimationFrame(time, frame) {
    if (isAnimating === false) return;
    animationLoop(time, frame);
    context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLAttributes(gl) {
  var buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? 35048 : 35044;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type = 5126;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      type = 5123;
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, 35044);
    } else if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
    } else {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */


function Face3(a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}

Object.assign(Face3.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;

    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }

    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler(x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties(Euler.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (value) {
      this._order = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m, order, update) {
    var clamp = _Math.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
    var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
    var m31 = te[2],
        m32 = te[6],
        m33 = te[10];
    order = order || this._order;

    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13, -1, 1));

      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23, -1, 1));

      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32, -1, 1));

      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31, -1, 1));

      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21, -1, 1));

      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12, -1, 1));

      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
    }

    this._order = order;
    if (update !== false) this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function () {
    var matrix = new Matrix4();
    return function setFromQuaternion(q, order, update) {
      matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix, order, update);
    };
  }(),
  setFromVector3: function (v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function () {
    // WARNING: this discards revolution information -bhouston
    var q = new Quaternion();
    return function reorder(newOrder) {
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function (optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {
  this.mask = 1 | 0;
}

Object.assign(Layers.prototype, {
  set: function (channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function (channel) {
    this.mask |= 1 << channel | 0;
  },
  toggle: function (channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function (channel) {
    this.mask &= ~(1 << channel | 0);
  },
  test: function (layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {
  Object.defineProperty(this, 'id', {
    value: object3DId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new Vector3();
  var rotation = new Euler();
  var quaternion = new Quaternion();
  var scale = new Vector3(1, 1, 1);

  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }

  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }

  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}

Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix: function (matrix) {
    this.matrix.multiplyMatrices(matrix, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function () {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    var q1 = new Quaternion();
    return function rotateOnAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateOnWorldAxis: function () {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    var q1 = new Quaternion();
    return function rotateOnWorldAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(q1);
      return this;
    };
  }(),
  rotateX: function () {
    var v1 = new Vector3(1, 0, 0);
    return function rotateX(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function () {
    var v1 = new Vector3(0, 1, 0);
    return function rotateY(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function () {
    var v1 = new Vector3(0, 0, 1);
    return function rotateZ(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function () {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    var v1 = new Vector3();
    return function translateOnAxis(axis, distance) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translateX: function () {
    var v1 = new Vector3(1, 0, 0);
    return function translateX(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function () {
    var v1 = new Vector3(0, 1, 0);
    return function translateY(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function () {
    var v1 = new Vector3(0, 0, 1);
    return function translateZ(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var m1 = new Matrix4();
    return function worldToLocal(vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    // This method does not support objects having non-uniformly-scaled parent(s)
    var q1 = new Quaternion();
    var m1 = new Matrix4();
    var target = new Vector3();
    var position = new Vector3();
    return function lookAt(x, y, z) {
      if (x.isVector3) {
        target.copy(x);
      } else {
        target.set(x, y, z);
      }

      var parent = this.parent;
      this.updateWorldMatrix(true, false);
      position.setFromMatrixPosition(this.matrixWorld);

      if (this.isCamera || this.isLight) {
        m1.lookAt(position, target, this.up);
      } else {
        m1.lookAt(target, position, this.up);
      }

      this.quaternion.setFromRotationMatrix(m1);

      if (parent) {
        m1.extractRotation(parent.matrixWorld);
        q1.setFromRotationMatrix(m1);
        this.quaternion.premultiply(q1.inverse());
      }
    };
  }(),
  add: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      object.dispatchEvent({
        type: 'added'
      });
      this.children.push(object);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }

    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    var index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      object.dispatchEvent({
        type: 'removed'
      });
      this.children.splice(index, 1);
    }

    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;

    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function () {
    var position = new Vector3();
    var scale = new Vector3();
    return function getWorldQuaternion(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
        target = new Quaternion();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, target, scale);
      return target;
    };
  }(),
  getWorldScale: function () {
    var position = new Vector3();
    var quaternion = new Quaternion();
    return function getWorldScale(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldScale() target is now required');
        target = new Vector3();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, target);
      return target;
    };
  }(),
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    var parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    var parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    var isRootObject = meta === undefined || typeof meta === 'string';
    var output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isMesh && this.drawMode !== TrianglesDrawMode) object.drawMode = this.drawMode; //

    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        var shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        var uuids = [];

        for (var i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      var shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var geometryId = 0; // Geometry uses even numbers as Id

function Geometry() {
  Object.defineProperty(this, 'id', {
    value: geometryId += 2
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix: function (matrix) {
    var normalMatrix = new Matrix3().getNormalMatrix(matrix);

    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }

    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();

      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1 = new Matrix4();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1 = new Matrix4();
    return function scale(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function (geometry) {
    var scope = this;
    var indices = geometry.index !== null ? geometry.index.array : undefined;
    var attributes = geometry.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
      scope.vertices.push(new Vector3().fromArray(positions, i));

      if (colors !== undefined) {
        scope.colors.push(new Color().fromArray(colors, i));
      }
    }

    function addFace(a, b, c, materialIndex) {
      var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
      var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);

      if (uvs !== undefined) {
        scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
      }

      if (uvs2 !== undefined) {
        scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
      }
    }

    var groups = geometry.groups;

    if (groups.length > 0) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var start = group.start;
        var count = group.count;

        for (var j = start, jl = start + count; j < jl; j += 3) {
          if (indices !== undefined) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== undefined) {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      } else {
        for (var i = 0; i < positions.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }

    this.computeFaceNormals();

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    return this;
  },
  center: function () {
    var offset = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  normalize: function () {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1.0 / radius;
    var matrix = new Matrix4();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function () {
    var cb = new Vector3(),
        ab = new Vector3();

    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined) areaWeighted = true;
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }

    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      var vA, vB, vC;
      var cb = new Vector3(),
          ab = new Vector3();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function () {
    var f, fl, face;
    this.computeFaceNormals();

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face; // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];

      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }

      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    } // use temp geometry to compute face and vertex normals for each morph


    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;

    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new Vector3();
          vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }

      var morphNormals = this.morphNormals[i]; // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals(); // store morph normals

      var faceNormal, vertexNormals;

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    } // restore original normals


    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }

    var normalMatrix,
        vertexOffset = this.vertices.length,
        vertices1 = this.vertices,
        vertices2 = geometry.vertices,
        faces1 = this.faces,
        faces2 = geometry.faces,
        uvs1 = this.faceVertexUvs[0],
        uvs2 = geometry.faceVertexUvs[0],
        colors1 = this.colors,
        colors2 = geometry.colors;
    if (materialIndexOffset === undefined) materialIndexOffset = 0;

    if (matrix !== undefined) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    } // vertices


    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    } // colors


    for (var i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    } // faces


    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i],
          faceCopy,
          normal,
          color,
          faceVertexNormals = face.vertexNormals,
          faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);

      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }

      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();

        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }

        faceCopy.vertexNormals.push(normal);
      }

      faceCopy.color.copy(face.color);

      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    } // uvs


    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i],
          uvCopy = [];

      if (uv === undefined) {
        continue;
      }

      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }

      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function (mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }

    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function () {
    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

    var unique = [],
        changes = [];
    var v, key;
    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;

    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[i] = changes[verticesMap[key]];
      }
    } // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.


    var faceIndicesToRemove = [];

    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved

      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }

    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);

      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    } // Use unique set of vertices


    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function (points) {
    this.vertices = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    var faces = this.faces;
    var length = faces.length; // tag faces

    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    } // sort faces


    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }

    faces.sort(materialIndexSort); // sort uvs

    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];

    for (var i = 0; i < length; i++) {
      var id = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id]);
      if (newUvs2) newUvs2.push(uvs2[id]);
    }

    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    }; // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    var vertices = [];

    for (var i = 0; i < this.vertices.length; i++) {
      var vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for (var i = 0; i < this.faces.length; i++) {
      var face = this.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false; // deprecated

      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0); // isQuad

      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);

      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }

      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }

      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }

      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }

      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }

    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }

    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }

      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }

    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }

      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }

    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();

      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }

      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }

    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) data.data.colors = colors;
    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new Geometry().copy(this);
  },
  copy: function (source) {
    var i, il, j, jl, k, kl; // reset

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // vertices

    var vertices = source.vertices;

    for (i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    } // colors


    var colors = source.colors;

    for (i = 0, il = colors.length; i < il; i++) {
      this.colors.push(colors[i].clone());
    } // faces


    var faces = source.faces;

    for (i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    } // face vertex uvs


    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];

      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }

      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j],
            uvsCopy = [];

        for (k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    } // morph targets


    var morphTargets = source.morphTargets;

    for (i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i].name; // vertices

      if (morphTargets[i].vertices !== undefined) {
        morphTarget.vertices = [];

        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      } // normals


      if (morphTargets[i].normals !== undefined) {
        morphTarget.normals = [];

        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }

      this.morphTargets.push(morphTarget);
    } // morph normals


    var morphNormals = source.morphNormals;

    for (i = 0, il = morphNormals.length; i < il; i++) {
      var morphNormal = {}; // vertex normals

      if (morphNormals[i].vertexNormals !== undefined) {
        morphNormal.vertexNormals = [];

        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      } // face normals


      if (morphNormals[i].faceNormals !== undefined) {
        morphNormal.faceNormals = [];

        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }

      this.morphNormals.push(morphNormal);
    } // skin weights


    var skinWeights = source.skinWeights;

    for (i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    } // skin indices


    var skinIndices = source.skinIndices;

    for (i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    } // line distances


    var lineDistances = source.lineDistances;

    for (i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // update flags


    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }

  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setArray: function (array) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.count = array !== undefined ? array.length / this.itemSize : 0;
    this.array = array;
    return this;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (var i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = colors.length; i < l; i++) {
      var color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  },
  copyVector2sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  },
  copyVector3sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  },
  copyVector4sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
}); //

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = []; // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Object.assign(DirectGeometry.prototype, {
  computeGroups: function (geometry) {
    var group;
    var groups = [];
    var materialIndex = undefined;
    var faces = geometry.faces;

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i]; // materials

      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;

        if (group !== undefined) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };
      }
    }

    if (group !== undefined) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }

    this.groups = groups;
  },
  fromGeometry: function (geometry) {
    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;

    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];

      for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }

      this.morphTargets.position = morphTargetsPosition;
    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;

    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];

      for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }

      this.morphTargets.normal = morphTargetsNormal;
    } // skins


    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length; //

    if (vertices.length > 0 && faces.length === 0) {
      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
    }

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal = face.normal;
        this.normals.push(normal, normal, normal);
      }

      var vertexColors = face.vertexColors;

      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color = face.color;
        this.colors.push(color, color, color);
      }

      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i];

        if (vertexUvs !== undefined) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }

      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i];

        if (vertexUvs !== undefined) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      } // morphs


      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }

      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      } // skins


      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }

      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }

    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  var max = array[0];

  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: bufferGeometryId += 2
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}

BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  addAttribute: function (name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }

    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }

    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  removeAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix: function (matrix) {
    var position = this.attributes.position;

    if (position !== undefined) {
      matrix.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }

    var normal = this.attributes.normal;

    if (normal !== undefined) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(normal);
      normal.needsUpdate = true;
    }

    var tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix); // Tangent is vec4, but the '.w' component is a sign value (+1/-1).

      normalMatrix.applyToBufferAttribute(tangent);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1 = new Matrix4();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1 = new Matrix4();
    return function scale(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function () {
    var offset = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  setFromObject: function (object) {
    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    var geometry = object.geometry;

    if (object.isPoints || object.isLine) {
      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.addAttribute('color', colors.copyColorsArray(geometry.colors));

      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }

    return this;
  },
  setFromPoints: function (points) {
    var position = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.addAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function (object) {
    var geometry = object.geometry;

    if (object.isMesh) {
      var direct = geometry.__directGeometry;

      if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
      }

      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }

    var attribute;

    if (geometry.verticesNeedUpdate === true) {
      attribute = this.attributes.position;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }

      geometry.verticesNeedUpdate = false;
    }

    if (geometry.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }

      geometry.normalsNeedUpdate = false;
    }

    if (geometry.colorsNeedUpdate === true) {
      attribute = this.attributes.color;

      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }

      geometry.colorsNeedUpdate = false;
    }

    if (geometry.uvsNeedUpdate) {
      attribute = this.attributes.uv;

      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }

      geometry.uvsNeedUpdate = false;
    }

    if (geometry.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;

      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }

      geometry.lineDistancesNeedUpdate = false;
    }

    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }

    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    var positions = new Float32Array(geometry.vertices.length * 3);
    this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

    if (geometry.normals.length > 0) {
      var normals = new Float32Array(geometry.normals.length * 3);
      this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }

    if (geometry.colors.length > 0) {
      var colors = new Float32Array(geometry.colors.length * 3);
      this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }

    if (geometry.uvs.length > 0) {
      var uvs = new Float32Array(geometry.uvs.length * 2);
      this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }

    if (geometry.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    } // groups


    this.groups = geometry.groups; // morphs

    for (var name in geometry.morphTargets) {
      var array = [];
      var morphTargets = geometry.morphTargets[name];

      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }

      this.morphAttributes[name] = array;
    } // skinning


    if (geometry.skinIndices.length > 0) {
      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }

    if (geometry.skinWeights.length > 0) {
      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    } //


    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    var position = this.attributes.position;

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position);
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    var box = new Box3();
    var vector = new Vector3();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }

      var position = this.attributes.position;

      if (position) {
        var center = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        box.getCenter(center); // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for (var i = 0, il = position.count; i < il; i++) {
          vector.x = position.getX(i);
          vector.y = position.getY(i);
          vector.z = position.getZ(i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function () {// backwards compatibility
  },
  computeVertexNormals: function () {
    var index = this.index;
    var attributes = this.attributes;

    if (attributes.position) {
      var positions = attributes.position.array;

      if (attributes.normal === undefined) {
        this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        // reset existing normals to zero
        var array = attributes.normal.array;

        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }

      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new Vector3(),
          pB = new Vector3(),
          pC = new Vector3();
      var cb = new Vector3(),
          ab = new Vector3(); // indexed elements

      if (index) {
        var indices = index.array;

        for (var i = 0, il = index.count; i < il; i += 3) {
          vA = indices[i + 0] * 3;
          vB = indices[i + 1] * 3;
          vC = indices[i + 2] * 3;
          pA.fromArray(positions, vA);
          pB.fromArray(positions, vB);
          pC.fromArray(positions, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[vA] += cb.x;
          normals[vA + 1] += cb.y;
          normals[vA + 2] += cb.z;
          normals[vB] += cb.x;
          normals[vB + 1] += cb.y;
          normals[vB + 2] += cb.z;
          normals[vC] += cb.x;
          normals[vC + 1] += cb.y;
          normals[vC + 2] += cb.z;
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }

      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeSize = attribute2.itemSize;

      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  },
  normalizeNormals: function () {
    var vector = new Vector3();
    return function normalizeNormals() {
      var normals = this.attributes.normal;

      for (var i = 0, il = normals.count; i < il; i++) {
        vector.x = normals.getX(i);
        vector.y = normals.getY(i);
        vector.z = normals.getZ(i);
        vector.normalize();
        normals.setXYZ(i, vector.x, vector.y, vector.z);
      }
    };
  }(),
  toNonIndexed: function () {
    function convertBufferAttribute(attribute, indices) {
      var array = attribute.array;
      var itemSize = attribute.itemSize;
      var array2 = new array.constructor(indices.length * itemSize);
      var index = 0,
          index2 = 0;

      for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }

    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes; // attributes

    for (var name in attributes) {
      var attribute = attributes[name];
      var newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.addAttribute(name, newAttribute);
    } // morph attributes


    var morphAttributes = this.morphAttributes;

    for (name in morphAttributes) {
      var morphArray = [];
      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (var i = 0, il = morphAttribute.length; i < il; i++) {
        var attribute = morphAttribute[i];
        var newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    } // groups


    var groups = this.groups;

    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    data.data = {
      attributes: {}
    };
    var index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      var attribute = attributes[key];
      var attributeData = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: Array.prototype.slice.call(attribute.array),
        normalized: attribute.normalized
      };
      if (attribute.name !== '') attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }

    var morphAttributes = {};
    var hasMorphAttributes = false;

    for (var key in this.morphAttributes) {
      var attributeArray = this.morphAttributes[key];
      var array = [];

      for (var i = 0, il = attributeArray.length; i < il; i++) {
        var attribute = attributeArray[i];
        var attributeData = {
          itemSize: attribute.itemSize,
          type: attribute.array.constructor.name,
          array: Array.prototype.slice.call(attribute.array),
          normalized: attribute.normalized
        };
        if (attribute.name !== '') attributeData.name = attribute.name;
        array.push(attributeData);
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) data.data.morphAttributes = morphAttributes;
    var groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    var boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    var name, i, l; // reset

    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // index

    var index = source.index;

    if (index !== null) {
      this.setIndex(index.clone());
    } // attributes


    var attributes = source.attributes;

    for (name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    } // morph attributes


    var morphAttributes = source.morphAttributes;

    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone());
      }

      this.morphAttributes[name] = array;
    } // groups


    var groups = source.groups;

    for (i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// BoxGeometry

function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  Geometry.call(this);
  this.type = 'BoxGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}

BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry; // BoxBufferGeometry

function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  BufferGeometry.call(this);
  this.type = 'BoxBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  var scope = this;
  width = width || 1;
  height = height || 1;
  depth = depth || 1; // segments

  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var numberOfVertices = 0;
  var groupStart = 0; // build each side of the box geometry

  buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

  buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

  buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

  buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

  buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

  buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
  // build geometry

  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

  function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
    var segmentWidth = width / gridX;
    var segmentHeight = height / gridY;
    var widthHalf = width / 2;
    var heightHalf = height / 2;
    var depthHalf = depth / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new Vector3(); // generate vertices, normals and uvs

    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;

      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - widthHalf; // set values to correct vector component

        vector[u] = x * udir;
        vector[v] = y * vdir;
        vector[w] = depthHalf; // now apply vector to vertex buffer

        vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

        vector[u] = 0;
        vector[v] = 0;
        vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

        normals.push(vector.x, vector.y, vector.z); // uvs

        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY); // counters

        vertexCounter += 1;
      }
    } // indices
    // 1. you need three indices to draw a single face
    // 2. a single segment consists of two faces
    // 3. so we need to generate six (2*3) indices per segment


    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = numberOfVertices + ix + gridX1 * iy;
        var b = numberOfVertices + ix + gridX1 * (iy + 1);
        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // increase counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

    groupStart += groupCount; // update total number of vertices

    numberOfVertices += vertexCounter;
  }
}

BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// PlaneGeometry

function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = 'PlaneGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}

PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry; // PlaneBufferGeometry

function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = 'PlaneBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  width = width || 1;
  height = height || 1;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // generate vertices, normals and uvs

  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;

    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  } // indices


  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.lights = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexTangents = false;
  this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.userData = {};
  this.needsUpdate = true;
}

Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function () {},
  setValues: function (values) {
    if (values === undefined) return;

    for (var key in values) {
      var newValue = values[key];

      if (newValue === undefined) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }

      var currentValue = this[key];

      if (currentValue === undefined) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    var isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    var data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
    if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

      if (this.combine !== undefined) data.combine = this.combine;
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    }

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite; // rotation (SpriteMaterial)

    if (this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes,
        dstPlanes = null;

    if (srcPlanes !== null) {
      var n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
    }

    this.clippingPlanes = dstPlanes;
    this.shadowSide = source.shadowSide;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets

  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD

  }; // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.

  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;

  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }

    this.setValues(parameters);
  }
}

ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {
  var data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = {};

  for (var name in this.uniforms) {
    var uniform = this.uniforms[name];
    var value = uniform.value;

    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: 'm3',
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  var extensions = {};

  for (var key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }

  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};
/**
 * @author bhouston / http://clara.io
 */


function Ray(origin, direction) {
  this.origin = origin !== undefined ? origin : new Vector3();
  this.direction = direction !== undefined ? direction : new Vector3();
}

Object.assign(Ray.prototype, {
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function () {
    var v1 = new Vector3();
    return function recast(t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    target.subVectors(point, this.origin);
    var directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function (point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function () {
    var v1 = new Vector3();
    return function distanceSqToPoint(point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction); // point behind the ray

      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }

      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function () {
    var segCenter = new Vector3();
    var segDir = new Vector3();
    var diff = new Vector3();
    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;

      if (det > 0) {
        // The ray and segment are not parallel.
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }

      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }

      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }

      return sqrDist;
    };
  }(),
  intersectSphere: function () {
    var v1 = new Vector3();
    return function intersectSphere(sphere, target) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.

      if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

      return this.at(t0, target);
    };
  }(),
  intersectsSphere: function (sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, target) {
    var t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  },
  intersectsPlane: function (plane) {
    // check if the ray lies on the plane first
    var distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    var denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  },
  intersectBox: function (box, target) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;
    var origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function () {
    var v = new Vector3();
    return function intersectsBox(box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectTriangle: function () {
    // Compute the offset origin, edges, and normal.
    var diff = new Vector3();
    var edge1 = new Vector3();
    var edge2 = new Vector3();
    var normal = new Vector3();
    return function intersectTriangle(a, b, c, backfaceCulling, target) {
      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)

      var DdN = this.direction.dot(normal);
      var sign;

      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }

      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2)); // b1 < 0, no intersection

      if (DdQxE2 < 0) {
        return null;
      }

      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff)); // b2 < 0, no intersection

      if (DdE1xQ < 0) {
        return null;
      } // b1+b2 > 1, no intersection


      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      } // Line intersects triangle, check if ray does.


      var QdN = -sign * diff.dot(normal); // t < 0, no intersection

      if (QdN < 0) {
        return null;
      } // Ray intersects triangle.


      return this.at(QdN / DdN, target);
    };
  }(),
  applyMatrix4: function (matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle(a, b, c) {
  this.a = a !== undefined ? a : new Vector3();
  this.b = b !== undefined ? b : new Vector3();
  this.c = c !== undefined ? c : new Vector3();
}

Object.assign(Triangle, {
  getNormal: function () {
    var v0 = new Vector3();
    return function getNormal(a, b, c, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .getNormal() target is now required');
        target = new Vector3();
      }

      target.subVectors(c, b);
      v0.subVectors(a, b);
      target.cross(v0);
      var targetLengthSq = target.lengthSq();

      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }

      return target.set(0, 0, 0);
    };
  }(),
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function () {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function getBarycoord(point, a, b, c, target) {
      v0.subVectors(c, a);
      v1.subVectors(b, a);
      v2.subVectors(point, a);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = dot00 * dot11 - dot01 * dot01;

      if (target === undefined) {
        console.warn('THREE.Triangle: .getBarycoord() target is now required');
        target = new Vector3();
      } // collinear or singular triangle


      if (denom === 0) {
        // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
      }

      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

      return target.set(1 - u - v, v, u);
    };
  }(),
  containsPoint: function () {
    var v1 = new Vector3();
    return function containsPoint(point, a, b, c) {
      Triangle.getBarycoord(point, a, b, c, v1);
      return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
    };
  }(),
  getUV: function () {
    var barycoord = new Vector3();
    return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, barycoord);
      target.set(0, 0);
      target.addScaledVector(uv1, barycoord.x);
      target.addScaledVector(uv2, barycoord.y);
      target.addScaledVector(uv3, barycoord.z);
      return target;
    };
  }()
});
Object.assign(Triangle.prototype, {
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function () {
    var v0 = new Vector3();
    var v1 = new Vector3();
    return function getArea() {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  getMidpoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function (target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Vector3();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function (point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  containsPoint: function (point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  getUV: function (point, uv1, uv2, uv3, result) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
  },
  intersectsBox: function (box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function () {
    var vab = new Vector3();
    var vac = new Vector3();
    var vbc = new Vector3();
    var vap = new Vector3();
    var vbp = new Vector3();
    var vcp = new Vector3();
    return function closestPointToPoint(p, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
        target = new Vector3();
      }

      var a = this.a,
          b = this.b,
          c = this.c;
      var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
      // under the accompanying license; see chapter 5.1.5 for detailed explanation.
      // basically, we're distinguishing which of the voronoi regions of the triangle
      // the point lies in with the minimum amount of redundant computation.

      vab.subVectors(b, a);
      vac.subVectors(c, a);
      vap.subVectors(p, a);
      var d1 = vab.dot(vap);
      var d2 = vac.dot(vap);

      if (d1 <= 0 && d2 <= 0) {
        // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
      }

      vbp.subVectors(p, b);
      var d3 = vab.dot(vbp);
      var d4 = vac.dot(vbp);

      if (d3 >= 0 && d4 <= d3) {
        // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
      }

      var vc = d1 * d4 - d3 * d2;

      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

        return target.copy(a).addScaledVector(vab, v);
      }

      vcp.subVectors(p, c);
      var d5 = vab.dot(vcp);
      var d6 = vac.dot(vcp);

      if (d6 >= 0 && d5 <= d6) {
        // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
      }

      var vb = d5 * d2 - d1 * d6;

      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

        return target.copy(a).addScaledVector(vac, w);
      }

      var va = d3 * d6 - d5 * d4;

      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

        return target.copy(b).addScaledVector(vbc, w); // edge region of BC
      } // face region


      var denom = 1 / (va + vb + vc); // u = va * denom

      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
    };
  }(),
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new Color(0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */


function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new MeshBasicMaterial({
    color: Math.random() * 0xffffff
  });
  this.drawMode = TrianglesDrawMode;
  this.updateMorphTargets();
}

Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function (value) {
    this.drawMode = value;
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.drawMode = source.drawMode;

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    return this;
  },
  updateMorphTargets: function () {
    var geometry = this.geometry;
    var m, ml, name;

    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (m = 0, ml = morphAttribute.length; m < ml; m++) {
            name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  raycast: function () {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var tempA = new Vector3();
    var tempB = new Vector3();
    var tempC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    var intersectionPoint = new Vector3();
    var intersectionPointWorld = new Vector3();

    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
      var intersect;

      if (material.side === BackSide) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
      }

      if (intersect === null) return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far) return null;
      return {
        distance: distance,
        point: intersectionPointWorld.clone(),
        object: object
      };
    }

    function checkBufferGeometryIntersection(object, material, raycaster, ray, position, uv, a, b, c) {
      vA.fromBufferAttribute(position, a);
      vB.fromBufferAttribute(position, b);
      vC.fromBufferAttribute(position, c);
      var intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);

      if (intersection) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a);
          uvB.fromBufferAttribute(uv, b);
          uvC.fromBufferAttribute(uv, c);
          intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
        }

        var face = new Face3(a, b, c);
        Triangle.getNormal(vA, vB, vC, face.normal);
        intersection.face = face;
      }

      return intersection;
    }

    return function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix); // Check boundingBox before continuing

      if (geometry.boundingBox !== null) {
        if (ray.intersectsBox(geometry.boundingBox) === false) return;
      }

      var intersection;

      if (geometry.isBufferGeometry) {
        var a, b, c;
        var index = geometry.index;
        var position = geometry.attributes.position;
        var uv = geometry.attributes.uv;
        var groups = geometry.groups;
        var drawRange = geometry.drawRange;
        var i, j, il, jl;
        var group, groupMaterial;
        var start, end;

        if (index !== null) {
          // indexed buffer geometry
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = index.getX(j);
                b = index.getX(j + 1);
                c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = index.getX(i);
              b = index.getX(i + 1);
              c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        } else if (position !== undefined) {
          // non-indexed buffer geometry
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = j;
                b = j + 1;
                c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(position.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = i;
              b = i + 1;
              c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var uvs;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

        for (var f = 0, fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === undefined) continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];

          if (faceMaterial.morphTargets === true) {
            var morphTargets = geometry.morphTargets;
            var morphInfluences = this.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);

            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
              var influence = morphInfluences[t];
              if (influence === 0) continue;
              var targets = morphTargets[t].vertices;
              vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
              vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
              vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }

            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
          }

          intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

          if (intersection) {
            if (uvs && uvs[f]) {
              var uvs_f = uvs[f];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
            }

            intersection.face = face;
            intersection.faceIndex = f;
            intersects.push(intersection);
          }
        }
      }
    };
  }(),
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new Color(0x000000);
  var clearAlpha = 0;
  var planeMesh;
  var boxMesh; // Store the current background texture and its `version`
  // so we can recompile the material accordingly.

  var currentBackground = null;
  var currentBackgroundVersion = 0;

  function render(renderList, scene, camera, forceClear) {
    var background = scene.background;

    if (background === null) {
      setClear(clearColor, clearAlpha);
      currentBackground = null;
      currentBackgroundVersion = 0;
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
      currentBackground = null;
      currentBackgroundVersion = 0;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          type: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.removeAttribute('normal');
        boxMesh.geometry.removeAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'map', {
          get: function () {
            return this.uniforms.tCube.value;
          }
        });
        objects.update(boxMesh);
      }

      var texture = background.isWebGLRenderTargetCube ? background.texture : background;
      boxMesh.material.uniforms.tCube.value = texture;
      boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;

      if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          type: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.removeAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== undefined ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension;

    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](mode, start, count, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    var extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }

  var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(34930);
  var maxVertexTextures = gl.getParameter(35660);
  var maxTextureSize = gl.getParameter(3379);
  var maxCubemapSize = gl.getParameter(34076);
  var maxAttributes = gl.getParameter(34921);
  var maxVertexUniforms = gl.getParameter(36347);
  var maxVaryings = gl.getParameter(36348);
  var maxFragmentUniforms = gl.getParameter(36349);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}
/**
 * @author tschw
 */


function WebGLClipping() {
  var scope = this,
      globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false,
      plane = new Plane(),
      viewNormalMatrix = new Matrix3(),
      uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4,
          dstArray = cache.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0,
        dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    return dstArray;
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function (name) {
      if (extensions[name] !== undefined) {
        return extensions[name];
      }

      var extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      extensions[name] = extension;
      return extension;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLGeometries(gl, attributes, info) {
  var geometries = {};
  var wireframeAttributes = {};

  function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries[geometry.id];

    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }

    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes[buffergeometry.id];

    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[buffergeometry.id];
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry) return buffergeometry;
    geometry.addEventListener('dispose', onGeometryDispose);

    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }

      buffergeometry = geometry._bufferGeometry;
    }

    geometries[geometry.id] = buffergeometry;
    info.memory.geometries++;
    return buffergeometry;
  }

  function update(geometry) {
    var index = geometry.index;
    var geometryAttributes = geometry.attributes;

    if (index !== null) {
      attributes.update(index, 34963);
    }

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    var morphAttributes = geometry.morphAttributes;

    for (var name in morphAttributes) {
      var array = morphAttributes[name];

      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }

  function getWireframeAttribute(geometry) {
    var attribute = wireframeAttributes[geometry.id];
    if (attribute) return attribute;
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryAttributes = geometry.attributes; // console.time( 'wireframe' );

    if (geometryIndex !== null) {
      var array = geometryIndex.array;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryAttributes.position.array;

      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } // console.timeEnd( 'wireframe' );


    attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attributes.update(attribute, 34963);
    wireframeAttributes[geometry.id] = attribute;
    return attribute;
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  var type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension;

    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      var extension = extensions.get('ANGLE_instanced_arrays');

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 5:
      case 6:
        render.triangles += instanceCount * (count - 2);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);

  function update(object, geometry, material, program) {
    var objectInfluences = object.morphTargetInfluences;
    var length = objectInfluences.length;
    var influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (var i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    }

    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry.morphAttributes.normal; // Remove current morphAttributes

    for (var i = 0; i < length; i++) {
      var influence = influences[i];

      if (influence[1] !== 0) {
        if (morphTargets) geometry.removeAttribute('morphTarget' + i);
        if (morphNormals) geometry.removeAttribute('morphNormal' + i);
      }
    } // Collect influences


    for (var i = 0; i < length; i++) {
      var influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort); // Add morphAttributes

    for (var i = 0; i < 8; i++) {
      var influence = influences[i];

      if (influence) {
        var index = influence[0];
        var value = influence[1];

        if (value) {
          if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
          if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);
          morphInfluences[i] = value;
          continue;
        }
      }

      morphInfluences[i] = 0;
    }

    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLObjects(geometries, info) {
  var updateList = {};

  function update(object) {
    var frame = info.render.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateList[buffergeometry.id] !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }

      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame;
    }

    return buffergeometry;
  }

  function dispose() {
    updateList = {};
  }

  return {
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  format = format !== undefined ? format : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}

CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});
/**
 * @author Artur Trzesiok
 */

function DataTexture3D(data, width, height, depth) {
  // We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	var texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  Texture.call(this, null);
  this.image = {
    data: data,
    width: width,
    height: height,
    depth: depth
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
}

DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture(); // --- Base for inner nodes (including the root) ---

function UniformContainer() {
  this.seq = [];
  this.map = {};
} // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)


var arrayCacheF32 = [];
var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  var n = nBlocks * blockSize,
      r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(renderer, n) {
  var r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValue1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}

function setValue1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValue2fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValue3fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValue4fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or MatrixN)


function setValue2fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValue3fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValue4fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single texture (2D / Cube)


function setValueT1(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  renderer.setTexture2D(v || emptyTexture, unit);
}

function setValueT3D1(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  renderer.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  renderer.setTextureCube(v || emptyCubeTexture, unit);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValue2iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValue3iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValue4iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValue1f;
    // FLOAT

    case 0x8b50:
      return setValue2fv;
    // _VEC2

    case 0x8b51:
      return setValue3fv;
    // _VEC3

    case 0x8b52:
      return setValue4fv;
    // _VEC4

    case 0x8b5a:
      return setValue2fm;
    // _MAT2

    case 0x8b5b:
      return setValue3fm;
    // _MAT3

    case 0x8b5c:
      return setValue4fm;
    // _MAT4

    case 0x8b5e:
    case 0x8d66:
      return setValueT1;
    // SAMPLER_2D, SAMPLER_EXTERNAL_OES

    case 0x8B5F:
      return setValueT3D1;
    // SAMPLER_3D

    case 0x8b60:
      return setValueT6;
    // SAMPLER_CUBE

    case 0x1404:
    case 0x8b56:
      return setValue1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValue2iv;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValue3iv;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValue4iv;
    // _VEC4
  }
} // Array of scalars


function setValue1fv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1fv(this.addr, v);
  copyArray(cache, v);
}

function setValue1iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1iv(this.addr, v);
  copyArray(cache, v);
} // Array of vectors (flat or from THREE classes)


function setValueV2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 2);
  if (arraysEqual(cache, data)) return;
  gl.uniform2fv(this.addr, data);
  this.updateCache(data);
}

function setValueV3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 3);
  if (arraysEqual(cache, data)) return;
  gl.uniform3fv(this.addr, data);
  this.updateCache(data);
}

function setValueV4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniform4fv(this.addr, data);
  this.updateCache(data);
} // Array of matrices (flat or from THREE clases)


function setValueM2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix2fv(this.addr, false, data);
  this.updateCache(data);
}

function setValueM3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 9);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix3fv(this.addr, false, data);
  this.updateCache(data);
}

function setValueM4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 16);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix4fv(this.addr, false, data);
  this.updateCache(data);
} // Array of textures (2D / Cube)


function setValueT1a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);

  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }

  for (var i = 0; i !== n; ++i) {
    renderer.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);

  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }

  for (var i = 0; i !== n; ++i) {
    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValue1fv;
    // FLOAT

    case 0x8b50:
      return setValueV2a;
    // _VEC2

    case 0x8b51:
      return setValueV3a;
    // _VEC3

    case 0x8b52:
      return setValueV4a;
    // _VEC4

    case 0x8b5a:
      return setValueM2a;
    // _MAT2

    case 0x8b5b:
      return setValueM3a;
    // _MAT3

    case 0x8b5c:
      return setValueM4a;
    // _MAT4

    case 0x8b5e:
      return setValueT1a;
    // SAMPLER_2D

    case 0x8b60:
      return setValueT6a;
    // SAMPLER_CUBE

    case 0x1404:
    case 0x8b56:
      return setValue1iv;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValue2iv;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValue3iv;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValue4iv;
    // _VEC4
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  var cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  UniformContainer.call(this); // mix-in
}

StructuredUniform.prototype.setValue = function (gl, value, renderer) {
  var seq = this.seq;

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    u.setValue(gl, value[u.id], renderer);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name,
      pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    var match = RePathPart.exec(path),
        matchEnd = RePathPart.lastIndex,
        id = match[1],
        idIsIndex = match[2] === ']',
        subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      var map = container.map,
          next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program, renderer) {
  UniformContainer.call(this);
  this.renderer = renderer;
  var n = gl.getProgramParameter(program, 35718);

  for (var i = 0; i < n; ++i) {
    var info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value) {
  var u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, this.renderer);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  var v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, renderer) {
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i],
        v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, renderer);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  var r = [];

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function addLineNumbers(string) {
  var lines = string.split('\n');

  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function WebGLShader(gl, type, string) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);

  if (gl.getShaderParameter(shader, 35713) === false) {
    console.error('THREE.WebGLShader: Shader couldn\'t compile.');
  }

  if (gl.getShaderInfoLog(shader) !== '') {
    console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
  } // --enable-privileged-webgl-extension
  // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );


  return shader;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


var programIdCount = 0;

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    default:
      throw new Error('unsupported encoding: ' + encoding);
  }
}

function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case Uncharted2ToneMapping:
      toneMappingName = 'Uncharted2';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    default:
      throw new Error('unsupported toneMapping: ' + toneMapping);
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  var chunks = [];

  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, 35721);

  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

function parseIncludes(string) {
  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function replace(match, include) {
    var replace = ShaderChunk[include];

    if (replace === undefined) {
      throw new Error('Can not resolve #include <' + include + '>');
    }

    return parseIncludes(replace);
  }

  return string.replace(pattern, replace);
}

function unrollLoops(string) {
  var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  function replace(match, start, end, snippet) {
    var unroll = '';

    for (var i = parseInt(start); i < parseInt(end); i++) {
      unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
    }

    return unroll;
  }

  return string.replace(pattern, replace);
}

function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
  var gl = renderer.context;
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  }

  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;

      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;

      case SphericalReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
        break;
    }

    switch (material.envMap.mapping) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }

    switch (material.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0; // console.log( 'building new program ' );
  //

  var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);
  var customDefines = generateDefines(defines); //

  var program = gl.createProgram();
  var prefixVertex, prefixFragment;

  if (material.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
    var isGLSL3ShaderMaterial = false;
    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

    if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, '');
      fragmentShader = fragmentShader.replace(versionRegex, '');
    } // GLSL 3.0 conversion


    prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (material.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program);
  var programLog = gl.getProgramInfoLog(program).trim();
  var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
  var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
  var runnable = true;
  var haveDiagnostics = true; // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  if (gl.getProgramParameter(program, 35714) === false) {
    runnable = false;
    console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
  } else if (programLog !== '') {
    console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
  } else if (vertexLog === '' || fragmentLog === '') {
    haveDiagnostics = false;
  }

  if (haveDiagnostics) {
    this.diagnostics = {
      runnable: runnable,
      material: material,
      programLog: programLog,
      vertexShader: {
        log: vertexLog,
        prefix: prefixVertex
      },
      fragmentShader: {
        log: fragmentLog,
        prefix: prefixFragment
      }
    };
  } // clean up


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  var cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program, renderer);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  var cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    gl.deleteProgram(program);
    this.program = undefined;
  }; // DEPRECATED


  Object.defineProperties(this, {
    uniforms: {
      get: function () {
        console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
        return this.getUniforms();
      }
    },
    attributes: {
      get: function () {
        console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
        return this.getAttributes();
      }
    }
  }); //

  this.name = shader.name;
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLPrograms(renderer, extensions, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'phong',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;

    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;

    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.


    if (encoding === LinearEncoding && gammaOverrideLinear) {
      encoding = GammaEncoding;
    }

    return encoding;
  }

  this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = capabilities.precision;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID: shaderID,
      precision: precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      fog: !!fog,
      useFog: material.fog,
      fogExp: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
    };
    return parameters;
  };

  this.getProgramCode = function (material, parameters) {
    var array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }

    if (material.defines !== undefined) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }

    for (var i = 0; i < parameterNames.length; i++) {
      array.push(parameters[parameterNames[i]]);
    }

    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    array.push(renderer.gammaFactor);
    return array.join();
  };

  this.acquireProgram = function (material, shader, parameters, code) {
    var program; // Check if code has been already compiled

    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];

      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);
      programs.push(program);
    }

    return program;
  };

  this.releaseProgram = function (program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }; // Exposed for resource monitoring & error feedback via renderer.info:


  this.programs = programs;
}
/**
 * @author fordacious / fordacious.github.io
 */


function WebGLProperties() {
  var properties = new WeakMap();

  function get(object) {
    var map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program && b.program && a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transparent = [];

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    var renderItem = renderItems[renderItemsIndex];

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: material.program,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = material.program;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }

  function sort() {
    if (opaque.length > 1) opaque.sort(painterSortStable);
    if (transparent.length > 1) transparent.sort(reversePainterSortStable);
  }

  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    sort: sort
  };
}

function WebGLRenderLists() {
  var lists = {};

  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    delete lists[scene.id];
  }

  function get(scene, camera) {
    var cameras = lists[scene.id];
    var list;

    if (cameras === undefined) {
      list = new WebGLRenderList();
      lists[scene.id] = {};
      lists[scene.id][camera.id] = list;
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      list = cameras[camera.id];

      if (list === undefined) {
        list = new WebGLRenderList();
        cameras[camera.id] = list;
      }
    }

    return list;
  }

  function dispose() {
    lists = {};
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function UniformsCache() {
  var lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color(),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3() // TODO (abelnation): set RectAreaLight shadow uniforms

          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

var count = 0;

function WebGLLights() {
  var cache = new UniformsCache();
  var state = {
    id: count++,
    hash: {
      stateID: -1,
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      shadowsLength: -1
    },
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();

  function setup(lights, shadows, camera) {
    var r = 0,
        g = 0,
        b = 0;
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;

    for (var i = 0, l = lights.length; i < l; i++) {
      var light = lights[i];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }

        state.directionalShadowMap[directionalLength] = shadowMap;
        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }

        state.spotShadowMap[spotLength] = shadowMap;
        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          uniforms.shadowCameraNear = shadow.camera.near;
          uniforms.shadowCameraFar = shadow.camera.far;
        }

        state.pointShadowMap[pointLength] = shadowMap;
        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    state.directional.length = directionalLength;
    state.spot.length = spotLength;
    state.rectArea.length = rectAreaLength;
    state.point.length = pointLength;
    state.hemi.length = hemiLength;
    state.hash.stateID = state.id;
    state.hash.directionalLength = directionalLength;
    state.hash.pointLength = pointLength;
    state.hash.spotLength = spotLength;
    state.hash.rectAreaLength = rectAreaLength;
    state.hash.hemiLength = hemiLength;
    state.hash.shadowsLength = shadows.length;
  }

  return {
    setup: setup,
    state: state
  };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLRenderState() {
  var lights = new WebGLLights();
  var lightsArray = [];
  var shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }

  var state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates() {
  var renderStates = {};

  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    delete renderStates[scene.id];
  }

  function get(scene, camera) {
    var renderState;

    if (renderStates[scene.id] === undefined) {
      renderState = new WebGLRenderState();
      renderStates[scene.id] = {};
      renderStates[scene.id][camera.id] = renderState;
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      if (renderStates[scene.id][camera.id] === undefined) {
        renderState = new WebGLRenderState();
        renderStates[scene.id][camera.id] = renderState;
      } else {
        renderState = renderStates[scene.id][camera.id];
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = {};
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */


function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */


function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  var _frustum = new Frustum(),
      _projScreenMatrix = new Matrix4(),
      _shadowMapSize = new Vector2(),
      _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize),
      _lookTarget = new Vector3(),
      _lightPositionWorld = new Vector3(),
      _MorphingFlag = 1,
      _SkinningFlag = 2,
      _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
      _depthMaterials = new Array(_NumberOfMaterialVariants),
      _distanceMaterials = new Array(_NumberOfMaterialVariants),
      _materialCache = {};

  var shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  var cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
  var cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
  var cube2DViewPorts = [new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4()]; // init

  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i] = depthMaterial; //

    var distanceMaterial = new MeshDistanceMaterial({
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i] = distanceMaterial;
  } //


  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    var currentRenderTarget = _renderer.getRenderTarget();

    var _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    var faceCount;

    for (var i = 0, il = lights.length; i < il; i++) {
      var light = lights[i];
      var shadow = light.shadow;
      var isPointLight = light && light.isPointLight;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      var shadowCamera = shadow.camera;

      _shadowMapSize.copy(shadow.mapSize);

      _shadowMapSize.min(_maxShadowMapSize);

      if (isPointLight) {
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y; // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X

        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight); // negative X

        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight); // positive Z

        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight); // negative Z

        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight); // positive Y

        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight); // negative Y

        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4.0;
        _shadowMapSize.y *= 2.0;
      }

      if (shadow.map === null) {
        var pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadowCamera.updateProjectionMatrix();
      }

      if (shadow.isSpotLightShadow) {
        shadow.update(light);
      }

      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;

      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

      shadowCamera.position.copy(_lightPositionWorld);

      if (isPointLight) {
        faceCount = 6; // for point lights we set the shadow matrix to be a translation-only matrix
        // equal to inverse of the light's position

        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      } else {
        faceCount = 1;

        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);

        shadowCamera.lookAt(_lookTarget);
        shadowCamera.updateMatrixWorld(); // compute shadow matrix

        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }

      _renderer.setRenderTarget(shadowMap);

      _renderer.clear(); // render shadow map for each cube face (if omni-directional) or
      // run a single pass if not


      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);

          _lookTarget.add(cubeDirections[face]);

          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          var vpDimensions = cube2DViewPorts[face];

          _state.viewport(vpDimensions);
        } // update camera matrices and frustum


        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

        _frustum.setFromMatrix(_projScreenMatrix); // set object matrices & frustum culling


        renderObject(scene, camera, shadowCamera, isPointLight);
      }
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget);
  };

  function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
    var geometry = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;

    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }

    if (!customMaterial) {
      var useMorphing = false;

      if (material.morphTargets) {
        if (geometry && geometry.isBufferGeometry) {
          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        } else if (geometry && geometry.isGeometry) {
          useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
        }
      }

      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
      }

      var useSkinning = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing) variantIndex |= _MorphingFlag;
      if (useSkinning) variantIndex |= _SkinningFlag;
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      var keyA = result.uuid,
          keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      var cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;
    result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (isPointLight && result.isMeshDistanceMaterial) {
      result.referencePosition.copy(lightPositionWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, isPointLight) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        var geometry = _objects.update(object);

        var material = object.material;

        if (Array.isArray(material)) {
          var groups = geometry.groups;

          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, isPointLight);
    }
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLState(gl, extensions, utils, capabilities) {
  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (stencilTest) {
          enable(2960);
        } else {
          disable(2960);
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(34921);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var enabledCapabilities = {};
  var compressedTextureFormats = null;
  var currentProgram = null;
  var currentBlendingEnabled = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(35661);
  var lineWidthAvailable = false;
  var version = 0;
  var glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new Vector4();
  var currentViewport = new Vector4();

  function createTexture(type, target, count) {
    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (var i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  var emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];

      if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1') || extensions.get('WEBGL_compressed_texture_astc')) {
        var formats = gl.getParameter(34467);

        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }

    return compressedTextureFormats;
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }

    enabledCapabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    enableAttributeAndDivisor: enableAttributeAndDivisor,
    disableUnusedAttributes: disableUnusedAttributes,
    enable: enable,
    disable: disable,
    getCompressedTextureFormats: getCompressedTextureFormats,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _videoTextures = {};

  var _canvas; //


  var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    var scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (image instanceof ImageBitmap || image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
        var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
        var width = floor(scale * image.width);
        var height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return useOffscreenCanvas ? canvas.transferToImageBitmap() : canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo(image) {
    return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (capabilities.isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }

  function getInternalFormat(glFormat, glType) {
    if (!capabilities.isWebGL2) return glFormat;
    var internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    } else if (internalFormat === 34843 || internalFormat === 34837) {
      console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
    }

    return internalFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      delete _videoTextures[texture.id];
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  } //


  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    _gl.deleteTexture(textureProperties.__webglTexture);

    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }

    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  } //


  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);

        _gl.pixelStorei(37440, texture.flipY);

        var isCompressed = texture && texture.isCompressedTexture;
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];

        for (var i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }

        var image = cubeImage[0],
            supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
            glFormat = utils.convert(texture.format),
            glType = utils.convert(texture.type),
            glInternalFormat = getInternalFormat(glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);

        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap,
                mipmaps = cubeImage[i].mipmaps;

            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];

              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                }
              } else {
                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }

        if (!isCompressed) {
          textureProperties.__maxMipLevel = 0;
        } else {
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        }

        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          // We assume images for cube map have the same size.
          generateMipmap(34067, texture, image.width, image.height);
        }

        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      } else {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
      }
    }
  }

  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, properties.get(texture).__webglTexture);
  }

  function setTextureParameters(textureType, texture, supportsMips) {
    var extension;

    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));

      _gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));

      if (textureType === 32879) {
        _gl.texParameteri(textureType, 32882, utils.convert(texture.wrapR));
      }

      _gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));

      _gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension) {
      if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    var textureType = texture.isDataTexture3D ? 32879 : 3553;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);
    var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
        glFormat = utils.convert(texture.format),
        glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    var mipmap,
        mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = 6402;

      if (texture.type === FloatType) {
        if (!capabilities.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
        glInternalFormat = 36012;
      } else if (capabilities.isWebGL2) {
        // WebGL 2.0 requires signed internalformat for glTexImage2D
        glInternalFormat = 33189;
      }

      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      } // Depth stencil textures need the DEPTH_STENCIL internal format
      // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)


      if (texture.format === DepthStencilFormat) {
        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }

      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(3553, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = utils.convert(renderTarget.texture.format);
    var glType = utils.convert(renderTarget.texture.type);
    var glInternalFormat = getInternalFormat(glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

    _gl.bindFramebuffer(36160, framebuffer);

    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

    _gl.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 34041, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      var glFormat = utils.convert(renderTarget.texture.format);
      var glType = utils.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(glFormat, glType);

      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

    _gl.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (var i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }

    _gl.bindFramebuffer(36160, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2; // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultisample) {
        if (capabilities.isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

          var glFormat = utils.convert(renderTarget.texture.format);
          var glType = utils.convert(renderTarget.texture.type);
          var glInternalFormat = getInternalFormat(glFormat, glType);
          var samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

          _gl.bindRenderbuffer(36161, null);

          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }

          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);

      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(3553, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;

      var webglTexture = properties.get(texture).__webglTexture;

      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (capabilities.isWebGL2) {
        var renderTargetProperties = properties.get(renderTarget);

        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

        var width = renderTarget.width;
        var height = renderTarget.height;
        var mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;

        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
  }

  function updateVideoTexture(texture) {
    var id = texture.id;
    var frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures[id] !== frame) {
      _videoTextures[id] = frame;
      texture.update();
    }
  }

  this.setTexture2D = setTexture2D;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
}
/**
 * @author thespite / http://www.twitter.com/thespite
 */


function WebGLUtils(gl, extensions, capabilities) {
  function convert(p) {
    var extension;
    if (p === RepeatWrapping) return 10497;
    if (p === ClampToEdgeWrapping) return 33071;
    if (p === MirroredRepeatWrapping) return 33648;
    if (p === NearestFilter) return 9728;
    if (p === NearestMipMapNearestFilter) return 9984;
    if (p === NearestMipMapLinearFilter) return 9986;
    if (p === LinearFilter) return 9729;
    if (p === LinearMipMapNearestFilter) return 9985;
    if (p === LinearMipMapLinearFilter) return 9987;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (capabilities.isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');
      if (extension !== null) return extension.HALF_FLOAT_OES;
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403;
    if (p === AddEquation) return 32774;
    if (p === SubtractEquation) return 32778;
    if (p === ReverseSubtractEquation) return 32779;
    if (p === ZeroFactor) return 0;
    if (p === OneFactor) return 1;
    if (p === SrcColorFactor) return 768;
    if (p === OneMinusSrcColorFactor) return 769;
    if (p === SrcAlphaFactor) return 770;
    if (p === OneMinusSrcAlphaFactor) return 771;
    if (p === DstAlphaFactor) return 772;
    if (p === OneMinusDstAlphaFactor) return 773;
    if (p === DstColorFactor) return 774;
    if (p === OneMinusDstColorFactor) return 775;
    if (p === SrcAlphaSaturateFactor) return 776;

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
    }

    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');
      if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        return p;
      }
    }

    if (p === MinEquation || p === MaxEquation) {
      if (capabilities.isWebGL2) {
        if (p === MinEquation) return 32775;
        if (p === MaxEquation) return 32776;
      }

      extension = extensions.get('EXT_blend_minmax');

      if (extension !== null) {
        if (p === MinEquation) return extension.MIN_EXT;
        if (p === MaxEquation) return extension.MAX_EXT;
      }
    }

    if (p === UnsignedInt248Type) {
      if (capabilities.isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');
      if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
    }

    return 0;
  }

  return {
    convert: convert
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function Group() {
  Object3D.call(this);
  this.type = 'Group';
}

Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {
  Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}

Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov !== undefined ? fov : 50;
  this.zoom = 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.focus = 10;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)

  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },

  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    // see http://www.bobatkins.com/photography/technical/field_of_view.html
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },

  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var near = this.near,
        top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
        height = 2 * top,
        width = this.aspect * height,
        left = -0.5 * width,
        view = this.view;

    if (this.view !== null && this.view.enabled) {
      var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    var skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}

ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
/**
 * @author jsantell / https://www.jsantell.com/
 * @author mrdoob / http://mrdoob.com/
 */

var cameraLPos = new Vector3();
var cameraRPos = new Vector3();
/**
 * Assumes 2 cameras that are parallel and share an X-axis, and that
 * the cameras' projection and world matrices have already been set.
 * And that near and far planes are identical for both cameras.
 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
 */

function setProjectionFromUnion(camera, cameraL, cameraR) {
  cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  var ipd = cameraLPos.distanceTo(cameraRPos);
  var projL = cameraL.projectionMatrix.elements;
  var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
  // most likely identical top and bottom frustum extents.
  // Use the left camera for these values.

  var near = projL[14] / (projL[10] - 1);
  var far = projL[14] / (projL[10] + 1);
  var topFov = (projL[9] + 1) / projL[5];
  var bottomFov = (projL[9] - 1) / projL[5];
  var leftFov = (projL[8] - 1) / projL[0];
  var rightFov = (projR[8] + 1) / projR[0];
  var left = near * leftFov;
  var right = near * rightFov; // Calculate the new camera's position offset from the
  // left camera. xOffset should be roughly half `ipd`.

  var zOffset = ipd / (-leftFov + rightFov);
  var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  camera.matrixWorldInverse.getInverse(camera.matrixWorld); // Find the union of the frustum values of the cameras and scale
  // the values so that the near plane's position does not change in world space,
  // although must now be relative to the new union camera.

  var near2 = near + zOffset;
  var far2 = far + zOffset;
  var left2 = left - xOffset;
  var right2 = right + (ipd - xOffset);
  var top2 = topFov * far / far2 * near2;
  var bottom2 = bottomFov * far / far2 * near2;
  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebVRManager(renderer) {
  var scope = this;
  var device = null;
  var frameData = null;
  var poseTarget = null;
  var controllers = [];
  var standingMatrix = new Matrix4();
  var standingMatrixInverse = new Matrix4();
  var framebufferScaleFactor = 1.0;
  var frameOfReferenceType = 'stage';

  if (typeof window !== 'undefined' && 'VRFrameData' in window) {
    frameData = new window.VRFrameData();
    window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
  }

  var matrixWorldInverse = new Matrix4();
  var tempQuaternion = new Quaternion();
  var tempPosition = new Vector3();
  var cameraL = new PerspectiveCamera();
  cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
  cameraL.layers.enable(1);
  var cameraR = new PerspectiveCamera();
  cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
  cameraR.layers.enable(2);
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  function isPresenting() {
    return device !== null && device.isPresenting === true;
  }

  var currentSize = new Vector2(),
      currentPixelRatio;

  function onVRDisplayPresentChange() {
    if (isPresenting()) {
      var eyeParameters = device.getEyeParameters('left');
      var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
      var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
      currentPixelRatio = renderer.getPixelRatio();
      renderer.getSize(currentSize);
      renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
      animation.start();
    } else {
      if (scope.enabled) {
        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
      }

      animation.stop();
    }
  } //


  var triggers = [];

  function findGamepad(id) {
    var gamepads = navigator.getGamepads && navigator.getGamepads();

    for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {
      var gamepad = gamepads[i];

      if (gamepad && (gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') || gamepad.id.startsWith('Spatial Controller'))) {
        if (j === id) return gamepad;
        j++;
      }
    }
  }

  function updateControllers() {
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var gamepad = findGamepad(i);

      if (gamepad !== undefined && gamepad.pose !== undefined) {
        if (gamepad.pose === null) return; //  Pose

        var pose = gamepad.pose;
        if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);
        if (pose.position !== null) controller.position.fromArray(pose.position);
        if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
        controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
        controller.matrix.premultiply(standingMatrix);
        controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        controller.matrixWorldNeedsUpdate = true;
        controller.visible = true; //  Trigger

        var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

        if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
          triggers[i] = gamepad.buttons[buttonId].pressed;

          if (triggers[i] === true) {
            controller.dispatchEvent({
              type: 'selectstart'
            });
          } else {
            controller.dispatchEvent({
              type: 'selectend'
            });
            controller.dispatchEvent({
              type: 'select'
            });
          }
        }
      } else {
        controller.visible = false;
      }
    }
  } //


  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  };

  this.getDevice = function () {
    return device;
  };

  this.setDevice = function (value) {
    if (value !== undefined) device = value;
    animation.setContext(value);
  };

  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;
  };

  this.setFrameOfReferenceType = function (value) {
    frameOfReferenceType = value;
  };

  this.setPoseTarget = function (object) {
    if (object !== undefined) poseTarget = object;
  };

  this.getCamera = function (camera) {
    var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

    if (isPresenting() === false) {
      camera.position.set(0, userHeight, 0);
      camera.rotation.set(0, 0, 0);
      return camera;
    }

    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData); //

    if (frameOfReferenceType === 'stage') {
      var stageParameters = device.stageParameters;

      if (stageParameters) {
        standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      } else {
        standingMatrix.makeTranslation(0, userHeight, 0);
      }
    }

    var pose = frameData.pose;
    var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them.

    poseObject.matrix.copy(standingMatrix);
    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);

    if (pose.orientation !== null) {
      tempQuaternion.fromArray(pose.orientation);
      poseObject.quaternion.multiply(tempQuaternion);
    }

    if (pose.position !== null) {
      tempQuaternion.setFromRotationMatrix(standingMatrix);
      tempPosition.fromArray(pose.position);
      tempPosition.applyQuaternion(tempQuaternion);
      poseObject.position.add(tempPosition);
    }

    poseObject.updateMatrixWorld(); //

    cameraL.near = camera.near;
    cameraR.near = camera.near;
    cameraL.far = camera.far;
    cameraR.far = camera.far;
    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix); // TODO (mrdoob) Double check this code

    standingMatrixInverse.getInverse(standingMatrix);

    if (frameOfReferenceType === 'stage') {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }

    var parent = poseObject.parent;

    if (parent !== null) {
      matrixWorldInverse.getInverse(parent.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    } // envMap and Mirror needs camera.matrixWorld


    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
    setProjectionFromUnion(cameraVR, cameraL, cameraR); //

    var layers = device.getLayers();

    if (layers.length) {
      var layer = layers[0];

      if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
        cameraL.bounds.fromArray(layer.leftBounds);
      }

      if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
        cameraR.bounds.fromArray(layer.rightBounds);
      }
    }

    updateControllers();
    return cameraVR;
  };

  this.getStandingMatrix = function () {
    return standingMatrix;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var animation = new WebGLAnimation();

  this.setAnimationLoop = function (callback) {
    animation.setAnimationLoop(callback);
  };

  this.submitFrame = function () {
    if (isPresenting()) device.submitFrame();
  };

  this.dispose = function () {
    if (typeof window !== 'undefined') {
      window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebXRManager(renderer) {
  var gl = renderer.context;
  var device = null;
  var session = null;
  var framebufferScaleFactor = 1.0;
  var frameOfReference = null;
  var frameOfReferenceType = 'stage';
  var pose = null;
  var controllers = [];
  var inputSources = [];

  function isPresenting() {
    return session !== null && frameOfReference !== null;
  } //


  var cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  var cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  };

  this.getDevice = function () {
    return device;
  };

  this.setDevice = function (value) {
    if (value !== undefined) device = value;
    if (value instanceof XRDevice) gl.setCompatibleXRDevice(value);
  }; //


  function onSessionEvent(event) {
    var controller = controllers[inputSources.indexOf(event.inputSource)];
    if (controller) controller.dispatchEvent({
      type: event.type
    });
  }

  function onSessionEnd() {
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

    animation.stop();
  }

  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;
  };

  this.setFrameOfReferenceType = function (value) {
    frameOfReferenceType = value;
  };

  this.setSession = function (value) {
    session = value;

    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      session.baseLayer = new XRWebGLLayer(session, gl, {
        framebufferScaleFactor: framebufferScaleFactor
      });
      session.requestFrameOfReference(frameOfReferenceType).then(function (value) {
        frameOfReference = value;
        renderer.setFramebuffer(session.baseLayer.framebuffer);
        animation.setContext(session);
        animation.start();
      }); //

      inputSources = session.getInputSources();
      session.addEventListener('inputsourceschange', function () {
        inputSources = session.getInputSources();
        console.log(inputSources);

        for (var i = 0; i < controllers.length; i++) {
          var controller = controllers[i];
          controller.userData.inputSource = inputSources[i];
        }
      });
    }
  };

  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }

    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }

  this.getCamera = function (camera) {
    if (isPresenting()) {
      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      } // update camera and its children


      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }

      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      return cameraVR;
    }

    return camera;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var onAnimationFrameCallback = null;

  function onAnimationFrame(time, frame) {
    pose = frame.getDevicePose(frameOfReference);

    if (pose !== null) {
      var layer = session.baseLayer;
      var views = frame.views;

      for (var i = 0; i < views.length; i++) {
        var view = views[i];
        var viewport = layer.getViewport(view);
        var viewMatrix = pose.getViewMatrix(view);
        var camera = cameraVR.cameras[i];
        camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
      }
    } //


    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var inputSource = inputSources[i];

      if (inputSource) {
        var inputPose = frame.getInputPose(inputSource, frameOfReference);

        if (inputPose !== null) {
          if ('targetRay' in inputPose) {
            controller.matrix.elements = inputPose.targetRay.transformMatrix;
          } else if ('pointerMatrix' in inputPose) {
            // DEPRECATED
            controller.matrix.elements = inputPose.pointerMatrix;
          }

          controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
          controller.visible = true;
          continue;
        }
      }

      controller.visible = false;
    }

    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };

  this.dispose = function () {}; // DEPRECATED


  this.getStandingMatrix = function () {
    console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
    return new Matrix4();
  };

  this.submitFrame = function () {};
}
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */


function WebGLRenderer(parameters) {
  console.log('THREE.WebGLRenderer', REVISION);
  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
      _context = parameters.context !== undefined ? parameters.context : null,
      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
      _depth = parameters.depth !== undefined ? parameters.depth : true,
      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
      _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

  var currentRenderList = null;
  var currentRenderState = null; // public properties

  this.domElement = _canvas;
  this.context = null; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.gammaInput = false;
  this.gammaOutput = false; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = LinearToneMapping;
  this.toneMappingExposure = 1.0;
  this.toneMappingWhitePoint = 1.0; // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4; // internal properties

  var _this = this,
      _isContextLost = false,
      // internal state cache
  _framebuffer = null,
      _currentRenderTarget = null,
      _currentFramebuffer = null,
      _currentMaterialId = -1,
      // geometry and program caching
  _currentGeometryProgram = {
    geometry: null,
    program: null,
    wireframe: false
  },
      _currentCamera = null,
      _currentArrayCamera = null,
      _currentViewport = new Vector4(),
      _currentScissor = new Vector4(),
      _currentScissorTest = null,
      //
  _usedTextureUnits = 0,
      //
  _width = _canvas.width,
      _height = _canvas.height,
      _pixelRatio = 1,
      _viewport = new Vector4(0, 0, _width, _height),
      _scissor = new Vector4(0, 0, _width, _height),
      _scissorTest = false,
      // frustum
  _frustum = new Frustum(),
      // clipping
  _clipping = new WebGLClipping(),
      _clippingEnabled = false,
      _localClippingEnabled = false,
      // camera matrices cache
  _projScreenMatrix = new Matrix4(),
      _vector3 = new Vector3();

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  var _gl;

  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

    if (_gl === null) {
      if (_canvas.getContext('webgl') !== null) {
        throw new Error('Error creating WebGL context with your selected attributes.');
      } else {
        throw new Error('Error creating WebGL context.');
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  var extensions, capabilities, state, info;
  var properties, textures, attributes, geometries, objects;
  var programCache, renderLists, renderStates;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);

    if (!capabilities.isWebGL2) {
      extensions.get('WEBGL_depth_texture');
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('OES_element_index_uint');
      extensions.get('ANGLE_instanced_arrays');
    }

    extensions.get('OES_texture_float_linear');
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, utils, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl);
    geometries = new WebGLGeometries(_gl, attributes, info);
    objects = new WebGLObjects(geometries, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.context = _gl;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // vr

  var vr = null;

  if (typeof navigator !== 'undefined') {
    vr = 'xr' in navigator ? new WebXRManager(_this) : new WebVRManager(_this);
  }

  this.vr = vr; // shadow map

  var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (vr.isPresenting()) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = width * _pixelRatio;
    _canvas.height = height * _pixelRatio;

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width * _pixelRatio, _height * _pixelRatio);
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }

    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  }; // Clearing


  this.getClearColor = function () {
    return background.getClearColor();
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    vr.dispose();
    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }

  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = undefined;

    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    var programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);

      _gl.bufferData(34962, object.positionArray, 35048);

      state.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);

      _gl.bufferData(34962, object.normalArray, 35048);

      state.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);

      _gl.bufferData(34962, object.uvArray, 35048);

      state.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);

      _gl.bufferData(34962, object.colorArray, 35048);

      state.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }

    state.disableUnusedAttributes();

    _gl.drawArrays(4, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;

    if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
      _currentGeometryProgram.geometry = geometry.id;
      _currentGeometryProgram.program = program.id;
      _currentGeometryProgram.wireframe = material.wireframe === true;
      updateBuffers = true;
    }

    if (object.morphTargetInfluences) {
      morphtargets.update(object, geometry, material, program);
      updateBuffers = true;
    } //


    var index = geometry.index;
    var position = geometry.attributes.position;
    var rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    var attribute;
    var renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }

    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry);

      if (index !== null) {
        _gl.bindBuffer(34963, attribute.buffer);
      }
    } //


    var dataCount = Infinity;

    if (index !== null) {
      dataCount = index.count;
    } else if (position !== undefined) {
      dataCount = position.count;
    }

    var rangeStart = geometry.drawRange.start * rangeFactor;
    var rangeCount = geometry.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        switch (object.drawMode) {
          case TrianglesDrawMode:
            renderer.setMode(4);
            break;

          case TriangleStripDrawMode:
            renderer.setMode(5);
            break;

          case TriangleFanDrawMode:
            renderer.setMode(6);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (geometry && geometry.isInstancedBufferGeometry) {
      if (geometry.maxInstancedCount > 0) {
        renderer.renderInstances(geometry, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };

  function setupVertexAttributes(material, program, geometry) {
    if (geometry && geometry.isInstancedBufferGeometry && !capabilities.isWebGL2) {
      if (extensions.get('ANGLE_instanced_arrays') === null) {
        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(34962, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(34962, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value);

                break;

              case 3:
                _gl.vertexAttrib3fv(programAttribute, value);

                break;

              case 4:
                _gl.vertexAttrib4fv(programAttribute, value);

                break;

              default:
                _gl.vertexAttrib1fv(programAttribute, value);

            }
          }
        }
      }
    }

    state.disableUnusedAttributes();
  } // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function (object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    scene.traverse(function (object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            initMaterial(object.material[i], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  }; // Animation Loop


  var onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (vr.isPresenting()) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    vr.setAnimationLoop(callback);
    animation.start();
  }; // Rendering


  this.render = function (scene, camera) {
    var renderTarget, forceClear;

    if (arguments[2] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
      renderTarget = arguments[2];
    }

    if (arguments[3] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
      forceClear = arguments[3];
    }

    if (!(camera && camera.isCamera)) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost) return; // reset caching for this frame

    _currentGeometryProgram.geometry = null;
    _currentGeometryProgram.program = null;
    _currentGeometryProgram.wireframe = false;
    _currentMaterialId = -1;
    _currentCamera = null; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (vr.enabled) {
      camera = vr.getCamera(camera);
    } //


    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);

    if (_this.sortObjects === true) {
      currentRenderList.sort();
    } //


    if (_clippingEnabled) _clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled) _clipping.endShadows(); //

    if (this.info.autoReset) this.info.reset();

    if (renderTarget !== undefined) {
      this.setRenderTarget(renderTarget);
    } //


    background.render(currentRenderList, scene, camera, forceClear); // render scene

    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;

    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
    } else {
      // opaque pass (front-to-back order)
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera); // transparent pass (back-to-front order)

      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
    } //


    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering
      textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    } // Ensure depth buffer writing is enabled so it can be cleared on next render


    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    scene.onAfterRender(_this, scene, camera);

    if (vr.enabled) {
      vr.submitFrame();
    } // _gl.finish();


    currentRenderList = null;
    currentRenderState = null;
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;
          currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;

          if (Array.isArray(material)) {
            var groups = geometry.groups;

            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }

  function renderObjects(renderList, scene, camera, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
      var group = renderItem.group;

      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;

        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            if ('viewport' in camera2) {
              // XR
              state.viewport(_currentViewport.copy(camera2.viewport));
            } else {
              var bounds = camera2.bounds;
              var x = bounds.x * _width;
              var y = bounds.y * _height;
              var width = bounds.z * _width;
              var height = bounds.w * _height;
              state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
            }

            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }

  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
    var code = programCache.getProgramCode(material, parameters);
    var program = materialProperties.program;
    var programChange = true;

    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.code !== code) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
      lightsHash.stateID = lightsStateHash.stateID;
      lightsHash.directionalLength = lightsStateHash.directionalLength;
      lightsHash.pointLength = lightsStateHash.pointLength;
      lightsHash.spotLength = lightsStateHash.spotLength;
      lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
      lightsHash.hemiLength = lightsStateHash.hemiLength;
      lightsHash.shadowsLength = lightsStateHash.shadowsLength;
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }

    if (programChange) {
      if (parameters.shaderID) {
        var shader = ShaderLib[parameters.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }

      material.onBeforeCompile(materialProperties.shader, _this); // Computing code again as onBeforeCompile may have changed the shaders

      code = programCache.getProgramCode(material, parameters);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
      materialProperties.program = program;
      material.program = program;
    }

    var programAttributes = program.getAttributes();

    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;

      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes['morphTarget' + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }

    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;

      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes['morphNormal' + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }

    var uniforms = materialProperties.shader.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }

    materialProperties.fog = fog; // store the light setup it was created for

    if (lightsHash === undefined) {
      materialProperties.lightsHash = lightsHash = {};
    }

    lightsHash.stateID = lightsStateHash.stateID;
    lightsHash.directionalLength = lightsStateHash.directionalLength;
    lightsHash.pointLength = lightsStateHash.pointLength;
    lightsHash.spotLength = lightsStateHash.spotLength;
    lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
    lightsHash.hemiLength = lightsStateHash.hemiLength;
    lightsHash.shadowsLength = lightsStateHash.shadowsLength;

    if (material.lights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    var progUniforms = materialProperties.program.getUniforms(),
        uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }

  function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;

    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }

    if (material.needsUpdate === false) {
      if (materialProperties.program === undefined) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }

    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program,
        p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.shader.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen


    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      var skeleton = object.skeleton;

      if (skeleton) {
        var bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === undefined) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

            size = _Math.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

            boneMatrices.set(skeleton.boneMatrices); // copy current values

            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            boneTexture.needsUpdate = true;
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }

          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
      p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

      if (material.lights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }

      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshToonMaterial) {
          refreshUniformsToon(m_uniforms, material);
        } else {
          refreshUniformsPhong(m_uniforms, material);
        }
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(m_uniforms, material);
        } else {
          refreshUniformsStandard(m_uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsMatcap(m_uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDepth(m_uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDistance(m_uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsNormal(m_uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);

        if (material.isLineDashedMaterial) {
          refreshUniformsDash(m_uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(m_uniforms, material);
      } else if (material.isShadowMaterial) {
        m_uniforms.color.value = material.color;
        m_uniforms.opacity.value = material.opacity;
      } // RectAreaLight Texture
      // TODO (mrdoob): Find a nicer implementation


      if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // Uniforms (refresh uniforms objects)


  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value = material.color;
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    if (material.envMap) {
      uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else:
      //  WebGLRenderTargetCube will be flipped for backwards compatibility
      //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
      // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future

      uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);

    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    if (material.envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  } // Textures


  function allocTextureUnit() {
    var textureUnit = _usedTextureUnits;

    if (textureUnit >= capabilities.maxTextures) {
      console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }

    _usedTextureUnits += 1;
    return textureUnit;
  }

  this.allocTextureUnit = allocTextureUnit; // this.setTexture2D = setTexture2D;

  this.setTexture2D = function () {
    var warned = false; // backwards compatibility: peel texture.texture

    return function setTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warned = true;
        }

        texture = texture.texture;
      }

      textures.setTexture2D(texture, slot);
    };
  }();

  this.setTexture3D = function () {
    // backwards compatibility: peel texture.texture
    return function setTexture3D(texture, slot) {
      textures.setTexture3D(texture, slot);
    };
  }();

  this.setTexture = function () {
    var warned = false;
    return function setTexture(texture, slot) {
      if (!warned) {
        console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
        warned = true;
      }

      textures.setTexture2D(texture, slot);
    };
  }();

  this.setTextureCube = function () {
    var warned = false;
    return function setTextureCube(texture, slot) {
      // backwards compatibility: peel texture.texture
      if (texture && texture.isWebGLRenderTargetCube) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warned = true;
        }

        texture = texture.texture;
      } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
      // TODO: unify these code paths


      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        // CompressedTexture can have Array in image :/
        // this function alone should take care of cube textures
        textures.setTextureCube(texture, slot);
      } else {
        // assumed: texture property of THREE.WebGLRenderTargetCube
        textures.setTextureCubeDynamic(texture, slot);
      }
    };
  }(); //


  this.setFramebuffer = function (value) {
    _framebuffer = value;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipMapLevel) {
    _currentRenderTarget = renderTarget;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    var framebuffer = _framebuffer;
    var isCube = false;

    if (renderTarget) {
      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLRenderTargetCube) {
        framebuffer = __webglFramebuffer[activeCubeFace || 0];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);

      _currentScissorTest = _scissorTest;
    }

    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);

      _currentFramebuffer = framebuffer;
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace || 0, textureProperties.__webglTexture, activeMipMapLevel || 0);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    var framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (framebuffer) {
      var restore = false;

      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);

        restore = true;
      }

      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level) {
    var width = texture.image.width;
    var height = texture.image.height;
    var glFormat = utils.convert(texture.format);
    this.setTexture2D(texture, 0);

    _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    this.setTexture2D(dstTexture, 0);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */


function FogExp2(color, density) {
  this.name = '';
  this.color = new Color(color);
  this.density = density !== undefined ? density : 0.00025;
}

Object.assign(FogExp2.prototype, {
  isFogExp2: true,
  clone: function () {
    return new FogExp2(this.color, this.density);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog(color, near, far) {
  this.name = '';
  this.color = new Color(color);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
}

Object.assign(Fog.prototype, {
  isFog: true,
  clone: function () {
    return new Fog(this.color, this.near, this.far);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {
  Object3D.call(this);
  this.type = 'Scene';
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true; // checked by the renderer
}

Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  isScene: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== undefined ? array.length / stride : 0;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function () {},
  setArray: function (array) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.count = array !== undefined ? array.length / this.stride : 0;
    this.array = array;
    return this;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;

    for (var i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}

Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = 'SpriteMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.lights = false;
  this.transparent = true;
  this.setValues(parameters);
}

SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */


var geometry;

function Sprite(material) {
  Object3D.call(this);
  this.type = 'Sprite';

  if (geometry === undefined) {
    geometry = new BufferGeometry();
    var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
    geometry.setIndex([0, 1, 2, 0, 2, 3]);
    geometry.addAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
    geometry.addAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }

  this.geometry = geometry;
  this.material = material !== undefined ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}

Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function () {
    var intersectPoint = new Vector3();
    var worldScale = new Vector3();
    var mvPosition = new Vector3();
    var alignedPosition = new Vector2();
    var rotatedPosition = new Vector2();
    var viewWorldMatrix = new Matrix4();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();

    function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
      // compute position in camera space
      alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero

      if (sin !== undefined) {
        rotatedPosition.x = cos * alignedPosition.x - sin * alignedPosition.y;
        rotatedPosition.y = sin * alignedPosition.x + cos * alignedPosition.y;
      } else {
        rotatedPosition.copy(alignedPosition);
      }

      vertexPosition.copy(mvPosition);
      vertexPosition.x += rotatedPosition.x;
      vertexPosition.y += rotatedPosition.y; // transform to world space

      vertexPosition.applyMatrix4(viewWorldMatrix);
    }

    return function raycast(raycaster, intersects) {
      worldScale.setFromMatrixScale(this.matrixWorld);
      viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
      mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      var rotation = this.material.rotation;
      var sin, cos;

      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }

      var center = this.center;
      transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
      transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
      transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
      uvA.set(0, 0);
      uvB.set(1, 0);
      uvC.set(1, 1); // check first triangle

      var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);

      if (intersect === null) {
        // check second triangle
        transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
        uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);

        if (intersect === null) {
          return;
        }
      }

      var distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        point: intersectPoint.clone(),
        uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
        face: null,
        object: this
      });
    };
  }(),
  clone: function () {
    return new this.constructor(this.material).copy(this);
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== undefined) this.center.copy(source.center);
    return this;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function LOD() {
  Object3D.call(this);
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
}

LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;

    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }

    return this;
  },
  addLevel: function (object, distance) {
    if (distance === undefined) distance = 0;
    distance = Math.abs(distance);
    var levels = this.levels;

    for (var l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }

    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
  },
  getObjectForDistance: function (distance) {
    var levels = this.levels;

    for (var i = 1, l = levels.length; i < l; i++) {
      if (distance < levels[i].distance) {
        break;
      }
    }

    return levels[i - 1].object;
  },
  raycast: function () {
    var matrixPosition = new Vector3();
    return function raycast(raycaster, intersects) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(matrixPosition);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    };
  }(),
  update: function () {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function update(camera) {
      var levels = this.levels;

      if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance = v1.distanceTo(v2);
        levels[0].object.visible = true;

        for (var i = 1, l = levels.length; i < l; i++) {
          if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }

        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    };
  }(),
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;

    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }

    return data;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
  }

  Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}

SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  bind: function (skeleton, bindMatrix) {
    this.skeleton = skeleton;

    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }

    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    var vector = new Vector4();
    var skinWeight = this.geometry.attributes.skinWeight;

    for (var i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      var scale = 1.0 / vector.manhattanLength();

      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function (force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);

    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  },
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

function Skeleton(bones, boneInverses) {
  // copy the bone array
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16); // use the supplied bone inverses or calculate the inverses

  if (boneInverses === undefined) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.');
      this.boneInverses = [];

      for (var i = 0, il = this.bones.length; i < il; i++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}

Object.assign(Skeleton.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];

    for (var i = 0, il = this.bones.length; i < il; i++) {
      var inverse = new Matrix4();

      if (this.bones[i]) {
        inverse.getInverse(this.bones[i].matrixWorld);
      }

      this.boneInverses.push(inverse);
    }
  },
  pose: function () {
    var bone, i, il; // recover the bind-time world matrices

    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];

      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i]);
      }
    } // compute the local matrices, positions, rotations and scales


    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];

      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function () {
    var offsetMatrix = new Matrix4();
    var identityMatrix = new Matrix4();
    return function update() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture; // flatten bone matrices to array

      for (var i = 0, il = bones.length; i < il; i++) {
        // compute the offset between the current and the original transform
        var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
        offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
        offsetMatrix.toArray(boneMatrices, i * 16);
      }

      if (boneTexture !== undefined) {
        boneTexture.needsUpdate = true;
      }
    };
  }(),
  clone: function () {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function (name) {
    for (var i = 0, il = this.bones.length; i < il; i++) {
      var bone = this.bones[i];

      if (bone.name === name) {
        return bone;
      }
    }

    return undefined;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {
  Object3D.call(this);
  this.type = 'Bone';
}

Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new Color(0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.lights = false;
  this.setValues(parameters);
}

LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
  }

  Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new LineBasicMaterial({
    color: Math.random() * 0xffffff
  });
}

Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  computeLineDistances: function () {
    var start = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [0];

          for (var i = 1, l = positionAttribute.count; i < l; i++) {
            start.fromBufferAttribute(positionAttribute, i - 1);
            end.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += start.distanceTo(end);
          }

          geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;
        lineDistances[0] = 0;

        for (var i = 1, l = vertices.length; i < l; i++) {
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
        }
      }

      return this;
    };
  }(),
  raycast: function () {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects) {
      var precision = raycaster.linePrecision;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += precision;
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localPrecisionSq = localPrecision * localPrecision;
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step = this && this.isLineSegments ? 2 : 1;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, l = indices.length - 1; i < l; i += step) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;

        for (var i = 0; i < nbVertices - 1; i += step) {
          var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    };
  }(),
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.geometry.copy(source.geometry);
    this.material.copy(source.material);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineSegments';
}

LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    var start = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [];

          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
            start.fromBufferAttribute(positionAttribute, i);
            end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
          }

          geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;

        for (var i = 0, l = vertices.length; i < l; i += 2) {
          start.copy(vertices[i]);
          end.copy(vertices[i + 1]);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
        }
      }

      return this;
    };
  }()
});
/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineLoop';
}

LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */


function Points(geometry, material) {
  Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new PointsMaterial({
    color: Math.random() * 0xffffff
  });
}

Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function () {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects) {
      var object = this;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new Vector3();
      var intersectPoint = new Vector3();

      function testPoint(point, index) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);

        if (rayPointDistanceSq < localThresholdSq) {
          ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far) return;
          intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index,
            face: null,
            object: object
          });
        }
      }

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, il = indices.length; i < il; i++) {
            var a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (var i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      } else {
        var vertices = geometry.vertices;

        for (var i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i);
        }
      }
    };
  }(),
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== undefined ? format : RGBFormat;
  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.generateMipmaps = false;
}

VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function () {
    var video = this.image;

    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps; // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false; // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;
}

CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}

CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== undefined ? format : DepthFormat;

  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
  }

  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}

DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry(geometry) {
  BufferGeometry.call(this);
  this.type = 'WireframeGeometry'; // buffer

  var vertices = []; // helper variables

  var i, j, l, o, ol;
  var edge = [0, 0],
      edges = {},
      e,
      edge1,
      edge2;
  var key,
      keys = ['a', 'b', 'c'];
  var vertex; // different logic for Geometry and BufferGeometry

  if (geometry && geometry.isGeometry) {
    // create a data structure that contains all edges without duplicates
    var faces = geometry.faces;

    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];

      for (j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + ',' + edge[1];

        if (edges[key] === undefined) {
          edges[key] = {
            index1: edge[0],
            index2: edge[1]
          };
        }
      }
    } // generate vertices


    for (key in edges) {
      e = edges[key];
      vertex = geometry.vertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry.vertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry && geometry.isBufferGeometry) {
    var position, indices, groups;
    var group, start, count;
    var index1, index2;
    vertex = new Vector3();

    if (geometry.index !== null) {
      // indexed BufferGeometry
      position = geometry.attributes.position;
      indices = geometry.index;
      groups = geometry.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      } // create a data structure that contains all eges without duplicates


      for (o = 0, ol = groups.length; o < ol; ++o) {
        group = groups[o];
        start = group.start;
        count = group.count;

        for (i = start, l = start + count; i < l; i += 3) {
          for (j = 0; j < 3; j++) {
            edge1 = indices.getX(i + j);
            edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + ',' + edge[1];

            if (edges[key] === undefined) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
      } // generate vertices


      for (key in edges) {
        e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      // non-indexed BufferGeometry
      position = geometry.attributes.position;

      for (i = 0, l = position.count / 3; i < l; i++) {
        for (j = 0; j < 3; j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
          index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
}

WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */
// ParametricGeometry

function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = 'ParametricGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}

ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry

function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = 'ParametricBufferGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  }; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var EPS = 0.00001;
  var normal = new Vector3();
  var p0 = new Vector3(),
      p1 = new Vector3();
  var pu = new Vector3(),
      pv = new Vector3();
  var i, j;

  if (func.length < 3) {
    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
  } // generate vertices, normals and uvs


  var sliceCount = slices + 1;

  for (i = 0; i <= stacks; i++) {
    var v = i / stacks;

    for (j = 0; j <= slices; j++) {
      var u = j / slices; // vertex

      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z); // normal
      // approximate tangent vectors via finite differences

      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }

      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      } // cross product of tangent vectors returns surface normal


      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u, v);
    }
  } // generate indices


  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      var a = i * sliceCount + j;
      var b = i * sliceCount + j + 1;
      var c = (i + 1) * sliceCount + j + 1;
      var d = (i + 1) * sliceCount + j; // faces one and two

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */
// PolyhedronGeometry

function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = 'PolyhedronGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}

PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry

function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = 'PolyhedronBufferGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  radius = radius || 1;
  detail = detail || 0; // default buffer data

  var vertexBuffer = [];
  var uvBuffer = []; // the subdivision creates the vertex buffer data

  subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

  appplyRadius(radius); // finally, create the uv data

  generateUVs(); // build non-indexed geometry

  this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
  this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

  if (detail === 0) {
    this.computeVertexNormals(); // flat normals
  } else {
    this.normalizeNormals(); // smooth normals
  } // helper functions


  function subdivide(detail) {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

    for (var i = 0; i < indices.length; i += 3) {
      // get the vertices of the face
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c); // perform subdivision

      subdivideFace(a, b, c, detail);
    }
  }

  function subdivideFace(a, b, c, detail) {
    var cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision

    var v = [];
    var i, j; // construct all of the vertices for this subdivision

    for (i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = a.clone().lerp(c, i / cols);
      var bj = b.clone().lerp(c, i / cols);
      var rows = cols - i;

      for (j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    } // construct all of the faces


    for (i = 0; i < cols; i++) {
      for (j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);

        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }

  function appplyRadius(radius) {
    var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      vertex.normalize().multiplyScalar(radius);
      vertexBuffer[i + 0] = vertex.x;
      vertexBuffer[i + 1] = vertex.y;
      vertexBuffer[i + 2] = vertex.z;
    }
  }

  function generateUVs() {
    var vertex = new Vector3();

    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      var u = azimuth(vertex) / 2 / Math.PI + 0.5;
      var v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }

    correctUVs();
    correctSeam();
  }

  function correctSeam() {
    // handle case when face straddles the seam, see #3269
    for (var i = 0; i < uvBuffer.length; i += 6) {
      // uv data of a single face
      var x0 = uvBuffer[i + 0];
      var x1 = uvBuffer[i + 2];
      var x2 = uvBuffer[i + 4];
      var max = Math.max(x0, x1, x2);
      var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2) uvBuffer[i + 0] += 1;
        if (x1 < 0.2) uvBuffer[i + 2] += 1;
        if (x2 < 0.2) uvBuffer[i + 4] += 1;
      }
    }
  }

  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }

  function getVertexByIndex(index, vertex) {
    var stride = index * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }

  function correctUVs() {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    var centroid = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();

    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      var azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }

  function correctUV(uv, stride, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }

    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
    }
  } // Angle around the Y axis, counter-clockwise when looking from above.


  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  } // Angle above the XZ plane.


  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}

PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// TetrahedronGeometry

function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'TetrahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry; // TetrahedronBufferGeometry

function TetrahedronBufferGeometry(radius, detail) {
  var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
  var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'TetrahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// OctahedronGeometry

function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'OctahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry; // OctahedronBufferGeometry

function OctahedronBufferGeometry(radius, detail) {
  var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
  var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'OctahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// IcosahedronGeometry

function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'IcosahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry; // IcosahedronBufferGeometry

function IcosahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
  var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'IcosahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// DodecahedronGeometry

function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'DodecahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry; // DodecahedronBufferGeometry

function DodecahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var r = 1 / t;
  var vertices = [// (1, 1, 1)
  -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, 1/, )
  0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (1/, , 0)
  -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (, 0, 1/)
  -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
  var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'DodecahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */
// TubeGeometry

function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = 'TubeGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed); // expose internals

  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals; // create geometry

  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}

TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry; // TubeBufferGeometry

function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = 'TubeBufferGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals; // helper variables

  var vertex = new Vector3();
  var normal = new Vector3();
  var uv = new Vector2();
  var P = new Vector3();
  var i, j; // buffer

  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = []; // create buffer data

  generateBufferData(); // build geometry

  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

  function generateBufferData() {
    for (i = 0; i < tubularSegments; i++) {
      generateSegment(i);
    } // if the geometry is not closed, generate the last row of vertices and normals
    // at the regular position on the given path
    //
    // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


    generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
    // this makes it easy compute correct values for closed geometries

    generateUVs(); // finally create faces

    generateIndices();
  }

  function generateSegment(i) {
    // we use getPointAt to sample evenly distributed points from the given path
    P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

    var N = frames.normals[i];
    var B = frames.binormals[i]; // generate normals and vertices for the current segment

    for (j = 0; j <= radialSegments; j++) {
      var v = j / radialSegments * Math.PI * 2;
      var sin = Math.sin(v);
      var cos = -Math.cos(v); // normal

      normal.x = cos * N.x + sin * B.x;
      normal.y = cos * N.y + sin * B.y;
      normal.z = cos * N.z + sin * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z); // vertex

      vertex.x = P.x + radius * normal.x;
      vertex.y = P.y + radius * normal.y;
      vertex.z = P.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }

  function generateIndices() {
    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }

  function generateUVs() {
    for (i = 0; i <= tubularSegments; i++) {
      for (j = 0; j <= radialSegments; j++) {
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}

TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  data.path = this.parameters.path.toJSON();
  return data;
};
/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */
// TorusKnotGeometry


function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = 'TorusKnotGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}

TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry; // TorusKnotBufferGeometry

function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = 'TorusKnotBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var i, j;
  var vertex = new Vector3();
  var normal = new Vector3();
  var P1 = new Vector3();
  var P2 = new Vector3();
  var B = new Vector3();
  var T = new Vector3();
  var N = new Vector3(); // generate vertices, normals and uvs

  for (i = 0; i <= tubularSegments; ++i) {
    // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
    var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

    B.normalize();
    N.normalize();

    for (j = 0; j <= radialSegments; ++j) {
      // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
      // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
      var v = j / radialSegments * Math.PI * 2;
      var cx = -tube * Math.cos(v);
      var cy = tube * Math.sin(v); // now calculate the final vertex position.
      // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

      vertex.x = P1.x + (cx * N.x + cy * B.x);
      vertex.y = P1.y + (cx * N.y + cy * B.y);
      vertex.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (j = 1; j <= tubularSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
      // indices
      var a = (radialSegments + 1) * (j - 1) + (i - 1);
      var b = (radialSegments + 1) * j + (i - 1);
      var c = (radialSegments + 1) * j + i;
      var d = (radialSegments + 1) * (j - 1) + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

  function calculatePositionOnCurve(u, p, q, radius, position) {
    var cu = Math.cos(u);
    var su = Math.sin(u);
    var quOverP = q / p * u;
    var cs = Math.cos(quOverP);
    position.x = radius * (2 + cs) * 0.5 * cu;
    position.y = radius * (2 + cs) * su * 0.5;
    position.z = radius * Math.sin(quOverP) * 0.5;
  }
}

TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// TorusGeometry

function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = 'TorusGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}

TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry; // TorusBufferGeometry

function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = 'TorusBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var center = new Vector3();
  var vertex = new Vector3();
  var normal = new Vector3();
  var j, i; // generate vertices, normals and uvs

  for (j = 0; j <= radialSegments; j++) {
    for (i = 0; i <= tubularSegments; i++) {
      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2; // vertex

      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex.z = tube * Math.sin(v);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      center.x = radius * Math.cos(u);
      center.y = radius * Math.sin(u);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (j = 1; j <= radialSegments; j++) {
    for (i = 1; i <= tubularSegments; i++) {
      // indices
      var a = (tubularSegments + 1) * j + i - 1;
      var b = (tubularSegments + 1) * (j - 1) + i - 1;
      var c = (tubularSegments + 1) * (j - 1) + i;
      var d = (tubularSegments + 1) * j + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.2)
 */

var Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];
    if (!outerNode) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  var i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertice leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  var p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
      return false;
    }

    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize); // first look for points inside the triangle in increasing z-order

  var p = ear.nextZ;

  while (p && p.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.nextZ;
  } // then look for points in decreasing z-order


  p = ear.prevZ;

  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  var p = start;

  do {
    var a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return p;
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;

  do {
    var b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [],
      i,
      len,
      start,
      end,
      list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    var b = splitPolygon(outerNode, hole);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
  p = m.next;

  while (p !== stop) {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  }

  return m;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  var p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  var p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  var p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
      return true;
    }

    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
      inside = !inside;
    }

    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertice index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertice nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  var sum = 0;

  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */


var ShapeUtils = {
  // calculate area of the contour polygon
  area: function (contour) {
    var n = contour.length;
    var a = 0.0;

    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  },
  isClockWise: function (pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function (contour, holes) {
    var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    var holeIndices = []; // array of hole indices

    var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    var holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (var i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    var triangles = Earcut.triangulate(vertices, holeIndices); //

    for (var i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }
};
exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  var l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (var i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
// ExtrudeGeometry


function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = 'ExtrudeGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}

ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
}; // ExtrudeBufferGeometry


function ExtrudeBufferGeometry(shapes, options) {
  BufferGeometry.call(this);
  this.type = 'ExtrudeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  var scope = this;
  var verticesArray = [];
  var uvArray = [];

  for (var i = 0, l = shapes.length; i < l; i++) {
    var shape = shapes[i];
    addShape(shape);
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals(); // functions

  function addShape(shape) {
    var placeholder = []; // options

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var steps = options.steps !== undefined ? options.steps : 1;
    var depth = options.depth !== undefined ? options.depth : 100;
    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    var extrudePath = options.extrudePath;
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

    if (options.amount !== undefined) {
      console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
      depth = options.amount;
    } //


    var extrudePts,
        extrudeByPath = false;
    var splineTube, binormal, normal, position2;

    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false; // bevels not supported for path extrusion
      // SETUP TNB variables
      // TODO1 - have a .isClosed in spline?

      splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    } // Safeguards if bevels are not enabled


    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
    } // Variables initialization


    var ahole, h, hl; // looping of holes

    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !ShapeUtils.isClockWise(vertices);

    if (reverse) {
      vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];

        if (ShapeUtils.isClockWise(ahole)) {
          holes[h] = ahole.reverse();
        }
      }
    }

    var faces = ShapeUtils.triangulateShape(vertices, holes);
    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      vertices = vertices.concat(ahole);
    }

    function scalePt2(pt, vec, size) {
      if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }

    var b,
        bs,
        t,
        z,
        vert,
        vlen = vertices.length,
        face,
        flen = faces.length; // Find directions for point movement

    function getBevelVec(inPt, inPrev, inNext) {
      // computes for inPt the corresponding point inPt' on a new contour
      //   shifted by 1 unit (length of normalized vector) to the left
      // if we walk along contour clockwise, this new contour is outside the old one
      //
      // inPt' is the intersection of the two lines parallel to the two
      //  adjacent edges of inPt at a distance of 1 unit on the left side.
      var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
      // good reading for geometry algorithms (here: line-line intersection)
      // http://geomalgorithms.com/a05-_intersect-1.html

      var v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

      if (Math.abs(collinear0) > Number.EPSILON) {
        // not collinear
        // length of vectors for normalizing
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
        var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
        //  but prevent crazy spikes

        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        // handle special case of collinear edges
        var direction_eq = false; // assumes: opposite

        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }

        if (direction_eq) {
          // console.log("Warning: lines are a straight sequence");
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          // console.log("Warning: lines are a straight spike");
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }

      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }

    var contourMovements = [];

    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il) j = 0;
      if (k === il) k = 0; //  (j)---(i)---(k)
      // console.log('i,j,k', i, j , k)

      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }

    var holesMovements = [],
        oneHoleMovements,
        verticesMovements = contourMovements.concat();

    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = [];

      for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)

        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
      }

      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    } // Loop bevelSegments, 1 for the front, 1 for the back


    for (b = 0; b < bevelSegments; b++) {
      //for ( b = bevelSegments; b > 0; b -- ) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2); // contract shape

      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, -z);
      } // expand holes


      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
      }
    }

    bs = bevelSize; // Back facing vertices

    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    } // Add stepped vertices...
    // Including front facing vertices


    var s;

    for (s = 1; s <= steps; s++) {
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, depth / steps * s);
        } else {
          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    } // Add bevel segments planes
    //for ( b = 1; b <= bevelSegments; b ++ ) {


    for (b = bevelSegments - 1; b >= 0; b--) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2); // contract shape

      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, depth + z);
      } // expand holes


      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
          }
        }
      }
    }
    /* Faces */
    // Top and bottom faces


    buildLidFaces(); // Sides faces

    buildSideFaces(); /////  Internal functions

    function buildLidFaces() {
      var start = verticesArray.length / 3;

      if (bevelEnabled) {
        var layer = 0; // steps + 1

        var offset = vlen * layer; // Bottom faces

        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }

        layer = steps + bevelSegments * 2;
        offset = vlen * layer; // Top faces

        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        // Bottom faces
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2], face[1], face[0]);
        } // Top faces


        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 0);
    } // Create faces for the z-sides of the shape


    function buildSideFaces() {
      var start = verticesArray.length / 3;
      var layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        sidewalls(ahole, layeroffset); //, true

        layeroffset += ahole.length;
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 1);
    }

    function sidewalls(contour, layeroffset) {
      var j, k;
      i = contour.length;

      while (--i >= 0) {
        j = i;
        k = i - 1;
        if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

        var s = 0,
            sl = steps + bevelSegments * 2;

        for (s = 0; s < sl; s++) {
          var slen1 = vlen * s;
          var slen2 = vlen * (s + 1);
          var a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2;
          f4(a, b, c, d);
        }
      }
    }

    function v(x, y, z) {
      placeholder.push(x);
      placeholder.push(y);
      placeholder.push(z);
    }

    function f3(a, b, c) {
      addVertex(a);
      addVertex(b);
      addVertex(c);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }

    function f4(a, b, c, d) {
      addVertex(a);
      addVertex(b);
      addVertex(d);
      addVertex(b);
      addVertex(c);
      addVertex(d);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }

    function addVertex(index) {
      verticesArray.push(placeholder[index * 3 + 0]);
      verticesArray.push(placeholder[index * 3 + 1]);
      verticesArray.push(placeholder[index * 3 + 2]);
    }

    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}

ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
}; //


var WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < 0.01) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  //
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  } //


  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */
// TextGeometry


function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = 'TextGeometry';
  this.parameters = {
    text: text,
    parameters: parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}

TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry

function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  var font = parameters.font;

  if (!(font && font.isFont)) {
    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
    return new Geometry();
  }

  var shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

  parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

  if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
  if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
  if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = 'TextBufferGeometry';
}

TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */
// SphereGeometry

function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'SphereGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}

SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry

function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'SphereBufferGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  var thetaEnd = thetaStart + thetaLength;
  var ix, iy;
  var index = 0;
  var grid = [];
  var vertex = new Vector3();
  var normal = new Vector3(); // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // generate vertices, normals and uvs

  for (iy = 0; iy <= heightSegments; iy++) {
    var verticesRow = [];
    var v = iy / heightSegments;

    for (ix = 0; ix <= widthSegments; ix++) {
      var u = ix / widthSegments; // vertex

      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normal.set(vertex.x, vertex.y, vertex.z).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u, 1 - v);
      verticesRow.push(index++);
    }

    grid.push(verticesRow);
  } // indices


  for (iy = 0; iy < heightSegments; iy++) {
    for (ix = 0; ix < widthSegments; ix++) {
      var a = grid[iy][ix + 1];
      var b = grid[iy][ix];
      var c = grid[iy + 1][ix];
      var d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */
// RingGeometry

function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'RingGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}

RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry; // RingBufferGeometry

function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'RingBufferGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // some helper variables

  var segment;
  var radius = innerRadius;
  var radiusStep = (outerRadius - innerRadius) / phiSegments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var j, i; // generate vertices, normals and uvs

  for (j = 0; j <= phiSegments; j++) {
    for (i = 0; i <= thetaSegments; i++) {
      // values are generate from the inside of the ring to the outside
      segment = thetaStart + i / thetaSegments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uv

      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // increase the radius for next row of vertices


    radius += radiusStep;
  } // indices


  for (j = 0; j < phiSegments; j++) {
    var thetaSegmentLevel = j * (thetaSegments + 1);

    for (i = 0; i < thetaSegments; i++) {
      segment = i + thetaSegmentLevel;
      var a = segment;
      var b = segment + thetaSegments + 1;
      var c = segment + thetaSegments + 2;
      var d = segment + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */
// LatheGeometry

function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = 'LatheGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}

LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry; // LatheBufferGeometry

function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = 'LatheBufferGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]

  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2); // buffers

  var indices = [];
  var vertices = [];
  var uvs = []; // helper variables

  var base;
  var inverseSegments = 1.0 / segments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var i, j; // generate vertices and uvs

  for (i = 0; i <= segments; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var sin = Math.sin(phi);
    var cos = Math.cos(phi);

    for (j = 0; j <= points.length - 1; j++) {
      // vertex
      vertex.x = points[j].x * sin;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos;
      vertices.push(vertex.x, vertex.y, vertex.z); // uv

      uv.x = i / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  } // indices


  for (i = 0; i < segments; i++) {
    for (j = 0; j < points.length - 1; j++) {
      base = j + i * points.length;
      var a = base;
      var b = base + points.length;
      var c = base + points.length + 1;
      var d = base + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

  this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
  // because the corresponding vertices are identical (but still have different UVs).

  if (phiLength === Math.PI * 2) {
    var normals = this.attributes.normal.array;
    var n1 = new Vector3();
    var n2 = new Vector3();
    var n = new Vector3(); // this is the buffer offset for the last line of vertices

    base = segments * points.length * 3;

    for (i = 0, j = 0; i < points.length; i++, j += 3) {
      // select the normal of the vertex in the first line
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2]; // select the normal of the vertex in the last line

      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2]; // average normals

      n.addVectors(n1, n2).normalize(); // assign the new values to both normals

      normals[j + 0] = normals[base + j + 0] = n.x;
      normals[j + 1] = normals[base + j + 1] = n.y;
      normals[j + 2] = normals[base + j + 2] = n.z;
    }
  }
}

LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// ShapeGeometry

function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = 'ShapeGeometry';

  if (typeof curveSegments === 'object') {
    console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
    curveSegments = curveSegments.curveSegments;
  }

  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}

ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;

ShapeGeometry.prototype.toJSON = function () {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; // ShapeBufferGeometry


function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = 'ShapeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  curveSegments = curveSegments || 12; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var groupStart = 0;
  var groupCount = 0; // allow single and array values for "shapes" parameter

  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (var i = 0; i < shapes.length; i++) {
      addShape(shapes[i]);
      this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

      groupStart += groupCount;
      groupCount = 0;
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

  function addShape(shape) {
    var i, l, shapeHole;
    var indexOffset = vertices.length / 3;
    var points = shape.extractPoints(curveSegments);
    var shapeVertices = points.shape;
    var shapeHoles = points.holes; // check direction of vertices

    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }

    for (i = 0, l = shapeHoles.length; i < l; i++) {
      shapeHole = shapeHoles[i];

      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i] = shapeHole.reverse();
      }
    }

    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

    for (i = 0, l = shapeHoles.length; i < l; i++) {
      shapeHole = shapeHoles[i];
      shapeVertices = shapeVertices.concat(shapeHole);
    } // vertices, normals, uvs


    for (i = 0, l = shapeVertices.length; i < l; i++) {
      var vertex = shapeVertices[i];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y); // world uvs
    } // incides


    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      var a = face[0] + indexOffset;
      var b = face[1] + indexOffset;
      var c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}

ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; //


function toJSON$1(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */


function EdgesGeometry(geometry, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = 'EdgesGeometry';
  this.parameters = {
    thresholdAngle: thresholdAngle
  };
  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1; // buffer

  var vertices = []; // helper variables

  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
  var edge = [0, 0],
      edges = {},
      edge1,
      edge2;
  var key,
      keys = ['a', 'b', 'c']; // prepare source geometry

  var geometry2;

  if (geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
  } else {
    geometry2 = geometry.clone();
  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();
  var sourceVertices = geometry2.vertices;
  var faces = geometry2.faces; // now create a data structure where each entry represents an edge with its adjoining faces

  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];

    for (var j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + ',' + edge[1];

      if (edges[key] === undefined) {
        edges[key] = {
          index1: edge[0],
          index2: edge[1],
          face1: i,
          face2: undefined
        };
      } else {
        edges[key].face2 = i;
      }
    }
  } // generate vertices


  for (key in edges) {
    var e = edges[key]; // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
      var vertex = sourceVertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
}

EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// CylinderGeometry

function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CylinderGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}

CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry; // CylinderBufferGeometry

function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CylinderBufferGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== undefined ? radiusTop : 1;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var index = 0;
  var indexArray = [];
  var halfHeight = height / 2;
  var groupStart = 0; // generate geometry

  generateTorso();

  if (openEnded === false) {
    if (radiusTop > 0) generateCap(true);
    if (radiusBottom > 0) generateCap(false);
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

  function generateTorso() {
    var x, y;
    var normal = new Vector3();
    var vertex = new Vector3();
    var groupCount = 0; // this will be used to calculate the normal

    var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments; // calculate the radius of the current row

      var radius = v * (radiusBottom - radiusTop) + radiusTop;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, 1 - v); // save index of vertex in respective row

        indexRow.push(index++);
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        // we use the index array to access the correct indices
        var a = indexArray[y][x];
        var b = indexArray[y + 1][x];
        var c = indexArray[y + 1][x + 1];
        var d = indexArray[y][x + 1]; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // update group counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

    groupStart += groupCount;
  }

  function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (x = 1; x <= radialSegments; x++) {
      // vertex
      vertices.push(0, halfHeight * sign, 0); // normal

      normals.push(0, sign, 0); // uv

      uvs.push(0.5, 0.5); // increase index

      index++;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta); // vertex

      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, sign, 0); // uv

      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y); // increase index

      index++;
    } // generate indices


    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;

      if (top === true) {
        // face top
        indices.push(i, i + 1, c);
      } else {
        // face bottom
        indices.push(i + 1, i, c);
      }

      groupCount += 3;
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

    groupStart += groupCount;
  }
}

CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
/**
 * @author abelnation / http://github.com/abelnation
 */
// ConeGeometry

function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry; // ConeBufferGeometry

function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeBufferGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */
// CircleGeometry

function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CircleGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}

CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry; // CircleBufferGeometry

function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CircleBufferGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  segments = segments !== undefined ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var i, s;
  var vertex = new Vector3();
  var uv = new Vector2(); // center point

  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);

  for (s = 0, i = 3; s <= segments; s++, i += 3) {
    var segment = thetaStart + s / segments * thetaLength; // vertex

    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z); // normal

    normals.push(0, 0, 1); // uvs

    uv.x = (vertices[i] / radius + 1) / 2;
    uv.y = (vertices[i + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  } // indices


  for (i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries =
/*#__PURE__*/
Object.freeze({
  WireframeGeometry: WireframeGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricBufferGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronBufferGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeBufferGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusBufferGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextBufferGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereBufferGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingBufferGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneBufferGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheBufferGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeBufferGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  EdgesGeometry: EdgesGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeBufferGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderBufferGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleBufferGeometry,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxBufferGeometry
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = 'ShadowMaterial';
  this.color = new Color(0x000000);
  this.transparent = true;
  this.setValues(parameters);
}

ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
}

RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'STANDARD': ''
  };
  this.type = 'MeshStandardMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1.0;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': ''
  };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 *  clearCoat: <float>
 *  clearCoatRoughness: <float>
 * }
 */


function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    'PHYSICAL': ''
  };
  this.type = 'MeshPhysicalMaterial';
  this.reflectivity = 0.5; // maps to F0 = 0.04

  this.clearCoat = 0.0;
  this.clearCoatRoughness = 0.0;
  this.setValues(parameters);
}

MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function (source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    'PHYSICAL': ''
  };
  this.reflectivity = source.reflectivity;
  this.clearCoat = source.clearCoat;
  this.clearCoatRoughness = source.clearCoatRoughness;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.specular = new Color(0x111111);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */


function MeshToonMaterial(parameters) {
  MeshPhongMaterial.call(this);
  this.defines = {
    'TOON': ''
  };
  this.type = 'MeshToonMaterial';
  this.gradientMap = null;
  this.setValues(parameters);
}

MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function (source) {
  MeshPhongMaterial.prototype.copy.call(this, source);
  this.gradientMap = source.gradientMap;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshNormalMaterial';
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'MATCAP': ''
  };
  this.type = 'MeshMatcapMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'MATCAP': ''
  };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */


function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}

LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function (source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};

var Materials =
/*#__PURE__*/
Object.freeze({
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    var n = times.length;
    var result = new Array(n);

    for (var i = 0; i !== n; ++i) result[i] = i;

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);

    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      var srcOffset = order[i] * stride;

      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    var i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    var value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

exports.AnimationUtils = AnimationUtils;

function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}

Object.assign(Interpolant.prototype, {
  evaluate: function (t) {
    var pp = this.parameterPositions,
        i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];

    validate_interval: {
      seek: {
        var right;

        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (var giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan; // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }

              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];

              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the right side of the index


            right = pp.length;
            break linear_scan;
          } //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {


          if (!(t >= t0)) {
            // looping?
            var t1global = pp[1];

            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details

              t0 = t1global;
            } // linear reverse scan


            for (var giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }

              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];

              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the left side of the index


            right = i1;
            i1 = 0;
            break linear_scan;
          } // the interval is valid


          break validate_interval;
        } // linear scan
        // binary search


        while (i1 < right) {
          var mid = i1 + right >>> 1;

          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }

        t1 = pp[i1];
        t0 = pp[i1 - 1]; // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }

        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek


      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval


    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (index) {
    // copies a sample value to the result buffer
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = index * stride;

    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }

    return result;
  },
  // Template methods for derived classes:
  interpolate_: function ()
  /* i1, t0, t, t1 */
  {
    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
  },
  intervalChanged_: function ()
  /* i1, t0, t1 */
  {// empty
  }
}); //!\ DECLARE ALIAS AFTER assign prototype !

Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}

CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function (i1, t0, t1) {
    var pp = this.parameterPositions,
        iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];

    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }

    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }

    var halfDt = (t1 - t0) * 0.5,
        stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        o1 = i1 * stride,
        o0 = o1 - stride,
        oP = this._offsetPrev,
        oN = this._offsetNext,
        wP = this._weightPrev,
        wN = this._weightNext,
        p = (t - t0) / (t1 - t0),
        pp = p * p,
        ppp = pp * p; // evaluate polynomials

    var sP = -wP * ppp + 2 * wP * pp - wP * p;
    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    var sN = wN * ppp - wN * pp; // combine data linearly

    for (var i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }

    return result;
  }
});
/**
 * @author tschw
 */

function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset1 = i1 * stride,
        offset0 = offset1 - stride,
        weight1 = (t - t0) / (t1 - t0),
        weight0 = 1 - weight1;

    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }

    return result;
  }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function (i1
  /*, t0, t, t1 */
  ) {
    return this.copySampleValue_(i1 - 1);
  }
});
/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack(name, times, values, interpolation) {
  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
} // Static methods


Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function (track) {
    var trackType = track.constructor;
    var json; // derived classes can define a static toJSON method

    if (trackType.toJSON !== undefined) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      var interpolation = track.getInterpolation();

      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }

    json.type = track.ValueTypeName; // mandatory

    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function (result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function (result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function (result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function (interpolation) {
    var factoryMethod;

    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;

      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;

      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }

    if (factoryMethod === undefined) {
      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }

    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function (timeOffset) {
    if (timeOffset !== 0.0) {
      var times = this.times;

      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }

    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function (timeScale) {
    if (timeScale !== 1.0) {
      var times = this.times;

      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }

    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function (startTime, endTime) {
    var times = this.times,
        nKeys = times.length,
        from = 0,
        to = nKeys - 1;

    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }

    while (to !== -1 && times[to] > endTime) {
      --to;
    }

    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) to = Math.max(to, 1), from = to - 1;
      var stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }

    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function () {
    var valid = true;
    var valueSize = this.getValueSize();

    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }

    var times = this.times,
        values = this.values,
        nKeys = times.length;

    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }

    var prevTime = null;

    for (var i = 0; i !== nKeys; i++) {
      var currTime = times[i];

      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }

      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }

      prevTime = currTime;
    }

    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (var i = 0, n = values.length; i !== n; ++i) {
          var value = values[i];

          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }

    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function () {
    var times = this.times,
        values = this.values,
        stride = this.getValueSize(),
        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
        writeIndex = 1,
        lastIndex = times.length - 1;

    for (var i = 1; i < lastIndex; ++i) {
      var keep = false;
      var time = times[i];
      var timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors
          var offset = i * stride,
              offsetP = offset - stride,
              offsetN = offset + stride;

          for (var j = 0; j !== stride; ++j) {
            var value = values[offset + j];

            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      } // in-place compaction


      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          var readOffset = i * stride,
              writeOffset = writeIndex * stride;

          for (var j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }

        ++writeIndex;
      }
    } // flush last keyframe (compaction looks ahead)


    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];

      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }

      ++writeIndex;
    }

    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    }

    return this;
  },
  clone: function () {
    var times = AnimationUtils.arraySlice(this.times, 0);
    var values = AnimationUtils.arraySlice(this.values, 0);
    var TypedKeyframeTrack = this.constructor;
    var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

    track.createInterpolant = this.createInterpolant;
    return track;
  }
});
/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}

BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: 'bool',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".

});
/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: 'color' // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.

});
/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: 'number' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = i1 * stride,
        alpha = (t - t0) / (t1 - t0);

    for (var end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }

    return result;
  }
});
/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: 'quaternion',
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function (result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: undefined // not yet implemented

});
/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: 'string',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: 'vector' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip(name, duration, tracks) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== undefined ? duration : -1;
  this.uuid = _Math.generateUUID(); // this means it should figure out its duration by scanning the tracks

  if (this.duration < 0) {
    this.resetDuration();
  }
}

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  var trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    var times = [],
        values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

Object.assign(AnimationClip, {
  parse: function (json) {
    var tracks = [],
        jsonTracks = json.tracks,
        frameTime = 1.0 / (json.fps || 1.0);

    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }

    return new AnimationClip(json.name, json.duration, tracks);
  },
  toJSON: function (clip) {
    var tracks = [],
        clipTracks = clip.tracks;
    var json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid
    };

    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }

    return json;
  },
  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];

    for (var i = 0; i < numMorphTargets; i++) {
      var times = [];
      var values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      var order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.

      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }

      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }

    return new AnimationClip(name, -1, tracks);
  },
  findByName: function (objectOrClipArray, name) {
    var clipArray = objectOrClipArray;

    if (!Array.isArray(objectOrClipArray)) {
      var o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }

    for (var i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }

    return null;
  },
  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
    var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

    var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002

    for (var i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = morphTargets[i];
      var parts = morphTarget.name.match(pattern);

      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];

        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }

        animationMorphTargets.push(morphTarget);
      }
    }

    var clips = [];

    for (var name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }

    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function (animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }

    var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        var times = [];
        var values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };

    var tracks = [];
    var clipName = animation.name || 'default'; // automatic length determination in AnimationClip.

    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];

    for (var h = 0; h < hierarchyTracks.length; h++) {
      var animationKeys = hierarchyTracks[h].keys; // skip empty tracks

      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        var morphTargetNames = {};

        for (var k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        } // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.


        for (var morphTargetName in morphTargetNames) {
          var times = [];
          var values = [];

          for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            var animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }

          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }

        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation
        var boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }

    if (tracks.length === 0) {
      return null;
    }

    var clip = new AnimationClip(clipName, duration, tracks);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function () {
    var tracks = this.tracks,
        duration = 0;

    for (var i = 0, n = tracks.length; i !== n; ++i) {
      var track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }

    this.duration = duration;
    return this;
  },
  trim: function () {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }

    return this;
  },
  validate: function () {
    var valid = true;

    for (var i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }

    return valid;
  },
  optimize: function () {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }

    return this;
  },
  clone: function () {
    var tracks = [];

    for (var i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }

    return new AnimationClip(this.name, this.duration, tracks);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.Cache = Cache;

function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
}

var DefaultLoadingManager = new LoadingManager();
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.DefaultLoadingManager = DefaultLoadingManager;
var loading = {};

function FileLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(FileLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    } // Check if request is duplicate


    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    } // Check for data: URI


    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex); // Safari can not handle Data URIs through XMLHttpRequest so process manually

    if (dataUriRegexResult) {
      var mimeType = dataUriRegexResult[1];
      var isBase64 = !!dataUriRegexResult[2];
      var data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);

      try {
        var response;
        var responseType = (this.responseType || '').toLowerCase();

        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            var view = new Uint8Array(data.length);

            for (var i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }

            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }

            break;

          case 'document':
            var parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;

          case 'json':
            response = JSON.parse(data);
            break;

          default:
            // 'text' or other
            response = data;
            break;
        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does


        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        var response = this.response;
        Cache.add(url, response);
        var callbacks = loading[url];
        delete loading[url];

        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }

          scope.manager.itemEnd(url);
        } else {
          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        var callbacks = loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        var callbacks = loading[url];
        delete loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        var callbacks = loading[url];
        delete loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

      for (var header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }

      request.send(null);
    }

    scope.manager.itemStart(url);
    return request;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  },
  setResponseType: function (value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function (value) {
    this.mimeType = value;
    return this;
  },
  setRequestHeader: function (value) {
    this.requestHeader = value;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(AnimationLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json, onLoad) {
    var animations = [];

    for (var i = 0; i < json.length; i++) {
      var clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }

    onLoad(animations);
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager; // override in sub classes

  this._parser = null;
}

Object.assign(CompressedTextureLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var images = [];
    var texture = new CompressedTexture();
    texture.image = images;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');

    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        var texDatas = scope._parser(buffer, true);

        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;

        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }

    if (Array.isArray(url)) {
      var loaded = 0;

      for (var i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file
      loader.load(url, function (buffer) {
        var texDatas = scope._parser(buffer, true);

        if (texDatas.isCubemap) {
          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for (var f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };

            for (var i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }

        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }

    return texture;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

function DataTextureLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager; // override in sub classes

  this._parser = null;
}

Object.assign(DataTextureLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var texture = new DataTexture();
    var loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      var texData = scope._parser(buffer);

      if (!texData) return;

      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }

      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

      if (texData.format !== undefined) {
        texture.format = texData.format;
      }

      if (texData.type !== undefined) {
        texture.type = texData.type;
      }

      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }

      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(ImageLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(CubeTextureLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (urls, onLoad, onProgress, onError) {
    var texture = new CubeTexture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var loaded = 0;

    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;

        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }

    for (var i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }

    return texture;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(TextureLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (url, onLoad, onProgress, onError) {
    var texture = new Texture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {
  this.type = 'Curve';
  this.arcLengthDivisions = 200;
}

Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function ()
  /* t, optionalTarget */
  {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function (u, optionalTarget) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  },
  // Get total curve arc length
  getLength: function () {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function (divisions) {
    if (divisions === undefined) divisions = this.arcLengthDivisions;

    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    var cache = [];
    var current,
        last = this.getPoint(0);
    var p,
        sum = 0;
    cache.push(0);

    for (p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  },
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function (u, distance) {
    var arcLengths = this.getLengths();
    var i = 0,
        il = arcLengths.length;
    var targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    var low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    var t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function (t) {
    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
  },
  getTangentAt: function (u) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t);
  },
  computeFrenetFrames: function (segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    var normal = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4();
    var i, u, theta; // compute the tangent vectors for each segment on the curve

    for (i = 0; i <= segments; i++) {
      u = i / segments;
      tangents[i] = this.getTangentAt(u);
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function (json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});

function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = 'EllipseCurve';
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}

EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var twoPi = Math.PI * 2;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

  while (deltaAngle < 0) deltaAngle += twoPi;

  while (deltaAngle > twoPi) deltaAngle -= twoPi;

  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }

  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }

  var angle = this.aStartAngle + t * deltaAngle;
  var x = this.aX + this.xRadius * Math.cos(angle);
  var y = this.aY + this.yRadius * Math.sin(angle);

  if (this.aRotation !== 0) {
    var cos = Math.cos(this.aRotation);
    var sin = Math.sin(this.aRotation);
    var tx = x - this.aX;
    var ty = y - this.aY; // Rotate the point about the center of the ellipse.

    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }

  return point.set(x, y);
};

EllipseCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};

EllipseCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};

EllipseCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};

function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = 'ArcCurve';
}

ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  var c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


var tmp = new Vector3();
var px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = 'CatmullRomCurve3';
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || 'centripetal';
  this.tension = tension || 0.5;
}

CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var points = this.points;
  var l = points.length;
  var p = (l - (this.closed ? 0 : 1)) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;

  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }

  var p0, p1, p2, p3; // 4 points

  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    // extrapolate first point
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }

  p1 = points[intPoint % l];
  p2 = points[(intPoint + 1) % l];

  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    // extrapolate last point
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }

  if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
    // init Centripetal / Chordal Catmull-Rom
    var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

    if (dt1 < 1e-4) dt1 = 1.0;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === 'catmullrom') {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }

  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};

CatmullRomCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }

  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};

CatmullRomCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }

  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};

CatmullRomCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (var i = 0, l = json.points.length; i < l; i++) {
    var point = json.points[i];
    this.points.push(new Vector3().fromArray(point));
  }

  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */


function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}

CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
  return point;
};

CubicBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}

CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
  return point;
};

CubicBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve';
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve.prototype.getTangent = function ()
/* t */
{
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};

LineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve3';
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
  return point;
};

QuadraticBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
  return point;
};

QuadraticBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function SplineCurve(points
/* array of Vector2 */
) {
  Curve.call(this);
  this.type = 'SplineCurve';
  this.points = points || [];
}

SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var points = this.points;
  var p = (points.length - 1) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;
  var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  var p1 = points[intPoint];
  var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
  return point;
};

SplineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }

  return this;
};

SplineCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }

  return data;
};

SplineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (var i = 0, l = json.points.length; i < l; i++) {
    var point = json.points[i];
    this.points.push(new Vector2().fromArray(point));
  }

  return this;
};

var Curves =
/*#__PURE__*/
Object.freeze({
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {
  Curve.call(this);
  this.type = 'CurvePath';
  this.curves = [];
  this.autoClose = false; // Automatically closes the path
}

CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function (curve) {
    this.curves.push(curve);
  },
  closePath: function () {
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function (t) {
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        var diff = curveLengths[i] - d;
        var curve = this.curves[i];
        var segmentLength = curve.getLength();
        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function () {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function () {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    var lengths = [],
        sums = 0;

    for (var i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 40;
    var points = [];

    for (var i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  },
  getPoints: function (divisions) {
    divisions = divisions || 12;
    var points = [],
        last;

    for (var i = 0, curves = this.curves; i < curves.length; i++) {
      var curve = curves[i];
      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      var pts = curve.getPoints(resolution);

      for (var j = 0; j < pts.length; j++) {
        var point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  },
  copy: function (source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];

    for (var i = 0, l = source.curves.length; i < l; i++) {
      var curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function () {
    var data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];

    for (var i = 0, l = this.curves.length; i < l; i++) {
      var curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (var i = 0, l = json.curves.length; i < l; i++) {
      var curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path(points) {
  CurvePath.call(this);
  this.type = 'Path';
  this.currentPoint = new Vector2();

  if (points) {
    this.setFromPoints(points);
  }
}

Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function (points) {
    this.moveTo(points[0].x, points[0].y);

    for (var i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
  },
  moveTo: function (x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
  },
  lineTo: function (x, y) {
    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  splineThru: function (pts
  /*Array of Vector*/
  ) {
    var npts = [this.currentPoint.clone()].concat(pts);
    var curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
  },
  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  },
  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      var firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
  },
  copy: function (source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function () {
    var data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function (json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/
// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape(points) {
  Path.call(this, points);
  this.uuid = _Math.generateUUID();
  this.type = 'Shape';
  this.holes = [];
}

Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function (divisions) {
    var holesPts = [];

    for (var i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function (divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function (source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];

    for (var i = 0, l = source.holes.length; i < l; i++) {
      var hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  },
  toJSON: function () {
    var data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];

    for (var i = 0, l = this.holes.length; i < l; i++) {
      var hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];

    for (var i = 0, l = json.holes.length; i < l; i++) {
      var hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light(color, intensity) {
  Object3D.call(this);
  this.type = 'Light';
  this.color = new Color(color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
}

Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = 'HemisphereLight';
  this.castShadow = undefined;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}

HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.matrix = new Matrix4();
}

Object.assign(LightShadow.prototype, {
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    var object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}

SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  update: function (light) {
    var camera = this.camera;
    var fov = _Math.RAD2DEG * 2 * light.angle;
    var aspect = this.mapSize.width / this.mapSize.height;
    var far = light.distance || camera.far;

    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new SpotLightShadow();
}

SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = 'PointLight';
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
}

PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left !== undefined ? left : -1;
  this.right = right !== undefined ? right : 1;
  this.top = top !== undefined ? top : 1;
  this.bottom = bottom !== undefined ? bottom : -1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
}

OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}

DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
}

AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = 'RectAreaLight';
  this.width = width !== undefined ? width : 10;
  this.height = height !== undefined ? height : 10;
}

RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function (meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.textures = {};
}

Object.assign(MaterialLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var textures = this.textures;

    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }

      return textures[name];
    }

    var material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
    if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
    if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== undefined) material.skinning = json.skinning;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.userData !== undefined) material.userData = json.userData; // Shader Material

    if (json.uniforms !== undefined) {
      for (var name in json.uniforms) {
        var uniform = json.uniforms[name];
        material.uniforms[name] = {};

        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;

          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;

          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;

          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;

          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;

          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);

          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;

          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }

    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

    if (json.extensions !== undefined) {
      for (var key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    } // Deprecated


    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

    if (json.map !== undefined) material.map = getTexture(json.map);

    if (json.alphaMap !== undefined) {
      material.alphaMap = getTexture(json.alphaMap);
      material.transparent = true;
    }

    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

    if (json.normalScale !== undefined) {
      var normalScale = json.normalScale;

      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [normalScale, normalScale];
      }

      material.normalScale = new Vector2().fromArray(normalScale);
    }

    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    return material;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  },
  setTextures: function (value) {
    this.textures = value;
    return this;
  }
});
/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var LoaderUtils = {
  decodeText: function (array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    var s = '';

    for (var i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    } // Merges multi-byte utf-8 characters.


    return decodeURIComponent(escape(s));
  },
  extractUrlBase: function (url) {
    var index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.LoaderUtils = LoaderUtils;

function BufferGeometryLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(BufferGeometryLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var geometry = new BufferGeometry();
    var index = json.data.index;

    if (index !== undefined) {
      var typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }

    var attributes = json.data.attributes;

    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      geometry.addAttribute(key, bufferAttribute);
    }

    var morphAttributes = json.data.morphAttributes;

    if (morphAttributes) {
      for (var key in morphAttributes) {
        var attributeArray = morphAttributes[key];
        var array = [];

        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var attribute = attributeArray[i];
          var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
          var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }

        geometry.morphAttributes[key] = array;
      }
    }

    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if (groups !== undefined) {
      for (var i = 0, n = groups.length; i !== n; ++i) {
        var group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }

    var boundingSphere = json.data.boundingSphere;

    if (boundingSphere !== undefined) {
      var center = new Vector3();

      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }

      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }

    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
var TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.resourcePath = '';
}

Object.assign(ObjectLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var path = this.path === undefined ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    var loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      var json = null;

      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }

      var metadata = json.metadata;

      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }

      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  setPath: function (value) {
    this.path = value;
    return this;
  },
  setResourcePath: function (value) {
    this.resourcePath = value;
    return this;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  parse: function (json, onLoad) {
    var shapes = this.parseShape(json.shapes);
    var geometries = this.parseGeometries(json.geometries, shapes);
    var images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    var textures = this.parseTextures(json.textures, images);
    var materials = this.parseMaterials(json.materials, textures);
    var object = this.parseObject(json.object, geometries, materials);

    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }

    if (json.images === undefined || json.images.length === 0) {
      if (onLoad !== undefined) onLoad(object);
    }

    return object;
  },
  parseShape: function (json) {
    var shapes = {};

    if (json !== undefined) {
      for (var i = 0, l = json.length; i < l; i++) {
        var shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }

    return shapes;
  },
  parseGeometries: function (json, shapes) {
    var geometries = {};

    if (json !== undefined) {
      var bufferGeometryLoader = new BufferGeometryLoader();

      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];

        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;

          case 'BoxGeometry':
          case 'BoxBufferGeometry':
          case 'CubeGeometry':
            // backwards compatible
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;

          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;

          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;

          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;

          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;

          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;

          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;

          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;

          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;

          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;

          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            var geometryShapes = [];

            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;

          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            var geometryShapes = [];

            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            var extrudePath = data.options.extrudePath;

            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }

            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;

          case 'BufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;

          case 'Geometry':
            if ('THREE' in window && 'LegacyJSONLoader' in THREE) {
              var geometryLoader = new THREE.LegacyJSONLoader();
              geometry = geometryLoader.parse(data, this.resourcePath).geometry;
            } else {
              console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            }

            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }

        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }

    return geometries;
  },
  parseMaterials: function (json, textures) {
    var cache = {}; // MultiMaterial

    var materials = {};

    if (json !== undefined) {
      var loader = new MaterialLoader();
      loader.setTextures(textures);

      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];

        if (data.type === 'MultiMaterial') {
          // Deprecated
          var array = [];

          for (var j = 0; j < data.materials.length; j++) {
            var material = data.materials[j];

            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }

            array.push(cache[material.uuid]);
          }

          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }

          materials[data.uuid] = cache[data.uuid];
        }
      }
    }

    return materials;
  },
  parseAnimations: function (json) {
    var animations = [];

    for (var i = 0; i < json.length; i++) {
      var data = json[i];
      var clip = AnimationClip.parse(data);
      if (data.uuid !== undefined) clip.uuid = data.uuid;
      animations.push(clip);
    }

    return animations;
  },
  parseImages: function (json, onLoad) {
    var scope = this;
    var images = {};

    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }

    if (json !== undefined && json.length > 0) {
      var manager = new LoadingManager(onLoad);
      var loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);

      for (var i = 0, il = json.length; i < il; i++) {
        var image = json[i];
        var url = image.url;

        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture
          images[image.uuid] = [];

          for (var j = 0, jl = url.length; j < jl; j++) {
            var currentUrl = url[j];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images[image.uuid].push(loadImage(path));
          }
        } else {
          // load single image
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
          images[image.uuid] = loadImage(path);
        }
      }
    }

    return images;
  },
  parseTextures: function (json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }

    var textures = {};

    if (json !== undefined) {
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];

        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }

        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }

        var texture;

        if (Array.isArray(images[data.image])) {
          texture = new CubeTexture(images[data.image]);
        } else {
          texture = new Texture(images[data.image]);
        }

        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;

        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }

        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }

    return textures;
  },
  parseObject: function (data, geometries, materials) {
    var object;

    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }

      return geometries[name];
    }

    function getMaterial(name) {
      if (name === undefined) return undefined;

      if (Array.isArray(name)) {
        var array = [];

        for (var i = 0, l = name.length; i < l; i++) {
          var uuid = name[i];

          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }

          array.push(materials[uuid]);
        }

        return array;
      }

      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }

      return materials[name];
    }

    switch (data.type) {
      case 'Scene':
        object = new Scene();

        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }

        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }

        break;

      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;

      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;

      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;

      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;

      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;

      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;

      case 'SkinnedMesh':
        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

      case 'Mesh':
        var geometry = getGeometry(data.geometry);
        var material = getMaterial(data.material);

        if (geometry.bones && geometry.bones.length > 0) {
          object = new SkinnedMesh(geometry, material);
        } else {
          object = new Mesh(geometry, material);
        }

        if (data.drawMode !== undefined) object.setDrawMode(data.drawMode);
        break;

      case 'LOD':
        object = new LOD();
        break;

      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;

      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;

      case 'Group':
        object = new Group();
        break;

      default:
        object = new Object3D();
    }

    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;

    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }

    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }

    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;

    if (data.children !== undefined) {
      var children = data.children;

      for (var i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials));
      }
    }

    if (data.type === 'LOD') {
      var levels = data.levels;

      for (var l = 0; l < levels.length; l++) {
        var level = levels[l];
        var child = object.getObjectByProperty('uuid', level.object);

        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }

    return object;
  }
});
var TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  SphericalReflectionMapping: SphericalReflectionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipMapNearestFilter: NearestMipMapNearestFilter,
  NearestMipMapLinearFilter: NearestMipMapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipMapNearestFilter: LinearMipMapNearestFilter,
  LinearMipMapLinearFilter: LinearMipMapLinearFilter
};
/**
 * @author thespite / http://clicktorelease.com/
 */

function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
  }

  if (typeof fetch === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
  }

  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.options = undefined;
}

ImageBitmapLoader.prototype = {
  constructor: ImageBitmapLoader,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    fetch(url).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, scope.options);
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  },
  setCrossOrigin: function ()
  /* value */
  {
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {
  this.type = 'ShapePath';
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}

Object.assign(ShapePath.prototype, {
  moveTo: function (x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
  },
  lineTo: function (x, y) {
    this.currentPath.lineTo(x, y);
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
  },
  splineThru: function (pts) {
    this.currentPath.splineThru(pts);
  },
  toShapes: function (isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      var shapes = [];

      for (var i = 0, l = inSubpaths.length; i < l; i++) {
        var tmpPath = inSubpaths[i];
        var tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }

      return shapes;
    }

    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line

      var inside = false;

      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;

        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }

          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?

            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt

          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }

    var isClockWise = ShapeUtils.isClockWise;
    var subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    var solid,
        tmpPath,
        tmpShape,
        shapes = [];

    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }

    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];

    for (var i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;

      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = []; //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        }); //console.log('ccw', i);
      }
    } // only Holes? -> probably all Shapes with wrong orientation


    if (!newShapes[0]) return toShapesNoHoles(subPaths);

    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];

      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }

      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];

        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;

          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });

              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }

          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      } // console.log("ambiguous: ", ambiguous);


      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }

    var tmpHoles;

    for (var i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];

      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    } //console.log("shape", shapes);


    return shapes;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font(data) {
  this.type = 'Font';
  this.data = data;
}

Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function (text, size) {
    if (size === undefined) size = 100;
    var shapes = [];
    var paths = createPaths(text, size, this.data);

    for (var p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }

    return shapes;
  }
});

function createPaths(text, size, data) {
  var chars = Array.from ? Array.from(text) : String(text).split(''); // see #13988

  var scale = size / data.resolution;
  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  var paths = [];
  var offsetX = 0,
      offsetY = 0;

  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];

    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      var ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }

  return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {
  var glyph = data.glyphs[char] || data.glyphs['?'];
  if (!glyph) return;
  var path = new ShapePath();
  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  if (glyph.o) {
    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

    for (var i = 0, l = outline.length; i < l;) {
      var action = outline[i++];

      switch (action) {
        case 'm':
          // moveTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;

        case 'l':
          // lineTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;

        case 'q':
          // quadraticCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;

        case 'b':
          // bezierCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }

  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function FontLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(FontLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      var json;

      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }

      var font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function (json) {
    return new Font(json);
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader() {}

Loader.Handlers = {
  handlers: [],
  add: function (regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function (file) {
    var handlers = this.handlers;

    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];

      if (regex.test(file)) {
        return loader;
      }
    }

    return null;
  }
};
Object.assign(Loader.prototype, {
  crossOrigin: 'anonymous',
  onLoadStart: function () {},
  onLoadProgress: function () {},
  onLoadComplete: function () {},
  initMaterials: function (materials, texturePath, crossOrigin) {
    var array = [];

    for (var i = 0; i < materials.length; ++i) {
      array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
    }

    return array;
  },
  createMaterial: function () {
    var BlendingMode = {
      NoBlending: NoBlending,
      NormalBlending: NormalBlending,
      AdditiveBlending: AdditiveBlending,
      SubtractiveBlending: SubtractiveBlending,
      MultiplyBlending: MultiplyBlending,
      CustomBlending: CustomBlending
    };
    var color = new Color();
    var textureLoader = new TextureLoader();
    var materialLoader = new MaterialLoader();
    return function createMaterial(m, texturePath, crossOrigin) {
      // convert from old material format
      var textures = {};

      function loadTexture(path, repeat, offset, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = Loader.Handlers.get(fullPath);
        var texture;

        if (loader !== null) {
          texture = loader.load(fullPath);
        } else {
          textureLoader.setCrossOrigin(crossOrigin);
          texture = textureLoader.load(fullPath);
        }

        if (repeat !== undefined) {
          texture.repeat.fromArray(repeat);
          if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
          if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
        }

        if (offset !== undefined) {
          texture.offset.fromArray(offset);
        }

        if (wrap !== undefined) {
          if (wrap[0] === 'repeat') texture.wrapS = RepeatWrapping;
          if (wrap[0] === 'mirror') texture.wrapS = MirroredRepeatWrapping;
          if (wrap[1] === 'repeat') texture.wrapT = RepeatWrapping;
          if (wrap[1] === 'mirror') texture.wrapT = MirroredRepeatWrapping;
        }

        if (anisotropy !== undefined) {
          texture.anisotropy = anisotropy;
        }

        var uuid = _Math.generateUUID();

        textures[uuid] = texture;
        return uuid;
      } //


      var json = {
        uuid: _Math.generateUUID(),
        type: 'MeshLambertMaterial'
      };

      for (var name in m) {
        var value = m[name];

        switch (name) {
          case 'DbgColor':
          case 'DbgIndex':
          case 'opticalDensity':
          case 'illumination':
            break;

          case 'DbgName':
            json.name = value;
            break;

          case 'blending':
            json.blending = BlendingMode[value];
            break;

          case 'colorAmbient':
          case 'mapAmbient':
            console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
            break;

          case 'colorDiffuse':
            json.color = color.fromArray(value).getHex();
            break;

          case 'colorSpecular':
            json.specular = color.fromArray(value).getHex();
            break;

          case 'colorEmissive':
            json.emissive = color.fromArray(value).getHex();
            break;

          case 'specularCoef':
            json.shininess = value;
            break;

          case 'shading':
            if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
            if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
            if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
            break;

          case 'mapDiffuse':
            json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
            break;

          case 'mapDiffuseRepeat':
          case 'mapDiffuseOffset':
          case 'mapDiffuseWrap':
          case 'mapDiffuseAnisotropy':
            break;

          case 'mapEmissive':
            json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
            break;

          case 'mapEmissiveRepeat':
          case 'mapEmissiveOffset':
          case 'mapEmissiveWrap':
          case 'mapEmissiveAnisotropy':
            break;

          case 'mapLight':
            json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
            break;

          case 'mapLightRepeat':
          case 'mapLightOffset':
          case 'mapLightWrap':
          case 'mapLightAnisotropy':
            break;

          case 'mapAO':
            json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
            break;

          case 'mapAORepeat':
          case 'mapAOOffset':
          case 'mapAOWrap':
          case 'mapAOAnisotropy':
            break;

          case 'mapBump':
            json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
            break;

          case 'mapBumpScale':
            json.bumpScale = value;
            break;

          case 'mapBumpRepeat':
          case 'mapBumpOffset':
          case 'mapBumpWrap':
          case 'mapBumpAnisotropy':
            break;

          case 'mapNormal':
            json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
            break;

          case 'mapNormalFactor':
            json.normalScale = value;
            break;

          case 'mapNormalRepeat':
          case 'mapNormalOffset':
          case 'mapNormalWrap':
          case 'mapNormalAnisotropy':
            break;

          case 'mapSpecular':
            json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
            break;

          case 'mapSpecularRepeat':
          case 'mapSpecularOffset':
          case 'mapSpecularWrap':
          case 'mapSpecularAnisotropy':
            break;

          case 'mapMetalness':
            json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
            break;

          case 'mapMetalnessRepeat':
          case 'mapMetalnessOffset':
          case 'mapMetalnessWrap':
          case 'mapMetalnessAnisotropy':
            break;

          case 'mapRoughness':
            json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
            break;

          case 'mapRoughnessRepeat':
          case 'mapRoughnessOffset':
          case 'mapRoughnessWrap':
          case 'mapRoughnessAnisotropy':
            break;

          case 'mapAlpha':
            json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
            break;

          case 'mapAlphaRepeat':
          case 'mapAlphaOffset':
          case 'mapAlphaWrap':
          case 'mapAlphaAnisotropy':
            break;

          case 'flipSided':
            json.side = BackSide;
            break;

          case 'doubleSided':
            json.side = DoubleSide;
            break;

          case 'transparency':
            console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
            json.opacity = value;
            break;

          case 'depthTest':
          case 'depthWrite':
          case 'colorWrite':
          case 'opacity':
          case 'reflectivity':
          case 'transparent':
          case 'visible':
          case 'wireframe':
            json[name] = value;
            break;

          case 'vertexColors':
            if (value === true) json.vertexColors = VertexColors;
            if (value === 'face') json.vertexColors = FaceColors;
            break;

          default:
            console.error('THREE.Loader.createMaterial: Unsupported', name, value);
            break;
        }
      }

      if (json.type === 'MeshBasicMaterial') delete json.emissive;
      if (json.type !== 'MeshPhongMaterial') delete json.specular;
      if (json.opacity < 1) json.transparent = true;
      materialLoader.setTextures(textures);
      return materialLoader.parse(json);
    };
  }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var context;
var AudioContext = {
  getContext: function () {
    if (context === undefined) {
      context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return context;
  },
  setContext: function (value) {
    context = value;
  }
};
/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

exports.AudioContext = AudioContext;

function AudioLoader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}

Object.assign(AudioLoader.prototype, {
  load: function (url, onLoad, onProgress, onError) {
    var loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      // Create a copy of the buffer. The `decodeAudioData` method
      // detaches the buffer when complete, preventing reuse.
      var bufferCopy = buffer.slice(0);
      var context = AudioContext.getContext();
      context.decodeAudioData(bufferCopy, function (audioBuffer) {
        onLoad(audioBuffer);
      });
    }, onProgress, onError);
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {
  this.type = 'StereoCamera';
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
}

Object.assign(StereoCamera.prototype, {
  update: function () {
    var instance, focus, fov, aspect, near, far, zoom, eyeSep;
    var eyeRight = new Matrix4();
    var eyeLeft = new Matrix4();
    return function update(camera) {
      var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

      if (needsUpdate) {
        instance = this;
        focus = camera.focus;
        fov = camera.fov;
        aspect = camera.aspect * this.aspect;
        near = camera.near;
        far = camera.far;
        zoom = camera.zoom; // Off-axis stereoscopic effect based on
        // http://paulbourke.net/stereographics/stereorender/

        var projectionMatrix = camera.projectionMatrix.clone();
        eyeSep = this.eyeSep / 2;
        var eyeSepOnProjection = eyeSep * near / focus;
        var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
        var xmin, xmax; // translate xOffset

        eyeLeft.elements[12] = -eyeSep;
        eyeRight.elements[12] = eyeSep; // for left eye

        xmin = -ymax * aspect + eyeSepOnProjection;
        xmax = ymax * aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

        xmin = -ymax * aspect - eyeSepOnProjection;
        xmax = ymax * aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }

      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
    };
  }()
});
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

function CubeCamera(near, far, cubeResolution, options) {
  Object3D.call(this);
  this.type = 'CubeCamera';
  var fov = 90,
      aspect = 1;
  var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  options = options || {
    format: RGBFormat,
    magFilter: LinearFilter,
    minFilter: LinearFilter
  };
  this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
  this.renderTarget.texture.name = "CubeCamera";

  this.update = function (renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
  };

  this.clear = function (renderer, color, depth, stencil) {
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;

    for (var i = 0; i < 6; i++) {
      renderer.setRenderTarget(renderTarget, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  };
}

CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock(autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}

Object.assign(Clock.prototype, {
  start: function () {
    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      var newTime = (typeof performance === 'undefined' ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioListener() {
  Object3D.call(this);
  this.type = 'AudioListener';
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0;
}

AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function () {
    return this.gain;
  },
  removeFilter: function () {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }

    return this;
  },
  getFilter: function () {
    return this.filter;
  },
  setFilter: function (value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }

    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  },
  getMasterVolume: function () {
    return this.gain.gain.value;
  },
  setMasterVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  },
  updateMatrixWorld: function () {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale = new Vector3();
    var orientation = new Vector3();
    var clock = new Clock();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = clock.getDelta();
      this.matrixWorld.decompose(position, quaternion, scale);
      orientation.set(0, 0, -1).applyQuaternion(quaternion);

      if (listener.positionX) {
        // code path for Chrome (see #14393)
        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(position.x, endTime);
        listener.positionY.linearRampToValueAtTime(position.y, endTime);
        listener.positionZ.linearRampToValueAtTime(position.z, endTime);
        listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
        listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
      }
    };
  }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio(listener) {
  Object3D.call(this);
  this.type = 'Audio';
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.startTime = 0;
  this.offset = 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = 'empty';
  this.filters = [];
}

Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio,
  getOutput: function () {
    return this.gain;
  },
  setNodeSource: function (audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  },
  setMediaElementSource: function (mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  },
  setBuffer: function (audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  },
  play: function () {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }

    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    var source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.onended = this.onEnded.bind(this);
    this.startTime = this.context.currentTime;
    source.start(this.startTime, this.offset);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  },
  pause: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    if (this.isPlaying === true) {
      this.source.stop();
      this.source.onended = null;
      this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
      this.isPlaying = false;
    }

    return this;
  },
  stop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.source.stop();
    this.source.onended = null;
    this.offset = 0;
    this.isPlaying = false;
    return this;
  },
  connect: function () {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }

    return this;
  },
  disconnect: function () {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }

    return this;
  },
  getFilters: function () {
    return this.filters;
  },
  setFilters: function (value) {
    if (!value) value = [];

    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }

    return this;
  },
  setDetune: function (value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }

    return this;
  },
  getDetune: function () {
    return this.detune;
  },
  getFilter: function () {
    return this.getFilters()[0];
  },
  setFilter: function (filter) {
    return this.setFilters(filter ? [filter] : []);
  },
  setPlaybackRate: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.playbackRate = value;

    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }

    return this;
  },
  getPlaybackRate: function () {
    return this.playbackRate;
  },
  onEnded: function () {
    this.isPlaying = false;
  },
  getLoop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }

    return this.loop;
  },
  setLoop: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.loop = value;

    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }

    return this;
  },
  getVolume: function () {
    return this.gain.gain.value;
  },
  setVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain);
}

PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
  constructor: PositionalAudio,
  getOutput: function () {
    return this.panner;
  },
  getRefDistance: function () {
    return this.panner.refDistance;
  },
  setRefDistance: function (value) {
    this.panner.refDistance = value;
    return this;
  },
  getRolloffFactor: function () {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function (value) {
    this.panner.rolloffFactor = value;
    return this;
  },
  getDistanceModel: function () {
    return this.panner.distanceModel;
  },
  setDistanceModel: function (value) {
    this.panner.distanceModel = value;
    return this;
  },
  getMaxDistance: function () {
    return this.panner.maxDistance;
  },
  setMaxDistance: function (value) {
    this.panner.maxDistance = value;
    return this;
  },
  setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  },
  updateMatrixWorld: function () {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale = new Vector3();
    var orientation = new Vector3();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      if (this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(position, quaternion, scale);
      orientation.set(0, 0, 1).applyQuaternion(quaternion);
      var panner = this.panner;

      if (panner.positionX) {
        // code path for Chrome and Firefox (see #14393)
        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(position.x, endTime);
        panner.positionY.linearRampToValueAtTime(position.y, endTime);
        panner.positionZ.linearRampToValueAtTime(position.z, endTime);
        panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
        panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
      } else {
        panner.setPosition(position.x, position.y, position.z);
        panner.setOrientation(orientation.x, orientation.y, orientation.z);
      }
    };
  }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}

Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function () {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function () {
    var value = 0,
        data = this.getFrequencyData();

    for (var i = 0; i < data.length; i++) {
      value += data[i];
    }

    return value / data.length;
  }
});
/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  var bufferType = Float64Array,
      mixFunction;

  switch (typeName) {
    case 'quaternion':
      mixFunction = this._slerp;
      break;

    case 'string':
    case 'bool':
      bufferType = Array;
      mixFunction = this._select;
      break;

    default:
      mixFunction = this._lerp;
  }

  this.buffer = new bufferType(valueSize * 4); // layout: [ incoming | accu0 | accu1 | orig ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property

  this._mixBufferRegion = mixFunction;
  this.cumulativeWeight = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}

Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function (accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place
    var buffer = this.buffer,
        stride = this.valueSize,
        offset = accuIndex * stride + stride,
        currentWeight = this.cumulativeWeight;

    if (currentWeight === 0) {
      // accuN := incoming * weight
      for (var i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }

      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight
      currentWeight += weight;
      var mix = weight / currentWeight;

      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }

    this.cumulativeWeight = currentWeight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function (accuIndex) {
    var stride = this.valueSize,
        buffer = this.buffer,
        offset = accuIndex * stride + stride,
        weight = this.cumulativeWeight,
        binding = this.binding;
    this.cumulativeWeight = 0;

    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )
      var originalValueOffset = stride * 3;

      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }

    for (var i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph
        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function () {
    var binding = this.binding;
    var buffer = this.buffer,
        stride = this.valueSize,
        originalValueOffset = stride * 3;
    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }

    this.cumulativeWeight = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function () {
    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  // mix functions
  _select: function (buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (var i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function (buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
    var s = 1 - t;

    for (var i = 0; i !== stride; ++i) {
      var j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
});
/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
// Characters [].:/ are reserved for track binding syntax.

var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

function Composite(targetGroup, path, optionalParsedPath) {
  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}

Object.assign(Composite.prototype, {
  getValue: function (array, offset) {
    this.bind(); // bind all binding

    var firstValidIndex = this._targetGroup.nCachedObjects_,
        binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

    if (binding !== undefined) binding.getValue(array, offset);
  },
  setValue: function (array, offset) {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function () {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function () {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});

function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}

Object.assign(PropertyBinding, {
  Composite: Composite,
  create: function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },

  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param  {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function () {
    var reservedRe = new RegExp('[' + RESERVED_CHARS_RE + ']', 'g');
    return function sanitizeNodeName(name) {
      return name.replace(/\s/g, '_').replace(reservedRe, '');
    };
  }(),
  parseTrackName: function () {
    // Attempts to allow node names from any language. ES5's `\w` regexp matches
    // only latin characters, and the unicode \p{L} is not yet supported. So
    // instead, we exclude reserved characters and match everything else.
    var wordChar = '[^' + RESERVED_CHARS_RE + ']';
    var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
    // be matched to parse the rest of the track name.

    var directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.

    var nodeRe = /(WCOD+)?/.source.replace('WCOD', wordCharOrDot); // Object on target node, and accessor. May not contain reserved
    // characters. Accessor may contain any character except closing bracket.

    var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', wordChar); // Property and accessor. May not contain reserved characters. Accessor may
    // contain any non-bracket characters.

    var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', wordChar);
    var trackRe = new RegExp('' + '^' + directoryRe + nodeRe + objectRe + propertyRe + '$');
    var supportedObjectNames = ['material', 'materials', 'bones'];
    return function parseTrackName(trackName) {
      var matches = trackRe.exec(trackName);

      if (!matches) {
        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
      }

      var results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

      if (lastDot !== undefined && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against a whitelist. Otherwise, there
        // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
        // 'bar' could be the objectName, or part of a nodeName (which can
        // include '.' characters).

        if (supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }

      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
      }

      return results;
    };
  }(),
  findNode: function (root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    } // search into skeleton bones.


    if (root.skeleton) {
      var bone = root.skeleton.getBoneByName(nodeName);

      if (bone !== undefined) {
        return bone;
      }
    } // search into node subtree.


    if (root.children) {
      var searchNodeSubtree = function (children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];

          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }

          var result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }

        return null;
      };

      var subTreeNode = searchNodeSubtree(root.children);

      if (subTreeNode) {
        return subTreeNode;
      }
    }

    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }, function getValue_array(buffer, offset) {
    var source = this.resolvedProperty;

    for (var i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }, function getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }, function getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }],
  SetterByBindingTypeAndVersioning: [[// Direct
  function setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// EntireArray
  function setValue_array(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }, function setValue_array_setNeedsUpdate(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.needsUpdate = true;
  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// ArrayElement
  function setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// HasToFromArray
  function setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
  },
  setValue: function getValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function () {
    var targetObject = this.node,
        parsedPath = this.parsedPath,
        objectName = parsedPath.objectName,
        propertyName = parsedPath.propertyName,
        propertyIndex = parsedPath.propertyIndex;

    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    } // set fail state so we can just 'return' on error


    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable; // ensure there is a value node

    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }

    if (objectName) {
      var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }

          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }

          targetObject = targetObject.material.materials;
          break;

        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          } // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.


          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

          for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }

          break;

        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }

          targetObject = targetObject[objectName];
      }

      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }

        targetObject = targetObject[objectIndex];
      }
    } // resolve property


    var nodeProperty = targetObject[propertyName];

    if (nodeProperty === undefined) {
      var nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    } // determine versioning scheme


    var versioning = this.Versioning.None;
    this.targetObject = targetObject;

    if (targetObject.needsUpdate !== undefined) {
      // material
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    } // determine how the property gets bound


    var bindingType = this.BindingType.Direct;

    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)
      if (propertyName === "morphTargetInfluences") {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }

        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }

          for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        } else {
          if (!targetObject.geometry.morphTargets) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
            return;
          }

          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        }
      }

      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    } // select getter / setter


    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function () {
    this.node = null; // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}); //!\ DECLARE ALIAS AFTER assign prototype !

Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup() {
  this.uuid = _Math.generateUUID(); // cached objects followed by the active ones

  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0; // threshold
  // note: read by PropertyBinding.Composite

  var indices = {};
  this._indicesByUUID = indices; // for bookkeeping

  for (var i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }

  this._paths = []; // inside: string

  this._parsedPaths = []; // inside: { we don't care, here }

  this._bindings = []; // inside: Array< PropertyBinding >

  this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  var scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },

      get inUse() {
        return this.total - scope.nCachedObjects_;
      }

    },

    get bindingsPerObject() {
      return scope._bindings.length;
    }

  };
}

Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function () {
    var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        nBindings = bindings.length,
        knownObject = undefined;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object); // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]; // move existing object to the ACTIVE region

        var firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j],
              lastCached = bindingsForPath[firstActiveIndex],
              binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;

          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }

          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function () {
    var objects = this._objects,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region
        var lastCachedIndex = nCachedObjects++,
            firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j],
              firstActive = bindingsForPath[lastCachedIndex],
              binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function () {
    var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index !== undefined) {
        delete indicesByUUID[uuid];

        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region
          var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex],
              lastIndex = --nObjects,
              lastObject = objects[lastIndex]; // last cached object takes this object's place

          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject; // last object goes to the activated slot and pop

          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex],
                last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop
          var lastIndex = --nObjects,
              lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active

      } // if object is known

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function (path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group
    var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path],
        bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    var paths = this._paths,
        parsedPaths = this._parsedPaths,
        objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);

    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
      var object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }

    return bindingsForPath;
  },
  unsubscribe_: function (path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'
    var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path];

    if (index !== undefined) {
      var paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          lastBindingsIndex = bindings.length - 1,
          lastBindings = bindings[lastBindingsIndex],
          lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction(mixer, clip, localRoot) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  var tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks);
  var interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };

  for (var i = 0; i !== nTracks; ++i) {
    var interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
  }

  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants; // bound by the mixer
  // inside: PropertyMixer (managed by the mixer)

  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null; // for the memory manager

  this._byClipCacheIndex = null; // for the memory manager

  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1; // global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action

  this._startTime = null; // scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop

  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity; // no. of repetitions when looping

  this.paused = false; // true -> zero effective time scale

  this.enabled = true; // false -> zero effective weight

  this.clampWhenFinished = false; // keep feeding the last frame?

  this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

  this.zeroSlopeAtEnd = true; // clips for start, loop and end
}

Object.assign(AnimationAction.prototype, {
  // State & Scheduling
  play: function () {
    this._mixer._activateAction(this);

    return this;
  },
  stop: function () {
    this._mixer._deactivateAction(this);

    return this.reset();
  },
  reset: function () {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip

    this._loopCount = -1; // forget previous loops

    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  },
  isRunning: function () {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function () {
    return this._mixer._isActiveAction(this);
  },
  startAt: function (time) {
    this._startTime = time;
    return this;
  },
  setLoop: function (mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function (weight) {
    this.weight = weight; // note: same logic as when updated at runtime

    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function () {
    return this._effectiveWeight;
  },
  fadeIn: function (duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function (duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function (fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);

    if (warp) {
      var fadeInDuration = this._clip.duration,
          fadeOutDuration = fadeOutAction._clip.duration,
          startEndRatio = fadeOutDuration / fadeInDuration,
          endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }

    return this;
  },
  crossFadeTo: function (fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function () {
    var weightInterpolant = this._weightInterpolant;

    if (weightInterpolant !== null) {
      this._weightInterpolant = null;

      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }

    return this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function (timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function () {
    return this._effectiveTimeScale;
  },
  setDuration: function (duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function (action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function (duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function (startTimeScale, endTimeScale, duration) {
    var mixer = this._mixer,
        now = mixer.time,
        interpolant = this._timeScaleInterpolant,
        timeScale = this.timeScale;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }

    var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function () {
    var timeScaleInterpolant = this._timeScaleInterpolant;

    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;

      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }

    return this;
  },
  // Object Accessors
  getMixer: function () {
    return this._mixer;
  },
  getClip: function () {
    return this._clip;
  },
  getRoot: function () {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function (time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer
    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight
      this._updateWeight(time);

      return;
    }

    var startTime = this._startTime;

    if (startTime !== null) {
      // check for scheduled start of action
      var timeRunning = (time - startTime) * timeDirection;

      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      } // start


      this._startTime = null; // unschedule

      deltaTime = timeDirection * timeRunning;
    } // apply time scale and advance time


    deltaTime *= this._updateTimeScale(time);

    var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
    // an effective weight of 0


    var weight = this._updateWeight(time);

    if (weight > 0) {
      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;

      for (var j = 0, m = interpolants.length; j !== m; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
      }
    }
  },
  _updateWeight: function (time) {
    var weight = 0;

    if (this.enabled) {
      weight = this.weight;
      var interpolant = this._weightInterpolant;

      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();

          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }

    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function (time) {
    var timeScale = 0;

    if (!this.paused) {
      timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;

      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();

          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }

    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function (deltaTime) {
    var time = this.time + deltaTime;
    var duration = this._clip.duration;
    var loop = this.loop;
    var loopCount = this._loopCount;
    var pingPong = loop === LoopPingPong;

    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }

    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started
        this._loopCount = 0;

        this._setEndings(true, true, false);
      }

      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else break handle_stop;

        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;

        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong
      if (loopCount === -1) {
        // just started
        if (deltaTime >= 0) {
          loopCount = 0;

          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }

      if (time >= duration || time < 0) {
        // wrap around
        var loopDelta = Math.floor(time / duration); // signed

        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        var pending = this.repetitions - loopCount;

        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running
          if (pending === 1) {
            // entering the last round
            var atStart = deltaTime < 0;

            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }

          this._loopCount = loopCount;

          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      }

      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"
        this.time = time;
        return duration - time;
      }
    }

    this.time = time;
    return time;
  },
  _setEndings: function (atStart, atEnd, pingPong) {
    var settings = this._interpolantSettings;

    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }

      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function (duration, weightNow, weightThen) {
    var mixer = this._mixer,
        now = mixer.time,
        interpolant = this._weightInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }

    var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
});
/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer(root) {
  this._root = root;

  this._initMemoryManager();

  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1.0;
}

AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function (action, prototypeAction) {
    var root = action._localRoot || this._root,
        tracks = action._clip.tracks,
        nTracks = tracks.length,
        bindings = action._propertyBindings,
        interpolants = action._interpolants,
        rootUuid = root.uuid,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingsByName = bindingsByRoot[rootUuid];

    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }

    for (var i = 0; i !== nTracks; ++i) {
      var track = tracks[i],
          trackName = track.name,
          binding = bindingsByName[trackName];

      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];

        if (binding !== undefined) {
          // existing binding, make sure the cache knows
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;

            this._addInactiveBinding(binding, rootUuid, trackName);
          }

          continue;
        }

        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;

        this._addInactiveBinding(binding, rootUuid, trackName);

        bindings[i] = binding;
      }

      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function (action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind
        var rootUuid = (action._localRoot || this._root).uuid,
            clipUuid = action._clip.uuid,
            actionsForClip = this._actionsByClip[clipUuid];

        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

        this._addInactiveAction(action, clipUuid, rootUuid);
      }

      var bindings = action._propertyBindings; // increment reference counts / sort out state

      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];

        if (binding.useCount++ === 0) {
          this._lendBinding(binding);

          binding.saveOriginalState();
        }
      }

      this._lendAction(action);
    }
  },
  _deactivateAction: function (action) {
    if (this._isActiveAction(action)) {
      var bindings = action._propertyBindings; // decrement reference counts / sort out state

      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];

        if (--binding.useCount === 0) {
          binding.restoreOriginalState();

          this._takeBackBinding(binding);
        }
      }

      this._takeBackAction(action);
    }
  },
  // Memory manager
  _initMemoryManager: function () {
    this._actions = []; // 'nActiveActions' followed by inactive ones

    this._nActiveActions = 0;
    this._actionsByClip = {}; // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones

    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above

    this._nActiveControlInterpolants = 0;
    var scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },

        get inUse() {
          return scope._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },

        get inUse() {
          return scope._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },

        get inUse() {
          return scope._nActiveControlInterpolants;
        }

      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function (action) {
    var index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function (action, clipUuid, rootUuid) {
    var actions = this._actions,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      var knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }

    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function (action) {
    var actions = this._actions,
        lastInactiveAction = actions[actions.length - 1],
        cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    var clipUuid = action._clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid],
        knownActionsForClip = actionsForClip.knownActions,
        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
        byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    var actionByRoot = actionsForClip.actionByRoot,
        rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];

    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }

    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function (action) {
    var bindings = action._propertyBindings;

    for (var i = 0, n = bindings.length; i !== n; ++i) {
      var binding = bindings[i];

      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function (action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s
    var actions = this._actions,
        prevIndex = action._cacheIndex,
        lastActiveIndex = this._nActiveActions++,
        firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function (action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a
    var actions = this._actions,
        prevIndex = action._cacheIndex,
        firstInactiveIndex = --this._nActiveActions,
        lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function (binding, rootUuid, trackName) {
    var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid],
        bindings = this._bindings;

    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }

    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function (binding) {
    var bindings = this._bindings,
        propBinding = binding.binding,
        rootUuid = propBinding.rootNode.uuid,
        trackName = propBinding.path,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid],
        lastInactiveBinding = bindings[bindings.length - 1],
        cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];

    remove_empty_map: {
      for (var _ in bindingByName) break remove_empty_map; // eslint-disable-line no-unused-vars


      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function (binding) {
    var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        lastActiveIndex = this._nActiveBindings++,
        firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function (binding) {
    var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        firstInactiveIndex = --this._nActiveBindings,
        lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function () {
    var interpolants = this._controlInterpolants,
        lastActiveIndex = this._nActiveControlInterpolants++,
        interpolant = interpolants[lastActiveIndex];

    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }

    return interpolant;
  },
  _takeBackControlInterpolant: function (interpolant) {
    var interpolants = this._controlInterpolants,
        prevIndex = interpolant.__cacheIndex,
        firstInactiveIndex = --this._nActiveControlInterpolants,
        lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function (clip, optionalRoot) {
    var root = optionalRoot || this._root,
        rootUuid = root.uuid,
        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
        clipUuid = clipObject !== null ? clipObject.uuid : clip,
        actionsForClip = this._actionsByClip[clipUuid],
        prototypeAction = null;

    if (actionsForClip !== undefined) {
      var existingAction = actionsForClip.actionByRoot[rootUuid];

      if (existingAction !== undefined) {
        return existingAction;
      } // we know the clip, so we don't have to parse all
      // the bindings again but can just copy


      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

      if (clipObject === null) clipObject = prototypeAction._clip;
    } // clip must be known when specified via string


    if (clipObject === null) return null; // allocate all resources required to run it

    var newAction = new AnimationAction(this, clipObject, optionalRoot);

    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


    this._addInactiveAction(newAction, clipUuid, rootUuid);

    return newAction;
  },
  // get an existing action
  existingAction: function (clip, optionalRoot) {
    var root = optionalRoot || this._root,
        rootUuid = root.uuid,
        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
        clipUuid = clipObject ? clipObject.uuid : clip,
        actionsForClip = this._actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }

    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function () {
    var actions = this._actions,
        nActions = this._nActiveActions,
        bindings = this._bindings,
        nBindings = this._nActiveBindings;
    this._nActiveActions = 0;
    this._nActiveBindings = 0;

    for (var i = 0; i !== nActions; ++i) {
      actions[i].reset();
    }

    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].useCount = 0;
    }

    return this;
  },
  // advance the time and update apply the animation
  update: function (deltaTime) {
    deltaTime *= this.timeScale;
    var actions = this._actions,
        nActions = this._nActiveActions,
        time = this.time += deltaTime,
        timeDirection = Math.sign(deltaTime),
        accuIndex = this._accuIndex ^= 1; // run active actions

    for (var i = 0; i !== nActions; ++i) {
      var action = actions[i];

      action._update(time, deltaTime, timeDirection, accuIndex);
    } // update scene graph


    var bindings = this._bindings,
        nBindings = this._nActiveBindings;

    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }

    return this;
  },
  // return this mixer's root target object
  getRoot: function () {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function (clip) {
    var actions = this._actions,
        clipUuid = clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away
      var actionsToRemove = actionsForClip.knownActions;

      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
        var action = actionsToRemove[i];

        this._deactivateAction(action);

        var cacheIndex = action._cacheIndex,
            lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction(action);
      }

      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function (root) {
    var rootUuid = root.uuid,
        actionsByClip = this._actionsByClip;

    for (var clipUuid in actionsByClip) {
      var actionByRoot = actionsByClip[clipUuid].actionByRoot,
          action = actionByRoot[rootUuid];

      if (action !== undefined) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }

    var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName !== undefined) {
      for (var trackName in bindingByName) {
        var binding = bindingByName[trackName];
        binding.restoreOriginalState();

        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function (clip, optionalRoot) {
    var action = this.existingAction(clip, optionalRoot);

    if (action !== null) {
      this._deactivateAction(action);

      this._removeInactiveAction(action);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform(value) {
  if (typeof value === 'string') {
    console.warn('THREE.Uniform: Type parameter is no longer needed.');
    value = arguments[1];
  }

  this.value = value;
}

Uniform.prototype.clone = function () {
  return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */


function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;
}

InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function (source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.maxInstancedCount = source.maxInstancedCount;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === 'number') {
    meshPerAttribute = normalized;
    normalized = false;
    console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
  }

  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.visible === false) return;
  object.raycast(raycaster, intersects);

  if (recursive === true) {
    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}

Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
    } else {
      console.error('THREE.Raycaster: Unsupported camera type.');
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    var intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    var intersects = optionalTarget || [];

    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }

    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axiz.
 */

function Spherical(radius, phi, theta) {
  this.radius = radius !== undefined ? radius : 1.0;
  this.phi = phi !== undefined ? phi : 0; // polar angle

  this.theta = theta !== undefined ? theta : 0; // azimuthal angle

  return this;
}

Object.assign(Spherical.prototype, {
  set: function (radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function () {
    var EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);

    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
    }

    return this;
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical(radius, theta, y) {
  this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane

  this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

  this.y = y !== undefined ? y : 0; // height above the x-z plane

  return this;
}

Object.assign(Cylindrical.prototype, {
  set: function (radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io
 */

function Box2(min, max) {
  this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
}

Object.assign(Box2.prototype, {
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new Vector2();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function (box) {
    // using 4 splitting planes to rule out intersections
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new Vector2();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
/**
 * @author bhouston / http://clara.io
 */

function Line3(start, end) {
  this.start = start !== undefined ? start : new Vector3();
  this.end = end !== undefined ? end : new Vector3();
}

Object.assign(Line3.prototype, {
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }

    return target.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function () {
    var startP = new Vector3();
    var startEnd = new Vector3();
    return function closestPointToPointParameter(point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;

      if (clampToLine) {
        t = _Math.clamp(t, 0, 1);
      }

      return t;
    };
  }(),
  closestPointToPoint: function (point, clampToLine, target) {
    var t = this.closestPointToPointParameter(point, clampToLine);

    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;

  this.render = function ()
  /* renderCallback */
  {};
}

ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function VertexNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== undefined ? size : 1;
  var color = hex !== undefined ? hex : 0xff0000;
  var width = linewidth !== undefined ? linewidth : 1; //

  var nNormals = 0;
  var objGeometry = this.object.geometry;

  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
  } //


  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute('position', positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
  })); //

  this.matrixAutoUpdate = false;
  this.update();
}

VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

VertexNormalsHelper.prototype.update = function () {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update() {
    var keys = ['a', 'b', 'c'];
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position; //

    var objGeometry = this.object.geometry;

    if (objGeometry && objGeometry.isGeometry) {
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;

      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];

        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          var vertex = vertices[face[keys[j]]];
          var normal = face.vertexNormals[j];
          v1.copy(vertex).applyMatrix4(matrixWorld);
          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      var objPos = objGeometry.attributes.position;
      var objNorm = objGeometry.attributes.normal;
      var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal

      for (var j = 0, jl = objPos.count; j < jl; j++) {
        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
    }

    position.needsUpdate = true;
  };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


function SpotLightHelper(light, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry = new BufferGeometry();
  var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

  for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
    var p1 = i / l * Math.PI * 2;
    var p2 = j / l * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
  }

  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  var material = new LineBasicMaterial({
    fog: false
  });
  this.cone = new LineSegments(geometry, material);
  this.add(this.cone);
  this.update();
}

SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

SpotLightHelper.prototype.update = function () {
  var vector = new Vector3();
  return function update() {
    this.light.updateMatrixWorld();
    var coneLength = this.light.distance ? this.light.distance : 1000;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(vector);

    if (this.color !== undefined) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  };
}();
/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */


function getBoneList(object) {
  var boneList = [];

  if (object && object.isBone) {
    boneList.push(object);
  }

  for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }

  return boneList;
}

function SkeletonHelper(object) {
  var bones = getBoneList(object);
  var geometry = new BufferGeometry();
  var vertices = [];
  var colors = [];
  var color1 = new Color(0, 0, 1);
  var color2 = new Color(0, 1, 0);

  for (var i = 0; i < bones.length; i++) {
    var bone = bones[i];

    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }

  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
  LineSegments.call(this, geometry, material);
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}

SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.updateMatrixWorld = function () {
  var vector = new Vector3();
  var boneMatrix = new Matrix4();
  var matrixWorldInv = new Matrix4();
  return function updateMatrixWorld(force) {
    var bones = this.bones;
    var geometry = this.geometry;
    var position = geometry.getAttribute('position');
    matrixWorldInv.getInverse(this.root.matrixWorld);

    for (var i = 0, j = 0; i < bones.length; i++) {
      var bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j, vector.x, vector.y, vector.z);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j + 1, vector.x, vector.y, vector.z);
        j += 2;
      }
    }

    geometry.getAttribute('position').needsUpdate = true;
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


function PointLightHelper(light, sphereSize, color) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color;
  var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
  var material = new MeshBasicMaterial({
    wireframe: true,
    fog: false
  });
  Mesh.call(this, geometry, material);
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
  /*
  var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
  	var d = light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.scale.set( d, d, d );
  	}
  	this.add( this.lightDistance );
  */
}

PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};

PointLightHelper.prototype.update = function () {
  if (this.color !== undefined) {
    this.material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color);
  }
  /*
  var d = this.light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.visible = true;
  	this.lightDistance.scale.set( d, d, d );
  	}
  */

};
/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 *
 *  This helper must be added as a child of the light
 */


function RectAreaLightHelper(light, color) {
  this.type = 'RectAreaLightHelper';
  this.light = light;
  this.color = color; // optional hardwired color for the helper

  var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  var material = new LineBasicMaterial({
    fog: false
  });
  Line.call(this, geometry, material); //

  var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({
    side: BackSide,
    fog: false
  })));
  this.update();
}

RectAreaLightHelper.prototype = Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

RectAreaLightHelper.prototype.update = function () {
  this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);

  if (this.color !== undefined) {
    this.material.color.set(this.color);
    this.children[0].material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); // prevent hue shift

    var c = this.material.color;
    var max = Math.max(c.r, c.g, c.b);
    if (max > 1) c.multiplyScalar(1 / max);
    this.children[0].material.color.copy(this.material.color);
  }
};

RectAreaLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */


function HemisphereLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry = new OctahedronBufferGeometry(size);
  geometry.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({
    wireframe: true,
    fog: false
  });
  if (this.color === undefined) this.material.vertexColors = VertexColors;
  var position = geometry.getAttribute('position');
  var colors = new Float32Array(position.count * 3);
  geometry.addAttribute('color', new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry, this.material));
  this.update();
}

HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};

HemisphereLightHelper.prototype.update = function () {
  var vector = new Vector3();
  var color1 = new Color();
  var color2 = new Color();
  return function update() {
    var mesh = this.children[0];

    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      var colors = mesh.geometry.getAttribute('color');
      color1.copy(this.light.color);
      color2.copy(this.light.groundColor);

      for (var i = 0, l = colors.count; i < l; i++) {
        var color = i < l / 2 ? color1 : color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }

      colors.needsUpdate = true;
    }

    mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
}();
/**
 * @author mrdoob / http://mrdoob.com/
 */


function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  var center = divisions / 2;
  var step = size / divisions;
  var halfSize = size / 2;
  var vertices = [],
      colors = [];

  for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
    vertices.push(-halfSize, 0, k, halfSize, 0, k);
    vertices.push(k, 0, -halfSize, k, 0, halfSize);
    var color = i === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
  }

  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

GridHelper.prototype = Object.create(LineSegments.prototype);
GridHelper.prototype.constructor = GridHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  var vertices = [];
  var colors = [];
  var x, z;
  var v, i, j, r, color; // create the radials

  for (i = 0; i <= radials; i++) {
    v = i / radials * (Math.PI * 2);
    x = Math.sin(v) * radius;
    z = Math.cos(v) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x, 0, z);
    color = i & 1 ? color1 : color2;
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
  } // create the circles


  for (i = 0; i <= circles; i++) {
    color = i & 1 ? color1 : color2;
    r = radius - radius / circles * i;

    for (j = 0; j < divisions; j++) {
      // first vertex
      v = j / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b); // second vertex

      v = (j + 1) / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b);
    }
  }

  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
/**
 * @author Mugen87 / http://github.com/Mugen87
 */

function PositionalAudioHelper(audio, range, divisionsInnerAngle, divisionsOuterAngle) {
  this.audio = audio;
  this.range = range || 1;
  this.divisionsInnerAngle = divisionsInnerAngle || 16;
  this.divisionsOuterAngle = divisionsOuterAngle || 2;
  var geometry = new BufferGeometry();
  var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
  var positions = new Float32Array((divisions * 3 + 3) * 3);
  geometry.addAttribute('position', new BufferAttribute(positions, 3));
  var materialInnerAngle = new LineBasicMaterial({
    color: 0x00ff00
  });
  var materialOuterAngle = new LineBasicMaterial({
    color: 0xffff00
  });
  Line.call(this, geometry, [materialOuterAngle, materialInnerAngle]);
  this.update();
}

PositionalAudioHelper.prototype = Object.create(Line.prototype);
PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

PositionalAudioHelper.prototype.update = function () {
  var audio = this.audio;
  var range = this.range;
  var divisionsInnerAngle = this.divisionsInnerAngle;
  var divisionsOuterAngle = this.divisionsOuterAngle;

  var coneInnerAngle = _Math.degToRad(audio.panner.coneInnerAngle);

  var coneOuterAngle = _Math.degToRad(audio.panner.coneOuterAngle);

  var halfConeInnerAngle = coneInnerAngle / 2;
  var halfConeOuterAngle = coneOuterAngle / 2;
  var start = 0;
  var count = 0;
  var i, stride;
  var geometry = this.geometry;
  var positionAttribute = geometry.attributes.position;
  geometry.clearGroups(); //

  function generateSegment(from, to, divisions, materialIndex) {
    var step = (to - from) / divisions;
    positionAttribute.setXYZ(start, 0, 0, 0);
    count++;

    for (i = from; i < to; i += step) {
      stride = start + count;
      positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
      positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
      positionAttribute.setXYZ(stride + 2, 0, 0, 0);
      count += 3;
    }

    geometry.addGroup(start, count, materialIndex);
    start += count;
    count = 0;
  } //


  generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
  generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
  generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0); //

  positionAttribute.needsUpdate = true;
  if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;
};

PositionalAudioHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material[0].dispose();
  this.material[1].dispose();
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


function FaceNormalsHelper(object, size, hex, linewidth) {
  // FaceNormalsHelper only supports THREE.Geometry
  this.object = object;
  this.size = size !== undefined ? size : 1;
  var color = hex !== undefined ? hex : 0xffff00;
  var width = linewidth !== undefined ? linewidth : 1; //

  var nNormals = 0;
  var objGeometry = this.object.geometry;

  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
  } else {
    console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
  } //


  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute('position', positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
  })); //

  this.matrixAutoUpdate = false;
  this.update();
}

FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

FaceNormalsHelper.prototype.update = function () {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update() {
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position; //

    var objGeometry = this.object.geometry;
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;

    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      var normal = face.normal;
      v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
      v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
      position.setXYZ(idx, v1.x, v1.y, v1.z);
      idx = idx + 1;
      position.setXYZ(idx, v2.x, v2.y, v2.z);
      idx = idx + 1;
    }

    position.needsUpdate = true;
  };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


function DirectionalLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  if (size === undefined) size = 1;
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
  var material = new LineBasicMaterial({
    fog: false
  });
  this.lightPlane = new Line(geometry, material);
  this.add(this.lightPlane);
  geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry, material);
  this.add(this.targetLine);
  this.update();
}

DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

DirectionalLightHelper.prototype.update = function () {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var v3 = new Vector3();
  return function update() {
    v1.setFromMatrixPosition(this.light.matrixWorld);
    v2.setFromMatrixPosition(this.light.target.matrixWorld);
    v3.subVectors(v2, v1);
    this.lightPlane.lookAt(v2);

    if (this.color !== undefined) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }

    this.targetLine.lookAt(v2);
    this.targetLine.scale.z = v3.length();
  };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */


function CameraHelper(camera) {
  var geometry = new BufferGeometry();
  var material = new LineBasicMaterial({
    color: 0xffffff,
    vertexColors: FaceColors
  });
  var vertices = [];
  var colors = [];
  var pointMap = {}; // colors

  var colorFrustum = new Color(0xffaa00);
  var colorCone = new Color(0xff0000);
  var colorUp = new Color(0x00aaff);
  var colorTarget = new Color(0xffffff);
  var colorCross = new Color(0x333333); // near

  addLine('n1', 'n2', colorFrustum);
  addLine('n2', 'n4', colorFrustum);
  addLine('n4', 'n3', colorFrustum);
  addLine('n3', 'n1', colorFrustum); // far

  addLine('f1', 'f2', colorFrustum);
  addLine('f2', 'f4', colorFrustum);
  addLine('f4', 'f3', colorFrustum);
  addLine('f3', 'f1', colorFrustum); // sides

  addLine('n1', 'f1', colorFrustum);
  addLine('n2', 'f2', colorFrustum);
  addLine('n3', 'f3', colorFrustum);
  addLine('n4', 'f4', colorFrustum); // cone

  addLine('p', 'n1', colorCone);
  addLine('p', 'n2', colorCone);
  addLine('p', 'n3', colorCone);
  addLine('p', 'n4', colorCone); // up

  addLine('u1', 'u2', colorUp);
  addLine('u2', 'u3', colorUp);
  addLine('u3', 'u1', colorUp); // target

  addLine('c', 't', colorTarget);
  addLine('p', 'c', colorCross); // cross

  addLine('cn1', 'cn2', colorCross);
  addLine('cn3', 'cn4', colorCross);
  addLine('cf1', 'cf2', colorCross);
  addLine('cf3', 'cf4', colorCross);

  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }

  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);

    if (pointMap[id] === undefined) {
      pointMap[id] = [];
    }

    pointMap[id].push(vertices.length / 3 - 1);
  }

  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry, material);
  this.camera = camera;
  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}

CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {
  var geometry, pointMap;
  var vector = new Vector3();
  var camera = new Camera();

  function setPoint(point, x, y, z) {
    vector.set(x, y, z).unproject(camera);
    var points = pointMap[point];

    if (points !== undefined) {
      var position = geometry.getAttribute('position');

      for (var i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], vector.x, vector.y, vector.z);
      }
    }
  }

  return function update() {
    geometry = this.geometry;
    pointMap = this.pointMap;
    var w = 1,
        h = 1; // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy(this.camera.projectionMatrix); // center / target

    setPoint('c', 0, 0, -1);
    setPoint('t', 0, 0, 1); // near

    setPoint('n1', -w, -h, -1);
    setPoint('n2', w, -h, -1);
    setPoint('n3', -w, h, -1);
    setPoint('n4', w, h, -1); // far

    setPoint('f1', -w, -h, 1);
    setPoint('f2', w, -h, 1);
    setPoint('f3', -w, h, 1);
    setPoint('f4', w, h, 1); // up

    setPoint('u1', w * 0.7, h * 1.1, -1);
    setPoint('u2', -w * 0.7, h * 1.1, -1);
    setPoint('u3', 0, h * 2, -1); // cross

    setPoint('cf1', -w, 0, 1);
    setPoint('cf2', w, 0, 1);
    setPoint('cf3', 0, -h, 1);
    setPoint('cf4', 0, h, 1);
    setPoint('cn1', -w, 0, -1);
    setPoint('cn2', w, 0, -1);
    setPoint('cn3', 0, -h, -1);
    setPoint('cn4', 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
  };
}();
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */


function BoxHelper(object, color) {
  this.object = object;
  if (color === undefined) color = 0xffff00;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = new Float32Array(8 * 3);
  var geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.addAttribute('position', new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color
  }));
  this.matrixAutoUpdate = false;
  this.update();
}

BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function () {
  var box = new Box3();
  return function update(object) {
    if (object !== undefined) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    }

    if (this.object !== undefined) {
      box.setFromObject(this.object);
    }

    if (box.isEmpty()) return;
    var min = box.min;
    var max = box.max;
    /*
      5____4
    1/___0/|
    | 6__|_7
    2/___3/
    	0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    var position = this.geometry.attributes.position;
    var array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  };
}();

BoxHelper.prototype.setFromObject = function (object) {
  this.object = object;
  this.update();
  return this;
};

BoxHelper.prototype.copy = function (source) {
  LineSegments.prototype.copy.call(this, source);
  this.object = source.object;
  return this;
};

BoxHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function Box3Helper(box, hex) {
  this.type = 'Box3Helper';
  this.box = box;
  var color = hex !== undefined ? hex : 0xffff00;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  var geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color
  }));
  this.geometry.computeBoundingSphere();
}

Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;

Box3Helper.prototype.updateMatrixWorld = function (force) {
  var box = this.box;
  if (box.isEmpty()) return;
  box.getCenter(this.position);
  box.getSize(this.scale);
  this.scale.multiplyScalar(0.5);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function PlaneHelper(plane, size, hex) {
  this.type = 'PlaneHelper';
  this.plane = plane;
  this.size = size === undefined ? 1 : size;
  var color = hex !== undefined ? hex : 0xffff00;
  var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  Line.call(this, geometry, new LineBasicMaterial({
    color: color
  })); //

  var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({
    color: color,
    opacity: 0.2,
    transparent: true,
    depthWrite: false
  })));
}

PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld = function (force) {
  var scale = -this.plane.constant;
  if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

  this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
  this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  this.lookAt(this.plane.normal);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */


var lineGeometry, coneGeometry;

function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
  // dir is assumed to be normalized
  Object3D.call(this);
  if (dir === undefined) dir = new Vector3(0, 0, 1);
  if (origin === undefined) origin = new Vector3(0, 0, 0);
  if (length === undefined) length = 1;
  if (color === undefined) color = 0xffff00;
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;

  if (lineGeometry === undefined) {
    lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
    coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
    coneGeometry.translate(0, -0.5, 0);
  }

  this.position.copy(origin);
  this.line = new Line(lineGeometry, new LineBasicMaterial({
    color: color
  }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
    color: color
  }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}

ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = function () {
  var axis = new Vector3();
  var radians;
  return function setDirection(dir) {
    // dir is assumed to be normalized
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();
      radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(axis, radians);
    }
  };
}();

ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;
  this.line.scale.set(1, Math.max(0, length - headLength), 1);
  this.line.updateMatrix();
  this.cone.scale.set(headWidth, headLength, headWidth);
  this.cone.position.y = length;
  this.cone.updateMatrix();
};

ArrowHelper.prototype.setColor = function (color) {
  this.line.material.color.copy(color);
  this.cone.material.color.copy(color);
};

ArrowHelper.prototype.copy = function (source) {
  Object3D.prototype.copy.call(this, source, false);
  this.line.copy(source.line);
  this.cone.copy(source.cone);
  return this;
};

ArrowHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */


function AxesHelper(size) {
  size = size || 1;
  var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
  var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4(a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new Face3(a, b, c, normal, color, materialIndex);
}

var LineStrip = 0;
exports.LineStrip = LineStrip;
var LinePieces = 1;
exports.LinePieces = LinePieces;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials) {
  if (materials === undefined) materials = [];
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}

function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
} //


function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
  return new BufferAttribute(array, itemSize).setDynamic(true);
}

function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}

function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}

function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}

function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}

function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}

function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}

function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}

function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}

function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
} //


Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Object.assign(CurvePath.prototype, {
  createPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from path points (for Line or Points objects)

    var pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from equidistant sampling along the path

    var pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function (points) {
    console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
    var geometry = new Geometry();

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return geometry;
  }
}); //

Object.assign(Path.prototype, {
  fromPoints: function (points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    this.setFromPoints(points);
  }
}); //

function ClosedSplineCurve3(points) {
  console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
  this.closed = true;
}

ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function SplineCurve3(points) {
  console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function Spline(points) {
  console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function ()
  /* a */
  {
    console.error('THREE.Spline: .initFromArray() has been removed.');
  },
  getControlPointsArray: function ()
  /* optionalTarget */
  {
    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
  },
  reparametrizeByArcLength: function ()
  /* samplingCoef */
  {
    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
  }
}); //

function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}

function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}

function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
} //


Object.assign(Loader.prototype, {
  extractUrlBase: function (url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
  }
});

function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}

function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
}

Object.assign(ObjectLoader.prototype, {
  setTexturePath: function (value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }
}); //

Object.assign(Box2.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});

Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Object.assign(_Math, {
  random16: function () {
    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  nearestPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
    return _Math.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
    return _Math.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
  },
  applyToBuffer: function (buffer
  /*, offset, length */
  ) {
    console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function (m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: function () {
    var v1;
    return function getPosition() {
      if (v1 === undefined) v1 = new Vector3();
      console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      return v1.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function (q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
  },
  rotateAxis: function (v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  translate: function () {
    console.error('THREE.Matrix4: .translate() has been removed.');
  },
  rotateX: function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
  },
  rotateY: function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
  },
  rotateZ: function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
  },
  rotateByAxis: function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
  },
  applyToBuffer: function (buffer
  /*, offset, length */
  ) {
    console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
  },
  makeFrustum: function (left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});

Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
};

Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Object.assign(Ray.prototype, {
  isIntersectionBox: function (box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function (plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function () {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
  },
  barycoordFromPoint: function (point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
  },
  midpoint: function (target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
  },
  normal: function (target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
  },
  plane: function (target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function (point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function (a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function (divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
  },
  extrude: function (options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function (options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
  },
  setEulerFromQuaternion: function () {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
  },
  getPositionFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function (index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function (m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
  },
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
}); //

Object.assign(Geometry.prototype, {
  computeTangents: function () {
    console.error('THREE.Geometry: .computeTangents() has been removed.');
  },
  computeLineDistances: function () {
    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function (name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
  },
  renderDepth: function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
  },
  translate: function (distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function () {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function () {
      console.warn('THREE.LOD: .objects has been renamed to .levels.');
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
  get: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  },
  set: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
};

Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
  get: function () {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    return this.arcLengthDivisions;
  },
  set: function (value) {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    this.arcLengthDivisions = value;
  }
}); //

PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  copyIndicesArray: function ()
  /* indices */
  {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function (index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
  },
  addDrawCall: function (start, count, indexOffset) {
    if (indexOffset !== undefined) {
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    }

    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
  },
  clearDrawCalls: function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
  },
  computeTangents: function () {
    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
  },
  computeOffsets: function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
}); //

Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function () {
    console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
  },
  addShapeList: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
  },
  addShape: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
  }
}); //

Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function () {
      console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
    }
  },
  onUpdate: {
    value: function () {
      console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
      return this;
    }
  }
}); //

Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

Object.assign(WebGLRenderer.prototype, {
  clearTarget: function (renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function (callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function () {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
  },
  resetGLState: function () {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
  },
  supportsFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
  },
  supportsHalfFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
  },
  supportsStandardDerivatives: function () {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
  },
  supportsCompressedTextureS3TC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
  },
  supportsCompressedTexturePVRTC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
  },
  supportsBlendMinMax: function () {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
  },
  supportsVertexTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
  },
  enableScissorTest: function (boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
  },
  initMaterial: function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
  },
  addPrePlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
  },
  addPostPlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
  },
  updateShadowMap: function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
  },
  setFaceCulling: function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* cullFace */
    {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
}); //

Object.defineProperties(WebGLRenderTargetCube.prototype, {
  activeCubeFace: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().');
    }
  },
  activeMipMapLevel: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().');
    }
  }
}); //

Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Object.defineProperties(WebVRManager.prototype, {
  standing: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebVRManager: .standing has been removed.');
    }
  },
  userHeight: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebVRManager: .userHeight has been removed.');
    }
  }
}); //

Audio.prototype.load = function (file) {
  console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function (buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
}; //


var GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    var matrix;

    if (geometry2.isMesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }

    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
exports.GeometryUtils = GeometryUtils;
ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  var loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  var loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function Projector() {
  console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');

  this.projectVector = function (vector, camera) {
    console.warn('THREE.Projector: .projectVector() is now vector.project().');
    vector.project(camera);
  };

  this.unprojectVector = function (vector, camera) {
    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
    vector.unproject(camera);
  };

  this.pickingRay = function () {
    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
  };
} //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


var SceneUtils = {
  createMultiMaterialObject: function ()
  /* geometry, materials */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  },
  detach: function ()
  /* child, parent, scene */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  },
  attach: function ()
  /* child, scene, parent */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
}
},{}],"node_modules/three-orbitcontrols/OrbitControls.js":[function(require,module,exports) {
/* three-orbitcontrols addendum */ var THREE = require('three');
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

THREE.OrbitControls = function ( object, domElement ) {

	this.object = object;

	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = - Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.panSpeed = 1.0;
	this.screenSpacePanning = false; // if true, pan in screen-space
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;

	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;

	};

	this.saveState = function () {

		scope.target0.copy( scope.target );
		scope.position0.copy( scope.object.position );
		scope.zoom0 = scope.object.zoom;

	};

	this.reset = function () {

		scope.target.copy( scope.target0 );
		scope.object.position.copy( scope.position0 );
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent( changeEvent );

		scope.update();

		state = STATE.NONE;

	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy( position ).sub( scope.target );

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion( quat );

			// angle from z-axis around y-axis
			spherical.setFromVector3( offset );

			if ( scope.autoRotate && state === STATE.NONE ) {

				rotateLeft( getAutoRotationAngle() );

			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

			// restrict phi to be between desired limits
			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

			spherical.makeSafe();


			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

			// move target to panned location
			scope.target.add( panOffset );

			offset.setFromSpherical( spherical );

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion( quatInverse );

			position.copy( scope.target ).add( offset );

			scope.object.lookAt( scope.target );

			if ( scope.enableDamping === true ) {

				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

				panOffset.multiplyScalar( 1 - scope.dampingFactor );

			} else {

				sphericalDelta.set( 0, 0, 0 );

				panOffset.set( 0, 0, 0 );

			}

			scale = 1;

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if ( zoomChanged ||
				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

				scope.dispatchEvent( changeEvent );

				lastPosition.copy( scope.object.position );
				lastQuaternion.copy( scope.object.quaternion );
				zoomChanged = false;

				return true;

			}

			return false;

		};

	}();

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		window.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.zoomSpeed );

	}

	function rotateLeft( angle ) {

		sphericalDelta.theta -= angle;

	}

	function rotateUp( angle ) {

		sphericalDelta.phi -= angle;

	}

	var panLeft = function () {

		var v = new THREE.Vector3();

		return function panLeft( distance, objectMatrix ) {

			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
			v.multiplyScalar( - distance );

			panOffset.add( v );

		};

	}();

	var panUp = function () {

		var v = new THREE.Vector3();

		return function panUp( distance, objectMatrix ) {

			if ( scope.screenSpacePanning === true ) {

				v.setFromMatrixColumn( objectMatrix, 1 );

			} else {

				v.setFromMatrixColumn( objectMatrix, 0 );
				v.crossVectors( scope.object.up, v );

			}

			v.multiplyScalar( distance );

			panOffset.add( v );

		};

	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new THREE.Vector3();

		return function pan( deltaX, deltaY ) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if ( scope.object.isPerspectiveCamera ) {

				// perspective
				var position = scope.object.position;
				offset.copy( position ).sub( scope.target );
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

				// we use only clientHeight here so aspect ratio does not distort speed
				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

			} else if ( scope.object.isOrthographicCamera ) {

				// orthographic
				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

			} else {

				// camera neither orthographic nor perspective
				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
				scope.enablePan = false;

			}

		};

	}();

	function dollyIn( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale /= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	function dollyOut( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale *= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownDolly( event ) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownPan( event ) {

		//console.log( 'handleMouseDownPan' );

		panStart.set( event.clientX, event.clientY );

	}

	function handleMouseMoveRotate( event ) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set( event.clientX, event.clientY );

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleMouseMoveDolly( event ) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set( event.clientX, event.clientY );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyIn( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyOut( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleMouseMovePan( event ) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set( event.clientX, event.clientY );

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleMouseUp( event ) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel( event ) {

		// console.log( 'handleMouseWheel' );

		if ( event.deltaY < 0 ) {

			dollyOut( getZoomScale() );

		} else if ( event.deltaY > 0 ) {

			dollyIn( getZoomScale() );

		}

		scope.update();

	}

	function handleKeyDown( event ) {

		// console.log( 'handleKeyDown' );

		var needsUpdate = false;

		switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

		}

		if ( needsUpdate ) {

			// prevent the browser from scrolling on cursor keys
			event.preventDefault();

			scope.update();

		}


	}

	function handleTouchStartRotate( event ) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

	}

	function handleTouchStartDollyPan( event ) {

		//console.log( 'handleTouchStartDollyPan' );

		if ( scope.enableZoom ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		if ( scope.enablePan ) {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panStart.set( x, y );

		}

	}

	function handleTouchMoveRotate( event ) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleTouchMoveDollyPan( event ) {

		//console.log( 'handleTouchMoveDollyPan' );

		if ( scope.enableZoom ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyIn( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		if ( scope.enablePan ) {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panEnd.set( x, y );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		scope.update();

	}

	function handleTouchEnd( event ) {

		//console.log( 'handleTouchEnd' );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown( event ) {

		if ( scope.enabled === false ) return;

		// Prevent the browser from scrolling.

		event.preventDefault();

		// Manually set the focus since calling preventDefault above
		// prevents the browser from setting it automatically.

		scope.domElement.focus ? scope.domElement.focus() : window.focus();

		switch ( event.button ) {

			case scope.mouseButtons.LEFT:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

				} else {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				}

				break;

			case scope.mouseButtons.MIDDLE:

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

				break;

			case scope.mouseButtons.RIGHT:

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

				break;

		}

		if ( state !== STATE.NONE ) {

			document.addEventListener( 'mousemove', onMouseMove, false );
			document.addEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( startEvent );

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		handleMouseUp( event );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

		event.preventDefault();
		event.stopPropagation();

		scope.dispatchEvent( startEvent );

		handleMouseWheel( event );

		scope.dispatchEvent( endEvent );

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( event.touches.length ) {

			case 1:	// one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;

				handleTouchStartRotate( event );

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:	// two-fingered touch: dolly-pan

				if ( scope.enableZoom === false && scope.enablePan === false ) return;

				handleTouchStartDollyPan( event );

				state = STATE.TOUCH_DOLLY_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		switch ( event.touches.length ) {

			case 1: // one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;
				if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?

				handleTouchMoveRotate( event );

				break;

			case 2: // two-fingered touch: dolly-pan

				if ( scope.enableZoom === false && scope.enablePan === false ) return;
				if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?

				handleTouchMoveDollyPan( event );

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		handleTouchEnd( event );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	window.addEventListener( 'keydown', onKeyDown, false );

	// force an update at start

	this.update();

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

Object.defineProperties( THREE.OrbitControls.prototype, {

	center: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
			return this.target;

		}

	},

	// backward compatibility

	noZoom: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			return ! this.enableZoom;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			this.enableZoom = ! value;

		}

	},

	noRotate: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			return ! this.enableRotate;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			this.enableRotate = ! value;

		}

	},

	noPan: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			return ! this.enablePan;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			this.enablePan = ! value;

		}

	},

	noKeys: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			return ! this.enableKeys;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			this.enableKeys = ! value;

		}

	},

	staticMoving: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			return ! this.enableDamping;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			this.enableDamping = ! value;

		}

	},

	dynamicDampingFactor: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			return this.dampingFactor;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			this.dampingFactor = value;

		}

	}

} );
/* three-orbitcontrols addendum */ module.exports = exports.default = THREE.OrbitControls;

},{"three":"node_modules/three/build/three.module.js"}],"node_modules/three.interaction/build/three.interaction.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Interaction = exports.InteractionLayer = exports.InteractionManager = void 0;

var _three = require("three");

/**
 * get variable type
 * @param {*} val a variable which you want to get the type
 * @return {String} variable-type
 */
function _rt(val) {
  return Object.prototype.toString.call(val);
}
/**
 * Utils tool box
 *
 * @namespace Utils
 */


var Utils = {
  /**
   * determine whether it is a `Function`
   *
   * @static
   * @method
   * @memberof Utils
   * @param {*} variable a variable which you want to determine
   * @return {Boolean} type result
   */
  isFunction: function () {
    var ks = _rt(function () {});

    return function (variable) {
      return _rt(variable) === ks;
    };
  }(),

  /**
   * determine whether it is a `undefined`
   *
   * @static
   * @method
   * @memberof Utils
   * @param {*} variable a variable which you want to determine
   * @return {Boolean} type result
   */
  isUndefined: function isUndefined(variable) {
    return typeof variable === 'undefined';
  }
};
/**
 * proxy `addEventListener` function
 *
 * @param {String} type event type, evnet name
 * @param {Function} fn callback
 * @return {this} this
 */

_three.EventDispatcher.prototype.on = function (type, fn) {
  if (!Utils.isFunction(fn)) return;
  if (this instanceof _three.Object3D) this.interactive = true;
  this.addEventListener(type, fn);
  return this;
};
/**
 * proxy `removeEventListener` function
 *
 * @param {String} type event type, evnet name
 * @param {Function} fn callback, which you had bind before
 * @return {this} this
 */


_three.EventDispatcher.prototype.off = function (type, fn) {
  this.removeEventListener(type, fn);
  return this;
};
/**
 * binding a once event, just emit once time
 *
 * @param {String} type event type, evnet name
 * @param {Function} fn callback
 * @return {this} this
 */


_three.EventDispatcher.prototype.once = function (type, fn) {
  var _this = this;

  if (!Utils.isFunction(fn)) return;

  var cb = function cb(ev) {
    fn(ev);

    _this.off(type, cb);
  };

  this.on(type, cb);
  return this;
};
/**
 * emit a event
 *
 * @param {String} type event type, evnet name
 * @return {this} this
 */


_three.EventDispatcher.prototype.emit = function (type) {
  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;
  var cbs = this._listeners[type] || [];
  var cache = cbs.slice(0);

  for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    argument[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < cache.length; i++) {
    cache[i].apply(this, argument);
  }

  return this;
};
/**
 * whether displayObject is interactively
 */


_three.Object3D.prototype.interactive = false;
/**
 * whether displayObject's children is interactively
 */

_three.Object3D.prototype.interactiveChildren = true;
/**
 * whether displayObject had touchstart
 * @private
 */

_three.Object3D.prototype.started = false;
/**
 * tracked event cache, like: touchendmouseoutpointerout which decided by primary-event
 */

Object.defineProperty(_three.Object3D.prototype, 'trackedPointers', {
  get: function get() {
    if (!this._trackedPointers) this._trackedPointers = {};
    return this._trackedPointers;
  }
});
/**
 * dispatch a raycast
 *
 * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster
 * @return {Object|Boolean} had pass hit-test
 */

_three.Object3D.prototype.raycastTest = function (raycaster) {
  var result = [];
  this.raycast(raycaster, result);

  if (result.length > 0) {
    return result[0];
  }

  return false;
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
/**
 * Holds all information related to an Interaction event
 *
 * @class
 */


var InteractionData = function () {
  /**
   * InteractionData constructor
   */
  function InteractionData() {
    classCallCheck(this, InteractionData);
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {Vector2}
     */

    this.global = new _three.Vector2();
    /**
     * The target DisplayObject that was interacted with
     *
     * @member {Object3D}
     */

    this.target = null;
    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
     * @member {MouseEvent|TouchEvent|PointerEvent}
     */

    this.originalEvent = null;
    /**
     * Unique identifier for this interaction
     *
     * @member {number}
     */

    this.identifier = null;
    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     * @type {Boolean}
     */

    this.isPrimary = false;
    /**
     * Indicates which button was pressed on the mouse or pointer device to trigger the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
     * @type {number}
     */

    this.button = 0;
    /**
     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
     * @type {number}
     */

    this.buttons = 0;
    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     * @type {number}
     */

    this.width = 0;
    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     * @type {number}
     */

    this.height = 0;
    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
     * @type {number}
     */

    this.tiltX = 0;
    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
     * @type {number}
     */

    this.tiltY = 0;
    /**
     * The type of pointer that triggered the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
     * @type {string}
     */

    this.pointerType = null;
    /**
     * Pressure applied by the pointing device during the event. A Touch's force property
     * will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
     * @type {number}
     */

    this.pressure = 0;
    /**
     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
     * @type {number}
     */

    this.rotationAngle = 0;
    /**
     * Twist of a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */

    this.twist = 0;
    /**
     * Barrel pressure on a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */

    this.tangentialPressure = 0;
  }
  /**
   * The unique identifier of the pointer. It will be the same as `identifier`.
   * @readonly
   * @member {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
   */


  createClass(InteractionData, [{
    key: '_copyEvent',

    /**
     * Copies properties from normalized event data.
     *
     * @param {Touch|MouseEvent|PointerEvent} event The normalized event data
     * @private
     */
    value: function _copyEvent(event) {
      // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite
      // it with "false" on later events when our shim for it on touch events might not be
      // accurate
      if (event.isPrimary) {
        this.isPrimary = true;
      }

      this.button = event.button;
      this.buttons = event.buttons;
      this.width = event.width;
      this.height = event.height;
      this.tiltX = event.tiltX;
      this.tiltY = event.tiltY;
      this.pointerType = event.pointerType;
      this.pressure = event.pressure;
      this.rotationAngle = event.rotationAngle;
      this.twist = event.twist || 0;
      this.tangentialPressure = event.tangentialPressure || 0;
    }
    /**
     * Resets the data for pooling.
     *
     * @private
     */

  }, {
    key: '_reset',
    value: function _reset() {
      // isPrimary is the only property that we really need to reset - everything else is
      // guaranteed to be overwritten
      this.isPrimary = false;
    }
  }, {
    key: 'pointerId',
    get: function get$$1() {
      return this.identifier;
    }
  }]);
  return InteractionData;
}();
/**
 * Event class that mimics native DOM events.
 *
 * @class
 */


var InteractionEvent = function () {
  /**
   * InteractionEvent constructor
   */
  function InteractionEvent() {
    classCallCheck(this, InteractionEvent);
    /**
     * Whether this event will continue propagating in the tree
     *
     * @member {boolean}
     */

    this.stopped = false;
    /**
     * The object which caused this event to be dispatched.
     *
     * @member {Object3D}
     */

    this.target = null;
    /**
     * The object whose event listeners callback is currently being invoked.
     *
     * @member {Object3D}
     */

    this.currentTarget = null;
    /**
     * Type of the event
     *
     * @member {string}
     */

    this.type = null;
    /**
     * InteractionData related to this event
     *
     * @member {InteractionData}
     */

    this.data = null;
    /**
     * ray caster detial from 3d-mesh
     *
     * @member {Intersects}
     */

    this.intersects = [];
  }
  /**
   * Prevents event from reaching any objects other than the current object.
   *
   */


  createClass(InteractionEvent, [{
    key: "stopPropagation",
    value: function stopPropagation() {
      this.stopped = true;
    }
    /**
     * Resets the event.
     *
     * @private
     */

  }, {
    key: "_reset",
    value: function _reset() {
      this.stopped = false;
      this.currentTarget = null;
      this.target = null;
      this.intersects = [];
    }
  }]);
  return InteractionEvent;
}();
/**
 * DisplayObjects with the `trackedPointers` property use this class to track interactions
 *
 * @class
 * @private
 */


var InteractionTrackingData = function () {
  /**
   * @param {number} pointerId - Unique pointer id of the event
   */
  function InteractionTrackingData(pointerId) {
    classCallCheck(this, InteractionTrackingData);
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData.FLAGS.NONE;
  }
  /**
   *
   * @private
   * @param {number} flag - The interaction flag to set
   * @param {boolean} yn - Should the flag be set or unset
   */


  createClass(InteractionTrackingData, [{
    key: "_doSet",
    value: function _doSet(flag, yn) {
      if (yn) {
        this._flags = this._flags | flag;
      } else {
        this._flags = this._flags & ~flag;
      }
    }
    /**
     * Unique pointer id of the event
     *
     * @readonly
     * @member {number}
     */

  }, {
    key: "pointerId",
    get: function get$$1() {
      return this._pointerId;
    }
    /**
     * State of the tracking data, expressed as bit flags
     *
     * @member {number}
     */

  }, {
    key: "flags",
    get: function get$$1() {
      return this._flags;
    }
    /**
     * Set the flags for the tracking data
     *
     * @param {number} flags - Flags to set
     */
    ,
    set: function set$$1(flags) {
      this._flags = flags;
    }
    /**
     * Is the tracked event inactive (not over or down)?
     *
     * @member {number}
     */

  }, {
    key: "none",
    get: function get$$1() {
      return this._flags === this.constructor.FLAGS.NONE;
    }
    /**
     * Is the tracked event over the DisplayObject?
     *
     * @member {boolean}
     */

  }, {
    key: "over",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.OVER) !== 0;
    }
    /**
     * Set the over flag
     *
     * @param {boolean} yn - Is the event over?
     */
    ,
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.OVER, yn);
    }
    /**
     * Did the right mouse button come down in the DisplayObject?
     *
     * @member {boolean}
     */

  }, {
    key: "rightDown",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
    }
    /**
     * Set the right down flag
     *
     * @param {boolean} yn - Is the right mouse button down?
     */
    ,
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
    }
    /**
     * Did the left mouse button come down in the DisplayObject?
     *
     * @member {boolean}
     */

  }, {
    key: "leftDown",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
    }
    /**
     * Set the left down flag
     *
     * @param {boolean} yn - Is the left mouse button down?
     */
    ,
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
    }
  }]);
  return InteractionTrackingData;
}();

InteractionTrackingData.FLAGS = Object.freeze({
  NONE: 0,
  OVER: 1 << 0,
  LEFT_DOWN: 1 << 1,
  RIGHT_DOWN: 1 << 2
});
var MOUSE_POINTER_ID = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()

var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
/**
 * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * reference to [pixi.js](http://www.pixijs.com/) impl
 *
 * @private
 * @class
 * @extends EventDispatcher
 */

var InteractionManager = function (_EventDispatcher) {
  inherits(InteractionManager, _EventDispatcher);
  /**
   * @param {WebGLRenderer} renderer - A reference to the current renderer
   * @param {Scene} scene - A reference to the current scene
   * @param {Camera} camera - A reference to the current camera
   * @param {Object} [options] - The options for the manager.
   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.
   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.
   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
   */

  function InteractionManager(renderer, scene, camera, options) {
    classCallCheck(this, InteractionManager);

    var _this = possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));

    options = options || {};
    /**
     * The renderer this interaction manager works for.
     *
     * @member {WebGLRenderer}
     */

    _this.renderer = renderer;
    /**
     * The renderer this interaction manager works for.
     *
     * @member {Scene}
     */

    _this.scene = scene;
    /**
     * The renderer this interaction manager works for.
     *
     * @member {Camera}
     */

    _this.camera = camera;
    /**
     * Should default browser actions automatically be prevented.
     * Does not apply to pointer events for backwards compatibility
     * preventDefault on pointer events stops mouse events from firing
     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
     *
     * @member {boolean}
     * @default false
     */

    _this.autoPreventDefault = options.autoPreventDefault || false;
    /**
     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.
     *
     * @member {number}
     * @default 10
     */

    _this.interactionFrequency = options.interactionFrequency || 10;
    /**
     * The mouse data
     *
     * @member {InteractionData}
     */

    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does
    //  not get called before we even move the mouse.

    _this.mouse.global.set(-999999);
    /**
     * Actively tracked InteractionData
     *
     * @private
     * @member {Object.<number,InteractionData>}
     */


    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    /**
     * Pool of unused InteractionData
     *
     * @private
     * @member {InteractionData[]}
     */

    _this.interactionDataPool = [];
    /**
     * An event data object to handle all the event tracking/dispatching
     *
     * @member {object}
     */

    _this.eventData = new InteractionEvent();
    /**
     * The DOM element to bind to.
     *
     * @private
     * @member {HTMLElement}
     */

    _this.interactionDOMElement = null;
    /**
     * This property determines if mousemove and touchmove events are fired only when the cursor
     * is over the object.
     * Setting to true will make things work more in line with how the DOM verison works.
     * Setting to false can make things easier for things like dragging
     * It is currently set to false as this is how three.js used to work.
     *
     * @member {boolean}
     * @default true
     */

    _this.moveWhenInside = true;
    /**
     * Have events been attached to the dom element?
     *
     * @private
     * @member {boolean}
     */

    _this.eventsAdded = false;
    /**
     * Is the mouse hovering over the renderer?
     *
     * @private
     * @member {boolean}
     */

    _this.mouseOverRenderer = false;
    /**
     * Does the device support touch events
     * https://www.w3.org/TR/touch-events/
     *
     * @readonly
     * @member {boolean}
     */

    _this.supportsTouchEvents = 'ontouchstart' in window;
    /**
     * Does the device support pointer events
     * https://www.w3.org/Submission/pointer-events/
     *
     * @readonly
     * @member {boolean}
     */

    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time

    /**
     * @private
     * @member {Function}
     */

    _this.onClick = _this.onClick.bind(_this);
    _this.processClick = _this.processClick.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerOver = _this.onPointerOver.bind(_this);
    /**
     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
     * and functions are called instead of changing the CSS.
     * Default CSS cursor values are provided for 'default' and 'pointer' modes.
     * @member {Object.<string, (string|Function|Object.<string, string>)>}
     */

    _this.cursorStyles = {
      default: 'inherit',
      pointer: 'pointer'
    };
    /**
     * The mode of the cursor that is being used.
     * The value of this is a key from the cursorStyles dictionary.
     *
     * @member {string}
     */

    _this.currentCursorMode = null;
    /**
     * Internal cached let.
     *
     * @private
     * @member {string}
     */

    _this.cursor = null;
    /**
     * ray caster, for survey intersects from 3d-scene
     *
     * @private
     * @member {Raycaster}
     */

    _this.raycaster = new _three.Raycaster();
    /**
     * snippet time
     *
     * @private
     * @member {Number}
     */

    _this._deltaTime = 0;

    _this.setTargetElement(_this.renderer.domElement);
    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
     * object.
     *
     * @event InteractionManager#mousedown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * on the display object.
     *
     * @event InteractionManager#rightdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released over the display
     * object.
     *
     * @event InteractionManager#mouseup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * over the display object.
     *
     * @event InteractionManager#rightup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
     * the display object.
     *
     * @event InteractionManager#click
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * and released on the display object.
     *
     * @event InteractionManager#rightclick
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released outside the
     * display object that initially registered a
     * [mousedown]{@link InteractionManager#event:mousedown}.
     *
     * @event InteractionManager#mouseupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * outside the display object that initially registered a
     * [rightdown]{@link InteractionManager#event:rightdown}.
     *
     * @event InteractionManager#rightupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved while over the display object
     *
     * @event InteractionManager#mousemove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved onto the display object
     *
     * @event InteractionManager#mouseover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved off the display object
     *
     * @event InteractionManager#mouseout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed on the display object.
     *
     * @event InteractionManager#pointerdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released over the display object.
     *
     * @event InteractionManager#pointerup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a pointer event
     *
     * @event InteractionManager#pointercancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed and released on the display object.
     *
     * @event InteractionManager#pointertap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released outside the display object that initially
     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.
     *
     * @event InteractionManager#pointerupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved while over the display object
     *
     * @event InteractionManager#pointermove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved onto the display object
     *
     * @event InteractionManager#pointerover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved off the display object
     *
     * @event InteractionManager#pointerout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed on the display object.
     *
     * @event InteractionManager#touchstart
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed from the display object.
     *
     * @event InteractionManager#touchend
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a touch
     *
     * @event InteractionManager#touchcancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed and removed from the display object.
     *
     * @event InteractionManager#tap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed outside of the display object that initially
     * registered a [touchstart]{@link InteractionManager#event:touchstart}.
     *
     * @event InteractionManager#touchendoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is moved along the display object.
     *
     * @event InteractionManager#touchmove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
     * object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mousedown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released over the display
     * object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#click
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightclick
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released outside the
     * display object that initially registered a
     * [mousedown]{@link Object3D#event:mousedown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * outside the display object that initially registered a
     * [rightdown]{@link Object3D#event:rightdown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved while over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mousemove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved onto the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved off the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a pointer event.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointercancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed and released on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointertap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released outside the display object that initially
     * registered a [pointerdown]{@link Object3D#event:pointerdown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved while over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointermove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved onto the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved off the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchstart
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed from the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchend
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a touch.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchcancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed and removed from the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#tap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed outside of the display object that initially
     * registered a [touchstart]{@link Object3D#event:touchstart}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchendoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is moved along the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchmove
     * @param {InteractionEvent} event - Interaction event
     */


    return _this;
  }
  /**
   * Hit tests a point against the display tree, returning the first interactive object that is hit.
   *
   * @param {Point} globalPoint - A point to hit test with, in global space.
   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults
   * to the last rendered root of the associated renderer.
   * @return {Object3D} The hit display object, if any.
   */


  createClass(InteractionManager, [{
    key: 'hitTest',
    value: function hitTest(globalPoint, root) {
      // clear the target for our hit test
      hitTestEvent.target = null; // assign the global point

      hitTestEvent.data.global = globalPoint; // ensure safety of the root

      if (!root) {
        root = this.scene;
      } // run the hit test


      this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything

      return hitTestEvent.target;
    }
    /**
     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
     * another DOM element to receive those events.
     *
     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.
     */

  }, {
    key: 'setTargetElement',
    value: function setTargetElement(element) {
      this.removeEvents();
      this.interactionDOMElement = element;
      this.addEvents();
    }
    /**
     * Registers all the DOM events
     *
     * @private
     */

  }, {
    key: 'addEvents',
    value: function addEvents() {
      if (!this.interactionDOMElement || this.eventsAdded) {
        return;
      }

      this.emit('addevents');
      this.interactionDOMElement.addEventListener('click', this.onClick, true);

      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style['touch-action'] = 'none';
      }
      /**
       * These events are added first, so that if pointer events are normalised, they are fired
       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd
       */


      if (this.supportsPointerEvents) {
        window.document.addEventListener('pointermove', this.onPointerMove, true);
        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel
        // we already handle those, so for the purposes of what we do in onPointerOut, we only
        // care about the pointerleave event

        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
        window.addEventListener('pointercancel', this.onPointerCancel, true);
        window.addEventListener('pointerup', this.onPointerUp, true);
      } else {
        window.document.addEventListener('mousemove', this.onPointerMove, true);
        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
        window.addEventListener('mouseup', this.onPointerUp, true);
      } // always look directly for touch events so that we can provide original data
      // In a future version we should change this to being just a fallback and rely solely on
      // PointerEvents whenever available


      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
      }

      this.eventsAdded = true;
    }
    /**
     * Removes all the DOM events that were previously registered
     *
     * @private
     */

  }, {
    key: 'removeEvents',
    value: function removeEvents() {
      if (!this.interactionDOMElement) {
        return;
      }

      this.emit('removeevents');
      this.interactionDOMElement.removeEventListener('click', this.onClick, true);

      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style['-ms-content-zooming'] = '';
        this.interactionDOMElement.style['-ms-touch-action'] = '';
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style['touch-action'] = '';
      }

      if (this.supportsPointerEvents) {
        window.document.removeEventListener('pointermove', this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
        window.removeEventListener('pointercancel', this.onPointerCancel, true);
        window.removeEventListener('pointerup', this.onPointerUp, true);
      } else {
        window.document.removeEventListener('mousemove', this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
        window.removeEventListener('mouseup', this.onPointerUp, true);
      }

      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
      }

      this.interactionDOMElement = null;
      this.eventsAdded = false;
    }
    /**
     * Updates the state of interactive objects.
     * Invoked by a throttled ticker.
     *
     * @param {number} deltaTime - time delta since last tick
     */

  }, {
    key: 'update',
    value: function update(_ref) {
      var snippet = _ref.snippet;
      this._deltaTime += snippet;

      if (this._deltaTime < this.interactionFrequency) {
        return;
      }

      this._deltaTime = 0;

      if (!this.interactionDOMElement) {
        return;
      } // if the user move the mouse this check has already been done using the mouse move!


      if (this.didMove) {
        this.didMove = false;
        return;
      }

      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
      // but there was a scenario of a display object moving under a static mouse cursor.
      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function

      for (var k in this.activeInteractionData) {
        // eslint-disable-next-line no-prototype-builtins
        if (this.activeInteractionData.hasOwnProperty(k)) {
          var interactionData = this.activeInteractionData[k];

          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);
          }
        }
      }

      this.setCursorMode(this.cursor); // TODO
    }
    /**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
     */

  }, {
    key: 'setCursorMode',
    value: function setCursorMode(mode) {
      mode = mode || 'default'; // if the mode didn't actually change, bail early

      if (this.currentCursorMode === mode) {
        return;
      }

      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it

      if (style) {
        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {
          case 'string':
            // string styles are handled as cursor CSS
            this.interactionDOMElement.style.cursor = style;
            break;

          case 'function':
            // functions are just called, and passed the cursor mode
            style(mode);
            break;

          case 'object':
            // if it is an object, assume that it is a dictionary of CSS styles,
            // apply it to the interactionDOMElement
            Object.assign(this.interactionDOMElement.style, style);
            break;

          default:
            break;
        }
      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry
        // for the mode, then assume that the dev wants it to be CSS for the cursor.
        this.interactionDOMElement.style.cursor = mode;
      }
    }
    /**
     * Dispatches an event on the display object that was interacted with
     *
     * @param {Object3D} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */

  }, {
    key: 'triggerEvent',
    value: function triggerEvent(displayObject, eventString, eventData) {
      if (!eventData.stopped) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);

        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    }
    /**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @private
     * @param {InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {Object3D} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @param {boolean} [interactive] - Whether the displayObject is interactive
     * @return {boolean} returns true if the displayObject hit the point
     */

  }, {
    key: 'processInteractive',
    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
      if (!displayObject || !displayObject.visible) {
        return false;
      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
      //
      // This function will now loop through all objects and then only hit test the objects it HAS
      // to, not all of them. MUCH faster..
      // An object will be hit test if the following is true:
      //
      // 1: It is interactive.
      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
      //
      // As another little optimisation once an interactive object has been hit we can carry on
      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
      // A final optimisation is that an object is not hit test directly if a child has already been hit.


      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;

      if (displayObject.interactiveChildren && displayObject.children) {
        var children = displayObject.children;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i]; // time to get recursive.. if this function will return if something is hit..

          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);

          if (childHit) {
            // its a good idea to check if a child has lost its parent.
            // this means it has been removed whilst looping so its best
            if (!child.parent) {
              continue;
            } // we no longer need to hit test any more objects in this container as we we
            // now know the parent has been hit


            interactiveParent = false; // If the child is interactive , that means that the object hit was actually
            // interactive and not just the child of an interactive object.
            // This means we no longer need to hit test anything else. We still need to run
            // through all objects, but we don't need to perform any hit tests.

            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }

              hit = true;
            }
          }
        }
      } // no point running this if the item is not interactive or does not have an interactive parent.


      if (interactive) {
        // if we are hit testing (as in we have no hit any objects yet)
        // We also don't need to worry about hit testing if once of the displayObjects children
        // has already been hit - but only if it was interactive, otherwise we need to keep
        // looking for an interactive child, just in case we hit one
        if (hitTest && !interactionEvent.target) {
          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {
            hit = true;
          }
        }

        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.data.target = interactionEvent.target = displayObject;
          }

          if (func) {
            func(interactionEvent, displayObject, !!hit);
          }
        }
      }

      return hit;
    }
    /**
     * Is called when the click is pressed down on the renderer element
     *
     * @private
     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down
     */

  }, {
    key: 'onClick',
    value: function onClick(originalEvent) {
      if (originalEvent.type !== 'click') return;
      var events = this.normalizeToPointerData(originalEvent);

      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }

      var interactionData = this.getInteractionDataForPointerId(events[0]);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.scene, this.processClick, true);
      this.emit('click', interactionEvent);
    }
    /**
     * Processes the result of the click check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processClick',
    value: function processClick(interactionEvent, displayObject, hit) {
      if (hit) {
        this.triggerEvent(displayObject, 'click', interactionEvent);
      }
    }
    /**
     * Is called when the pointer button is pressed down on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
     */

  }, {
    key: 'onPointerDown',
    value: function onPointerDown(originalEvent) {
      // if we support touch events, then only use those for touch events, not pointer events
      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent);
      /**
       * No need to prevent default on natural pointer events, as there are no side effects
       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
       * so still need to be prevented.
       */
      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type

      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }

      var eventLen = events.length;

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);
        this.emit('pointerdown', interactionEvent);

        if (event.pointerType === 'touch') {
          this.emit('touchstart', interactionEvent);
        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
        }
      }
    }
    /**
     * Processes the result of the pointer down check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerDown',
    value: function processPointerDown(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;

      if (hit) {
        if (!displayObject.trackedPointers[id]) {
          displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }

        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);

        if (data.pointerType === 'touch') {
          displayObject.started = true;
          this.triggerEvent(displayObject, 'touchstart', interactionEvent);
        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
          var isRightButton = data.button === 2;

          if (isRightButton) {
            displayObject.trackedPointers[id].rightDown = true;
          } else {
            displayObject.trackedPointers[id].leftDown = true;
          }

          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
        }
      }
    }
    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
     * @param {boolean} cancelled - true if the pointer is cancelled
     * @param {Function} func - Function passed to {@link processInteractive}
     */

  }, {
    key: 'onPointerComplete',
    value: function onPointerComplete(originalEvent, cancelled, func) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside
      // in all cases (unless it was a pointercancel)

      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events

        this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);
        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);

        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);
        } else if (event.pointerType === 'touch') {
          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
        }
      }
    }
    /**
     * Is called when the pointer button is cancelled
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */

  }, {
    key: 'onPointerCancel',
    value: function onPointerCancel(event) {
      // if we support touch events, then only use those for touch events, not pointer events
      if (this.supportsTouchEvents && event.pointerType === 'touch') return;
      this.onPointerComplete(event, true, this.processPointerCancel);
    }
    /**
     * Processes the result of the pointer cancel check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     */

  }, {
    key: 'processPointerCancel',
    value: function processPointerCancel(interactionEvent, displayObject) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;

      if (displayObject.trackedPointers[id] !== undefined) {
        delete displayObject.trackedPointers[id];
        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);

        if (data.pointerType === 'touch') {
          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);
        }
      }
    }
    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */

  }, {
    key: 'onPointerUp',
    value: function onPointerUp(event) {
      // if we support touch events, then only use those for touch events, not pointer events
      if (this.supportsTouchEvents && event.pointerType === 'touch') return;
      this.onPointerComplete(event, false, this.processPointerUp);
    }
    /**
     * Processes the result of the pointer up check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerUp',
    value: function processPointerUp(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id];
      var isTouch = data.pointerType === 'touch';
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only

      if (isMouse) {
        var isRightButton = data.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== undefined && trackingData.flags & test;

        if (hit) {
          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);

          if (isDown) {
            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);
          }
        } else if (isDown) {
          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);
        } // update the down state of the tracking data


        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      } // Pointers and Touches, and Mouse


      if (isTouch && displayObject.started) {
        displayObject.started = false;
        this.triggerEvent(displayObject, 'touchend', interactionEvent);
      }

      if (hit) {
        this.triggerEvent(displayObject, 'pointerup', interactionEvent);

        if (trackingData) {
          this.triggerEvent(displayObject, 'pointertap', interactionEvent);

          if (isTouch) {
            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend
            // so we should ensure that we don't keep pretending that they are

            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);
        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);
      } // Only remove the tracking data if there is no over/down state still associated with it


      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
    /**
     * Is called when the pointer moves across the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
     */

  }, {
    key: 'onPointerMove',
    value: function onPointerMove(originalEvent) {
      // if we support touch events, then only use those for touch events, not pointer events
      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent);

      if (events[0].pointerType === 'mouse') {
        this.didMove = true;
        this.cursor = null;
      }

      var eventLen = events.length;

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
        this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);
        this.emit('pointermove', interactionEvent);
        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);
      }

      if (events[0].pointerType === 'mouse') {
        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)
      }
    }
    /**
     * Processes the result of the pointer move check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerMove',
    value: function processPointerMove(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var isTouch = data.pointerType === 'touch';
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';

      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }

      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);

      if (!this.moveWhenInside || hit) {
        this.triggerEvent(displayObject, 'pointermove', interactionEvent);
        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);
      }
    }
    /**
     * Is called when the pointer is moved out of the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
     */

  }, {
    key: 'onPointerOut',
    value: function onPointerOut(originalEvent) {
      // if we support touch events, then only use those for touch events, not pointer events
      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1

      var event = events[0];

      if (event.pointerType === 'mouse') {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }

      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);
      this.emit('pointerout', interactionEvent);

      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
        this.emit('mouseout', interactionEvent);
      } else {
        // we can get touchleave events after touchend, so we want to make sure we don't
        // introduce memory leaks
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    }
    /**
     * Processes the result of the pointer over/out check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerOverOut',
    value: function processPointerOverOut(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state

      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }

      if (trackingData === undefined) return;

      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.triggerEvent(displayObject, 'pointerover', interactionEvent);

          if (isMouse) {
            this.triggerEvent(displayObject, 'mouseover', interactionEvent);
          }
        } // only change the cursor if it has not already been changed (by something deeper in the
        // display tree)


        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.triggerEvent(displayObject, 'pointerout', this.eventData);

        if (isMouse) {
          this.triggerEvent(displayObject, 'mouseout', interactionEvent);
        } // if there is no mouse down information for the pointer, then it is safe to delete


        if (trackingData.none) {
          delete displayObject.trackedPointers[id];
        }
      }
    }
    /**
     * Is called when the pointer is moved into the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
     */

  }, {
    key: 'onPointerOver',
    value: function onPointerOver(originalEvent) {
      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1

      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;

      if (event.pointerType === 'mouse') {
        this.mouseOverRenderer = true;
      }

      this.emit('pointerover', interactionEvent);

      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
        this.emit('mouseover', interactionEvent);
      }
    }
    /**
     * Get InteractionData for a given pointerId. Store that data as well
     *
     * @private
     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
     * @return {InteractionData} - Interaction data for the given pointer identifier
     */

  }, {
    key: 'getInteractionDataForPointerId',
    value: function getInteractionDataForPointerId(event) {
      var pointerId = event.pointerId;
      var interactionData = void 0;

      if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      } // copy properties from the event, so that we can make sure that touch/pointer specific
      // data is available


      interactionData._copyEvent(event);

      return interactionData;
    }
    /**
     * Return unused InteractionData to the pool, for a given pointerId
     *
     * @private
     * @param {number} pointerId - Identifier from a pointer event
     */

  }, {
    key: 'releaseInteractionDataForPointerId',
    value: function releaseInteractionDataForPointerId(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];

      if (interactionData) {
        delete this.activeInteractionData[pointerId];

        interactionData._reset();

        this.interactionDataPool.push(interactionData);
      }
    }
    /**
     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {Vector2} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */

  }, {
    key: 'mapPositionToPoint',
    value: function mapPositionToPoint(point, x, y) {
      var rect = void 0; // IE 11 fix

      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }

      point.x = (x - rect.left) / rect.width * 2 - 1;
      point.y = -((y - rect.top) / rect.height) * 2 + 1;
    }
    /**
     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The event to be configured
     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
     * @param {InteractionData} interactionData - The InteractionData that will be paired
     *        with the InteractionEvent
     * @return {InteractionEvent} the interaction event that was passed in
     */

  }, {
    key: 'configureInteractionEventForDOMEvent',
    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      this.raycaster.setFromCamera(interactionData.global, this.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove

      if (pointerEvent.pointerType === 'touch') {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }

      interactionData.originalEvent = pointerEvent;

      interactionEvent._reset();

      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);
      return interactionEvent;
    }
    /**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @private
     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */

  }, {
    key: 'normalizeToPointerData',
    value: function normalizeToPointerData(event) {
      var normalizedEvents = [];

      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;
          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;

          if (typeof touch.isPrimary === 'undefined') {
            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
          }

          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;
          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;
          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;
          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';
          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;
          touch.twist = 0;
          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven
          // support, and the fill ins are not quite the same
          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top
          // left is not 0,0 on the page

          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it

          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;
        if (typeof event.width === 'undefined') event.width = 1;
        if (typeof event.height === 'undefined') event.height = 1;
        if (typeof event.tiltX === 'undefined') event.tiltX = 0;
        if (typeof event.tiltY === 'undefined') event.tiltY = 0;
        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';
        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;
        if (typeof event.pressure === 'undefined') event.pressure = 0.5;
        event.twist = 0;
        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it

        event.isNormalized = true;
        normalizedEvents.push(event);
      } else {
        normalizedEvents.push(event);
      }

      return normalizedEvents;
    }
    /**
     * Destroys the interaction manager
     *
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.removeEvents();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this._tempPoint = null;
    }
  }]);
  return InteractionManager;
}(_three.EventDispatcher);

exports.InteractionManager = InteractionManager;
var MOUSE_POINTER_ID$1 = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()

var hitTestEvent$1 = {
  target: null,
  data: {
    global: null
  }
};
/**
 * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * reference to [pixi.js](http://www.pixijs.com/) impl
 *
 * @private
 * @class
 * @extends EventDispatcher
 */

var InteractionLayer = function (_EventDispatcher) {
  inherits(InteractionLayer, _EventDispatcher);
  /**
   * @param {WebGLRenderer} renderer - A reference to the current renderer
   * @param {Object} [options] - The options for the manager.
   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.
   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.
   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
   */

  function InteractionLayer(renderer, options) {
    classCallCheck(this, InteractionLayer);

    var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this));

    options = options || {};
    /**
     * The renderer this interaction manager works for.
     *
     * @member {WebGLRenderer}
     */

    _this.renderer = renderer;
    /**
     * The renderer this interaction manager works for.
     *
     * @member {Layer}
     */

    _this.layer = null;
    /**
     * The renderer this interaction manager works for.
     *
     * @member {Scene}
     */
    // this.scene = scene;

    /**
     * The renderer this interaction manager works for.
     *
     * @member {Camera}
     */
    // this.camera = camera;

    /**
     * Should default browser actions automatically be prevented.
     * Does not apply to pointer events for backwards compatibility
     * preventDefault on pointer events stops mouse events from firing
     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
     *
     * @member {boolean}
     * @default false
     */

    _this.autoPreventDefault = options.autoPreventDefault || false;
    /**
     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.
     *
     * @member {number}
     * @default 10
     */

    _this.interactionFrequency = options.interactionFrequency || 10;
    /**
     * The mouse data
     *
     * @member {InteractionData}
     */

    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID$1; // setting the mouse to start off far off screen will mean that mouse over does
    //  not get called before we even move the mouse.

    _this.mouse.global.set(-999999);
    /**
     * Actively tracked InteractionData
     *
     * @private
     * @member {Object.<number,InteractionData>}
     */


    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;
    /**
     * Pool of unused InteractionData
     *
     * @private
     * @member {InteractionData[]}
     */

    _this.interactionDataPool = [];
    /**
     * An event data object to handle all the event tracking/dispatching
     *
     * @member {object}
     */

    _this.eventData = new InteractionEvent();
    /**
     * The DOM element to bind to.
     *
     * @private
     * @member {HTMLElement}
     */

    _this.interactionDOMElement = null;
    /**
     * This property determines if mousemove and touchmove events are fired only when the cursor
     * is over the object.
     * Setting to true will make things work more in line with how the DOM verison works.
     * Setting to false can make things easier for things like dragging
     * It is currently set to false as this is how three.js used to work.
     *
     * @member {boolean}
     * @default true
     */

    _this.moveWhenInside = true;
    /**
     * Have events been attached to the dom element?
     *
     * @private
     * @member {boolean}
     */

    _this.eventsAdded = false;
    /**
     * Is the mouse hovering over the renderer?
     *
     * @private
     * @member {boolean}
     */

    _this.mouseOverRenderer = false;
    /**
     * Does the device support touch events
     * https://www.w3.org/TR/touch-events/
     *
     * @readonly
     * @member {boolean}
     */

    _this.supportsTouchEvents = 'ontouchstart' in window;
    /**
     * Does the device support pointer events
     * https://www.w3.org/Submission/pointer-events/
     *
     * @readonly
     * @member {boolean}
     */

    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time

    /**
     * @private
     * @member {Function}
     */

    _this.onClick = _this.onClick.bind(_this);
    _this.processClick = _this.processClick.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    /**
     * @private
     * @member {Function}
     */

    _this.onPointerOver = _this.onPointerOver.bind(_this);
    /**
     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
     * and functions are called instead of changing the CSS.
     * Default CSS cursor values are provided for 'default' and 'pointer' modes.
     * @member {Object.<string, (string|Function|Object.<string, string>)>}
     */

    _this.cursorStyles = {
      default: 'inherit',
      pointer: 'pointer'
    };
    /**
     * The mode of the cursor that is being used.
     * The value of this is a key from the cursorStyles dictionary.
     *
     * @member {string}
     */

    _this.currentCursorMode = null;
    /**
     * Internal cached let.
     *
     * @private
     * @member {string}
     */

    _this.cursor = null;
    /**
     * ray caster, for survey intersects from 3d-scene
     *
     * @private
     * @member {Raycaster}
     */

    _this.raycaster = new _three.Raycaster();
    /**
     * snippet time
     *
     * @private
     * @member {Number}
     */

    _this._deltaTime = 0;

    _this.setTargetElement(_this.renderer.domElement);
    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
     * object.
     *
     * @event InteractionLayer#mousedown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * on the display object.
     *
     * @event InteractionLayer#rightdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released over the display
     * object.
     *
     * @event InteractionLayer#mouseup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * over the display object.
     *
     * @event InteractionLayer#rightup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
     * the display object.
     *
     * @event InteractionLayer#click
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * and released on the display object.
     *
     * @event InteractionLayer#rightclick
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released outside the
     * display object that initially registered a
     * [mousedown]{@link InteractionLayer#event:mousedown}.
     *
     * @event InteractionLayer#mouseupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * outside the display object that initially registered a
     * [rightdown]{@link InteractionLayer#event:rightdown}.
     *
     * @event InteractionLayer#rightupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved while over the display object
     *
     * @event InteractionLayer#mousemove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved onto the display object
     *
     * @event InteractionLayer#mouseover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved off the display object
     *
     * @event InteractionLayer#mouseout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed on the display object.
     *
     * @event InteractionLayer#pointerdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released over the display object.
     *
     * @event InteractionLayer#pointerup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a pointer event
     *
     * @event InteractionLayer#pointercancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed and released on the display object.
     *
     * @event InteractionLayer#pointertap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released outside the display object that initially
     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.
     *
     * @event InteractionLayer#pointerupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved while over the display object
     *
     * @event InteractionLayer#pointermove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved onto the display object
     *
     * @event InteractionLayer#pointerover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved off the display object
     *
     * @event InteractionLayer#pointerout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed on the display object.
     *
     * @event InteractionLayer#touchstart
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed from the display object.
     *
     * @event InteractionLayer#touchend
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a touch
     *
     * @event InteractionLayer#touchcancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed and removed from the display object.
     *
     * @event InteractionLayer#tap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed outside of the display object that initially
     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.
     *
     * @event InteractionLayer#touchendoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is moved along the display object.
     *
     * @event InteractionLayer#touchmove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
     * object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mousedown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released over the display
     * object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#click
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightclick
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button (usually a mouse left-button) is released outside the
     * display object that initially registered a
     * [mousedown]{@link Object3D#event:mousedown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device secondary button (usually a mouse right-button) is released
     * outside the display object that initially registered a
     * [rightdown]{@link Object3D#event:rightdown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#rightupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved while over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mousemove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved onto the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device (usually a mouse) is moved off the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#mouseout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerdown
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerup
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a pointer event.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointercancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is pressed and released on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointertap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device button is released outside the display object that initially
     * registered a [pointerdown]{@link Object3D#event:pointerdown}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerupoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved while over the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointermove
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved onto the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerover
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a pointer device is moved off the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#pointerout
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed on the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchstart
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed from the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchend
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when the operating system cancels a touch.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchcancel
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is placed and removed from the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#tap
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is removed outside of the display object that initially
     * registered a [touchstart]{@link Object3D#event:touchstart}.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchendoutside
     * @param {InteractionEvent} event - Interaction event
     */

    /**
     * Fired when a touch point is moved along the display object.
     * DisplayObject's `interactive` property must be set to `true` to fire event.
     *
     * @event Object3D#touchmove
     * @param {InteractionEvent} event - Interaction event
     */


    return _this;
  }
  /**
   * @return {boolean}
   */


  createClass(InteractionLayer, [{
    key: 'isAble',
    value: function isAble() {
      return this.layer && this.layer.interactive;
    }
    /**
     * set layer
     * @param {Layer} layer layer
     */

  }, {
    key: 'setLayer',
    value: function setLayer(layer) {
      this.layer = layer;
    }
    /**
     * Hit tests a point against the display tree, returning the first interactive object that is hit.
     *
     * @param {Point} globalPoint - A point to hit test with, in global space.
     * @param {Object3D} [root] - The root display object to start from. If omitted, defaults
     * to the last rendered root of the associated renderer.
     * @return {Object3D} The hit display object, if any.
     */

  }, {
    key: 'hitTest',
    value: function hitTest(globalPoint, root) {
      if (!this.isAble()) return null; // clear the target for our hit test

      hitTestEvent$1.target = null; // assign the global point

      hitTestEvent$1.data.global = globalPoint; // ensure safety of the root

      if (!root) {
        root = this.layer.scene;
      } // run the hit test


      this.processInteractive(hitTestEvent$1, root, null, true); // return our found object - it'll be null if we didn't hit anything

      return hitTestEvent$1.target;
    }
    /**
     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
     * another DOM element to receive those events.
     *
     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.
     */

  }, {
    key: 'setTargetElement',
    value: function setTargetElement(element) {
      this.removeEvents();
      this.interactionDOMElement = element;
      this.addEvents();
    }
    /**
     * Registers all the DOM events
     *
     * @private
     */

  }, {
    key: 'addEvents',
    value: function addEvents() {
      if (!this.interactionDOMElement || this.eventsAdded) {
        return;
      }

      this.emit('addevents');
      this.interactionDOMElement.addEventListener('click', this.onClick, true);

      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style['touch-action'] = 'none';
      }
      /**
       * These events are added first, so that if pointer events are normalised, they are fired
       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd
       */


      if (this.supportsPointerEvents) {
        window.document.addEventListener('pointermove', this.onPointerMove, true);
        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel
        // we already handle those, so for the purposes of what we do in onPointerOut, we only
        // care about the pointerleave event

        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
        window.addEventListener('pointercancel', this.onPointerCancel, true);
        window.addEventListener('pointerup', this.onPointerUp, true);
      } else {
        window.document.addEventListener('mousemove', this.onPointerMove, true);
        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
        window.addEventListener('mouseup', this.onPointerUp, true);
      } // always look directly for touch events so that we can provide original data
      // In a future version we should change this to being just a fallback and rely solely on
      // PointerEvents whenever available


      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
      }

      this.eventsAdded = true;
    }
    /**
     * Removes all the DOM events that were previously registered
     *
     * @private
     */

  }, {
    key: 'removeEvents',
    value: function removeEvents() {
      if (!this.interactionDOMElement) {
        return;
      }

      this.emit('removeevents');
      this.interactionDOMElement.removeEventListener('click', this.onClick, true);

      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style['-ms-content-zooming'] = '';
        this.interactionDOMElement.style['-ms-touch-action'] = '';
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style['touch-action'] = '';
      }

      if (this.supportsPointerEvents) {
        window.document.removeEventListener('pointermove', this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
        window.removeEventListener('pointercancel', this.onPointerCancel, true);
        window.removeEventListener('pointerup', this.onPointerUp, true);
      } else {
        window.document.removeEventListener('mousemove', this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
        window.removeEventListener('mouseup', this.onPointerUp, true);
      }

      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
      }

      this.interactionDOMElement = null;
      this.eventsAdded = false;
    }
    /**
     * Updates the state of interactive objects.
     * Invoked by a throttled ticker.
     *
     * @param {number} deltaTime - time delta since last tick
     */

  }, {
    key: 'update',
    value: function update(_ref) {
      var snippet = _ref.snippet;
      if (!this.isAble()) return;
      this._deltaTime += snippet;

      if (this._deltaTime < this.interactionFrequency) {
        return;
      }

      this._deltaTime = 0;

      if (!this.interactionDOMElement) {
        return;
      } // if the user move the mouse this check has already been done using the mouse move!


      if (this.didMove) {
        this.didMove = false;
        return;
      }

      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
      // but there was a scenario of a display object moving under a static mouse cursor.
      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function

      for (var k in this.activeInteractionData) {
        // eslint-disable-next-line no-prototype-builtins
        if (this.activeInteractionData.hasOwnProperty(k)) {
          var interactionData = this.activeInteractionData[k];

          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);
          }
        }
      }

      this.setCursorMode(this.cursor); // TODO
    }
    /**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
     */

  }, {
    key: 'setCursorMode',
    value: function setCursorMode(mode) {
      mode = mode || 'default'; // if the mode didn't actually change, bail early

      if (this.currentCursorMode === mode) {
        return;
      }

      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it

      if (style) {
        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {
          case 'string':
            // string styles are handled as cursor CSS
            this.interactionDOMElement.style.cursor = style;
            break;

          case 'function':
            // functions are just called, and passed the cursor mode
            style(mode);
            break;

          case 'object':
            // if it is an object, assume that it is a dictionary of CSS styles,
            // apply it to the interactionDOMElement
            Object.assign(this.interactionDOMElement.style, style);
            break;

          default:
            break;
        }
      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry
        // for the mode, then assume that the dev wants it to be CSS for the cursor.
        this.interactionDOMElement.style.cursor = mode;
      }
    }
    /**
     * Dispatches an event on the display object that was interacted with
     *
     * @param {Object3D} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */

  }, {
    key: 'triggerEvent',
    value: function triggerEvent(displayObject, eventString, eventData) {
      if (!eventData.stopped) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);

        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    }
    /**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @private
     * @param {InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {Object3D} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @param {boolean} [interactive] - Whether the displayObject is interactive
     * @return {boolean} returns true if the displayObject hit the point
     */

  }, {
    key: 'processInteractive',
    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
      if (!displayObject || !displayObject.visible) {
        return false;
      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
      //
      // This function will now loop through all objects and then only hit test the objects it HAS
      // to, not all of them. MUCH faster..
      // An object will be hit test if the following is true:
      //
      // 1: It is interactive.
      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
      //
      // As another little optimisation once an interactive object has been hit we can carry on
      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
      // A final optimisation is that an object is not hit test directly if a child has already been hit.


      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;

      if (displayObject.interactiveChildren && displayObject.children) {
        var children = displayObject.children;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i]; // time to get recursive.. if this function will return if something is hit..

          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);

          if (childHit) {
            // its a good idea to check if a child has lost its parent.
            // this means it has been removed whilst looping so its best
            if (!child.parent) {
              continue;
            } // we no longer need to hit test any more objects in this container as we we
            // now know the parent has been hit


            interactiveParent = false; // If the child is interactive , that means that the object hit was actually
            // interactive and not just the child of an interactive object.
            // This means we no longer need to hit test anything else. We still need to run
            // through all objects, but we don't need to perform any hit tests.

            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }

              hit = true;
            }
          }
        }
      } // no point running this if the item is not interactive or does not have an interactive parent.


      if (interactive) {
        // if we are hit testing (as in we have no hit any objects yet)
        // We also don't need to worry about hit testing if once of the displayObjects children
        // has already been hit - but only if it was interactive, otherwise we need to keep
        // looking for an interactive child, just in case we hit one
        if (hitTest && !interactionEvent.target) {
          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {
            hit = true;
          }
        }

        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.data.target = interactionEvent.target = displayObject;
          }

          if (func) {
            func(interactionEvent, displayObject, !!hit);
          }
        }
      }

      return hit;
    }
    /**
     * Is called when the click is pressed down on the renderer element
     *
     * @private
     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down
     */

  }, {
    key: 'onClick',
    value: function onClick(originalEvent) {
      if (!this.isAble()) return;
      if (originalEvent.type !== 'click') return;
      var events = this.normalizeToPointerData(originalEvent);

      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }

      var interactionData = this.getInteractionDataForPointerId(events[0]);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);
      this.emit('click', interactionEvent);
    }
    /**
     * Processes the result of the click check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processClick',
    value: function processClick(interactionEvent, displayObject, hit) {
      if (hit) {
        this.triggerEvent(displayObject, 'click', interactionEvent);
      }
    }
    /**
     * Is called when the pointer button is pressed down on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
     */

  }, {
    key: 'onPointerDown',
    value: function onPointerDown(originalEvent) {
      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events

      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent);
      /**
       * No need to prevent default on natural pointer events, as there are no side effects
       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
       * so still need to be prevented.
       */
      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type

      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }

      var eventLen = events.length;

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);
        this.emit('pointerdown', interactionEvent);

        if (event.pointerType === 'touch') {
          this.emit('touchstart', interactionEvent);
        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
        }
      }
    }
    /**
     * Processes the result of the pointer down check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerDown',
    value: function processPointerDown(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;

      if (hit) {
        if (!displayObject.trackedPointers[id]) {
          displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }

        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);

        if (data.pointerType === 'touch') {
          displayObject.started = true;
          this.triggerEvent(displayObject, 'touchstart', interactionEvent);
        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
          var isRightButton = data.button === 2;

          if (isRightButton) {
            displayObject.trackedPointers[id].rightDown = true;
          } else {
            displayObject.trackedPointers[id].leftDown = true;
          }

          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
        }
      }
    }
    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
     * @param {boolean} cancelled - true if the pointer is cancelled
     * @param {Function} func - Function passed to {@link processInteractive}
     */

  }, {
    key: 'onPointerComplete',
    value: function onPointerComplete(originalEvent, cancelled, func) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside
      // in all cases (unless it was a pointercancel)

      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events

        this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);
        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);

        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);
        } else if (event.pointerType === 'touch') {
          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
        }
      }
    }
    /**
     * Is called when the pointer button is cancelled
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */

  }, {
    key: 'onPointerCancel',
    value: function onPointerCancel(event) {
      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events

      if (this.supportsTouchEvents && event.pointerType === 'touch') return;
      this.onPointerComplete(event, true, this.processPointerCancel);
    }
    /**
     * Processes the result of the pointer cancel check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     */

  }, {
    key: 'processPointerCancel',
    value: function processPointerCancel(interactionEvent, displayObject) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;

      if (displayObject.trackedPointers[id] !== undefined) {
        delete displayObject.trackedPointers[id];
        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);

        if (data.pointerType === 'touch') {
          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);
        }
      }
    }
    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */

  }, {
    key: 'onPointerUp',
    value: function onPointerUp(event) {
      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events

      if (this.supportsTouchEvents && event.pointerType === 'touch') return;
      this.onPointerComplete(event, false, this.processPointerUp);
    }
    /**
     * Processes the result of the pointer up check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerUp',
    value: function processPointerUp(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id];
      var isTouch = data.pointerType === 'touch';
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only

      if (isMouse) {
        var isRightButton = data.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== undefined && trackingData.flags & test;

        if (hit) {
          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);

          if (isDown) {
            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);
          }
        } else if (isDown) {
          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);
        } // update the down state of the tracking data


        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      } // Pointers and Touches, and Mouse


      if (isTouch && displayObject.started) {
        displayObject.started = false;
        this.triggerEvent(displayObject, 'touchend', interactionEvent);
      }

      if (hit) {
        this.triggerEvent(displayObject, 'pointerup', interactionEvent);

        if (trackingData) {
          this.triggerEvent(displayObject, 'pointertap', interactionEvent);

          if (isTouch) {
            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend
            // so we should ensure that we don't keep pretending that they are

            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);
        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);
      } // Only remove the tracking data if there is no over/down state still associated with it


      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
    /**
     * Is called when the pointer moves across the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
     */

  }, {
    key: 'onPointerMove',
    value: function onPointerMove(originalEvent) {
      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events

      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent);

      if (events[0].pointerType === 'mouse') {
        this.didMove = true;
        this.cursor = null;
      }

      var eventLen = events.length;

      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);
        this.emit('pointermove', interactionEvent);
        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);
      }

      if (events[0].pointerType === 'mouse') {
        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)
      }
    }
    /**
     * Processes the result of the pointer move check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerMove',
    value: function processPointerMove(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var isTouch = data.pointerType === 'touch';
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';

      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }

      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);

      if (!this.moveWhenInside || hit) {
        this.triggerEvent(displayObject, 'pointermove', interactionEvent);
        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);
      }
    }
    /**
     * Is called when the pointer is moved out of the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
     */

  }, {
    key: 'onPointerOut',
    value: function onPointerOut(originalEvent) {
      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events

      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1

      var event = events[0];

      if (event.pointerType === 'mouse') {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }

      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);
      this.emit('pointerout', interactionEvent);

      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
        this.emit('mouseout', interactionEvent);
      } else {
        // we can get touchleave events after touchend, so we want to make sure we don't
        // introduce memory leaks
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    }
    /**
     * Processes the result of the pointer over/out check and dispatches the event if need be
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {Object3D} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */

  }, {
    key: 'processPointerOverOut',
    value: function processPointerOverOut(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state

      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }

      if (trackingData === undefined) return;

      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.triggerEvent(displayObject, 'pointerover', interactionEvent);

          if (isMouse) {
            this.triggerEvent(displayObject, 'mouseover', interactionEvent);
          }
        } // only change the cursor if it has not already been changed (by something deeper in the
        // display tree)


        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.triggerEvent(displayObject, 'pointerout', this.eventData);

        if (isMouse) {
          this.triggerEvent(displayObject, 'mouseout', interactionEvent);
        } // if there is no mouse down information for the pointer, then it is safe to delete


        if (trackingData.none) {
          delete displayObject.trackedPointers[id];
        }
      }
    }
    /**
     * Is called when the pointer is moved into the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
     */

  }, {
    key: 'onPointerOver',
    value: function onPointerOver(originalEvent) {
      if (!this.isAble()) return;
      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1

      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;

      if (event.pointerType === 'mouse') {
        this.mouseOverRenderer = true;
      }

      this.emit('pointerover', interactionEvent);

      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
        this.emit('mouseover', interactionEvent);
      }
    }
    /**
     * Get InteractionData for a given pointerId. Store that data as well
     *
     * @private
     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
     * @return {InteractionData} - Interaction data for the given pointer identifier
     */

  }, {
    key: 'getInteractionDataForPointerId',
    value: function getInteractionDataForPointerId(event) {
      var pointerId = event.pointerId;
      var interactionData = void 0;

      if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === 'mouse') {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      } // copy properties from the event, so that we can make sure that touch/pointer specific
      // data is available


      interactionData._copyEvent(event);

      return interactionData;
    }
    /**
     * Return unused InteractionData to the pool, for a given pointerId
     *
     * @private
     * @param {number} pointerId - Identifier from a pointer event
     */

  }, {
    key: 'releaseInteractionDataForPointerId',
    value: function releaseInteractionDataForPointerId(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];

      if (interactionData) {
        delete this.activeInteractionData[pointerId];

        interactionData._reset();

        this.interactionDataPool.push(interactionData);
      }
    }
    /**
     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {Vector2} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */

  }, {
    key: 'mapPositionToPoint',
    value: function mapPositionToPoint(point, x, y) {
      var rect = void 0; // IE 11 fix

      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }

      point.x = (x - rect.left) / rect.width * 2 - 1;
      point.y = -((y - rect.top) / rect.height) * 2 + 1;
    }
    /**
     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
     *
     * @private
     * @param {InteractionEvent} interactionEvent - The event to be configured
     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
     * @param {InteractionData} interactionData - The InteractionData that will be paired
     *        with the InteractionEvent
     * @return {InteractionEvent} the interaction event that was passed in
     */

  }, {
    key: 'configureInteractionEventForDOMEvent',
    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove

      if (pointerEvent.pointerType === 'touch') {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }

      interactionData.originalEvent = pointerEvent;

      interactionEvent._reset();

      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);
      return interactionEvent;
    }
    /**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @private
     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */

  }, {
    key: 'normalizeToPointerData',
    value: function normalizeToPointerData(event) {
      var normalizedEvents = [];

      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;
          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;

          if (typeof touch.isPrimary === 'undefined') {
            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
          }

          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;
          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;
          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;
          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';
          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;
          touch.twist = 0;
          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven
          // support, and the fill ins are not quite the same
          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top
          // left is not 0,0 on the page

          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it

          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;
        if (typeof event.width === 'undefined') event.width = 1;
        if (typeof event.height === 'undefined') event.height = 1;
        if (typeof event.tiltX === 'undefined') event.tiltX = 0;
        if (typeof event.tiltY === 'undefined') event.tiltY = 0;
        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';
        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID$1;
        if (typeof event.pressure === 'undefined') event.pressure = 0.5;
        event.twist = 0;
        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it

        event.isNormalized = true;
        normalizedEvents.push(event);
      } else {
        normalizedEvents.push(event);
      }

      return normalizedEvents;
    }
    /**
     * Destroys the interaction manager
     *
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.removeEvents();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this._tempPoint = null;
    }
  }]);
  return InteractionLayer;
}(_three.EventDispatcher);

exports.InteractionLayer = InteractionLayer;

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }

  window.RAF = window.requestAnimationFrame;
  window.CAF = window.cancelAnimationFrame;
})();
/**
 * @extends EventDispatcher
 */


var Ticker = function (_EventDispatcher) {
  inherits(Ticker, _EventDispatcher);
  /**
   *
   */

  function Ticker() {
    classCallCheck(this, Ticker);

    var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));

    _this.timer = null;
    _this.started = false;
    /**
     * pre-time cache
     *
     * @member {Number}
     * @private
     */

    _this.pt = 0;
    /**
     * how long the time through, at this tick
     *
     * @member {Number}
     * @private
     */

    _this.snippet = 0;

    _this.start();

    return _this;
  }
  /**
   * start tick loop
   */


  createClass(Ticker, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      if (this.started) return;

      var loop = function loop() {
        _this2.timeline();

        _this2.emit('tick', {
          snippet: _this2.snippet
        });

        _this2.timer = RAF(loop);
      };

      loop();
    }
    /**
     * stop tick loop
     */

  }, {
    key: 'stop',
    value: function stop() {
      CAF(this.timer);
      this.started = false;
    }
    /**
     * get timeline snippet
     *
     * @private
     */

  }, {
    key: 'timeline',
    value: function timeline() {
      this.snippet = Date.now() - this.pt;

      if (this.pt === 0 || this.snippet > 200) {
        this.pt = Date.now();
        this.snippet = Date.now() - this.pt;
      }

      this.pt += this.snippet;
    }
  }]);
  return Ticker;
}(_three.EventDispatcher);
/**
 * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * reference to [pixi.js](http://www.pixijs.com/) impl
 *
 * @example
 * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';
 * import { Interaction } from 'three.interaction';
 * const renderer = new WebGLRenderer({ canvas: canvasElement });
 * const scene = new Scene();
 * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);
 *
 * const interaction = new Interaction(renderer, scene, camera);
 * // then you can bind every interaction event with any mesh which you had `add` into `scene` before
 * const cube = new Mesh(
 *   new BoxGeometry(1, 1, 1),
 *   new MeshBasicMaterial({ color: 0xffffff }),
 * );
 * scene.add(cube);
 * cube.on('touchstart', ev => {
 *   console.log(ev);
 * });
 *
 * cube.on('mousedown', ev => {
 *   console.log(ev);
 * });
 *
 * cube.on('pointerdown', ev => {
 *   console.log(ev);
 * });
 * // and so on ...
 *
 * // you can also listen on parent-node or any display-tree node,
 * // source event will bubble up along with display-tree.
 * // you can stop the bubble-up by invoke ev.stopPropagation function.
 * scene.on('touchstart', ev => {
 *   console.log(ev);
 * })
 *
 * @class
 * @extends InteractionManager
 */


var Interaction = function (_InteractionManager) {
  inherits(Interaction, _InteractionManager);
  /**
   * @param {WebGLRenderer} renderer - A reference to the current renderer
   * @param {Scene} scene - A reference to the current scene
   * @param {Camera} camera - A reference to the current camera
   * @param {Object} [options] - The options for the manager.
   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.
   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.
   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
   */

  function Interaction(renderer, scene, camera, options) {
    classCallCheck(this, Interaction);
    options = Object.assign({
      autoAttach: false
    }, options);
    /**
     * a ticker
     *
     * @private
     * @member {Ticker}
     */

    var _this = possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this, renderer, scene, camera, options));

    _this.ticker = new Ticker();
    /**
     * update for some over event
     *
     * @private
     */

    _this.update = _this.update.bind(_this);

    _this.on('addevents', function () {
      _this.ticker.on('tick', _this.update);
    });

    _this.on('removeevents', function () {
      _this.ticker.off('tick', _this.update);
    });

    _this.setTargetElement(_this.renderer.domElement);

    return _this;
  }

  return Interaction;
}(InteractionManager);

exports.Interaction = Interaction;
},{"three":"node_modules/three/build/three.module.js"}],"planet/icosphere.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = create;

function create(recursionLevel) {
  var points = [];
  var triangles = [];
  var point_index = -1;
  var middle_point_cache = {}; // add vertex to mesh, fix position to be on unit sphere, return index

  function addPoint(x, y, z) {
    var length = Math.sqrt(x * x + y * y + z * z);
    points.push({
      x: x / length,
      y: y / length,
      z: z / length
    });
    point_index++;
    return point_index;
  }

  function addTriangle(p1, p2, p3) {
    triangles.push({
      p1: p1,
      p2: p2,
      p3: p3
    });
  } // return index of point in the middle of p1 and p2


  function getMiddlePoint(p1, p2) {
    // first check if we have it already
    var cache_key = p1 < p2 ? "".concat(p1, "_").concat(p2) : "".concat(p2, "_").concat(p1);

    if (cache_key in middle_point_cache) {
      return middle_point_cache[cache_key];
    } // not in cache, calculate it


    var point1 = points[p1];
    var point2 = points[p2]; // addPoint makes sure point is on unit sphere

    var i = addPoint((point1.x + point2.x) * 0.5, (point1.y + point2.y) * 0.5, (point1.z + point2.z) * 0.5); // store it, return index

    middle_point_cache[cache_key] = i;
    return i;
  } // create 12 vertices of a icosahedron


  var t = (1.0 + Math.sqrt(5.0)) / 2.0;
  addPoint(-1, t, 0);
  addPoint(1, t, 0);
  addPoint(-1, -t, 0);
  addPoint(1, -t, 0);
  addPoint(0, -1, t);
  addPoint(0, 1, t);
  addPoint(0, -1, -t);
  addPoint(0, 1, -t);
  addPoint(t, 0, -1);
  addPoint(t, 0, 1);
  addPoint(-t, 0, -1);
  addPoint(-t, 0, 1); // 5 faces around point 0

  addTriangle(0, 11, 5);
  addTriangle(0, 5, 1);
  addTriangle(0, 1, 7);
  addTriangle(0, 7, 10);
  addTriangle(0, 10, 11); // 5 adjacent faces 

  addTriangle(1, 5, 9);
  addTriangle(5, 11, 4);
  addTriangle(11, 10, 2);
  addTriangle(10, 7, 6);
  addTriangle(7, 1, 8); // 5 faces around point 3

  addTriangle(3, 9, 4);
  addTriangle(3, 4, 2);
  addTriangle(3, 2, 6);
  addTriangle(3, 6, 8);
  addTriangle(3, 8, 9); // 5 adjacent faces 

  addTriangle(4, 9, 5);
  addTriangle(2, 4, 11);
  addTriangle(6, 2, 10);
  addTriangle(8, 6, 7);
  addTriangle(9, 8, 1); // refine triangles

  for (var i = 0; i < recursionLevel; i++) {
    var new_triangles = [];
    triangles.forEach(function (tri) {
      // replace triangle by 4 triangles
      var a = getMiddlePoint(tri.p1, tri.p2);
      var b = getMiddlePoint(tri.p2, tri.p3);
      var c = getMiddlePoint(tri.p3, tri.p1);
      new_triangles.push({
        p1: tri.p1,
        p2: a,
        p3: c
      });
      new_triangles.push({
        p1: tri.p2,
        p2: b,
        p3: a
      });
      new_triangles.push({
        p1: tri.p3,
        p2: c,
        p3: b
      });
      new_triangles.push({
        p1: a,
        p2: b,
        p3: c
      });
    });
    triangles = new_triangles;
  }

  return {
    points: points,
    triangles: triangles
  };
}
},{}],"data/data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = [6, 0, 157, 255, 131, 0, 182, 239, 57, 238, 159, 238, 246, 2, 86, 244, 127, 237, 138, 253, 181, 237, 254, 238, 230, 0, 90, 235, 201, 237, 48, 245, 190, 0, 124, 239, 201, 251, 132, 243, 239, 234, 216, 2, 124, 252, 27, 1, 30, 4, 10, 238, 92, 242, 154, 244, 30, 8, 94, 235, 187, 241, 191, 2, 193, 230, 54, 239, 198, 5, 215, 234, 206, 239, 241, 10, 59, 240, 197, 239, 183, 251, 208, 234, 150, 239, 192, 0, 74, 240, 89, 246, 115, 237, 255, 236, 10, 250, 171, 237, 91, 245, 75, 243, 60, 10, 91, 255, 116, 0, 122, 255, 185, 0, 202, 254, 122, 2, 132, 242, 212, 1, 249, 1, 10, 0, 191, 233, 118, 241, 15, 236, 20, 244, 72, 3, 8, 237, 125, 234, 120, 240, 158, 236, 168, 236, 113, 0, 98, 241, 7, 243, 224, 250, 202, 0, 243, 0, 243, 1, 11, 2, 41, 246, 149, 240, 195, 0, 249, 3, 191, 255, 50, 1, 213, 1, 149, 239, 96, 235, 122, 242, 106, 240, 212, 237, 193, 0, 82, 243, 195, 241, 229, 243, 180, 243, 15, 241, 41, 239, 179, 238, 6, 235, 183, 238, 163, 234, 253, 239, 14, 251, 127, 233, 3, 236, 212, 4, 9, 1, 118, 244, 132, 240, 6, 243, 58, 242, 144, 240, 180, 236, 229, 239, 242, 236, 93, 241, 81, 236, 229, 238, 6, 6, 21, 7, 183, 13, 12, 245, 84, 240, 166, 4, 58, 240, 83, 244, 65, 8, 108, 238, 55, 237, 77, 239, 138, 241, 220, 237, 39, 235, 8, 238, 51, 241, 207, 250, 127, 4, 167, 233, 37, 2, 140, 255, 115, 241, 208, 255, 255, 230, 155, 236, 162, 245, 45, 3, 163, 4, 151, 1, 43, 234, 85, 239, 255, 2, 132, 235, 228, 237, 247, 241, 49, 239, 149, 240, 15, 237, 215, 255, 81, 0, 171, 18, 65, 0, 110, 2, 171, 0, 80, 236, 157, 0, 74, 244, 204, 242, 234, 255, 196, 242, 0, 0, 156, 237, 156, 0, 13, 235, 126, 240, 143, 235, 58, 233, 165, 234, 87, 233, 13, 2, 193, 241, 79, 2, 170, 243, 70, 239, 2, 240, 49, 236, 209, 234, 141, 235, 23, 241, 117, 247, 164, 236, 77, 1, 150, 1, 57, 245, 123, 5, 14, 255, 60, 255, 235, 4, 228, 244, 50, 0, 235, 255, 68, 1, 231, 1, 170, 255, 76, 251, 29, 2, 37, 0, 76, 0, 111, 255, 220, 2, 139, 251, 148, 0, 82, 0, 214, 0, 238, 254, 253, 254, 245, 241, 223, 0, 176, 1, 62, 241, 35, 254, 40, 0, 108, 0, 207, 3, 153, 1, 180, 1, 150, 3, 26, 2, 217, 1, 231, 255, 171, 246, 59, 235, 13, 234, 68, 234, 207, 255, 204, 236, 167, 236, 40, 231, 71, 235, 93, 255, 106, 255, 138, 2, 204, 255, 162, 2, 225, 0, 60, 241, 88, 6, 138, 10, 72, 9, 82, 6, 30, 236, 230, 233, 26, 235, 42, 233, 30, 237, 27, 234, 60, 236, 56, 240, 141, 237, 173, 238, 108, 240, 111, 239, 216, 240, 147, 236, 97, 235, 40, 236, 1, 239, 109, 239, 22, 237, 207, 1, 97, 2, 75, 1, 26, 1, 8, 254, 224, 239, 221, 240, 144, 241, 48, 244, 134, 243, 185, 240, 31, 5, 67, 0, 77, 0, 251, 248, 144, 241, 83, 250, 11, 0, 107, 248, 152, 242, 98, 4, 41, 244, 123, 1, 27, 1, 55, 0, 143, 0, 174, 17, 127, 0, 64, 1, 184, 1, 213, 254, 58, 1, 127, 0, 28, 2, 231, 255, 218, 255, 78, 242, 43, 254, 248, 235, 108, 3, 139, 0, 49, 248, 33, 5, 98, 3, 127, 4, 171, 8, 43, 2, 23, 3, 110, 1, 67, 1, 237, 238, 0, 0, 151, 0, 133, 1, 69, 0, 200, 0, 219, 255, 79, 236, 100, 0, 202, 250, 211, 237, 83, 237, 50, 236, 80, 239, 242, 239, 31, 240, 102, 239, 76, 236, 181, 234, 254, 242, 194, 234, 222, 238, 181, 234, 171, 241, 172, 0, 90, 0, 71, 239, 189, 6, 140, 14, 140, 18, 168, 237, 54, 239, 165, 242, 27, 241, 46, 242, 61, 243, 208, 241, 175, 240, 110, 238, 117, 240, 190, 237, 197, 240, 155, 239, 104, 0, 235, 241, 167, 241, 204, 241, 145, 238, 39, 241, 212, 244, 36, 247, 157, 238, 124, 235, 169, 238, 80, 239, 69, 238, 198, 236, 57, 234, 87, 236, 160, 234, 173, 234, 54, 232, 210, 234, 175, 233, 23, 235, 179, 233, 169, 246, 217, 235, 241, 234, 117, 237, 17, 235, 67, 237, 49, 238, 9, 238, 212, 235, 221, 235, 206, 232, 30, 234, 83, 255, 72, 234, 55, 235, 111, 237, 204, 233, 129, 7, 106, 3, 15, 0, 196, 4, 204, 5, 131, 3, 45, 0, 189, 228, 212, 235, 200, 244, 244, 236, 232, 232, 202, 237, 102, 0, 225, 234, 8, 0, 225, 244, 185, 255, 223, 249, 203, 239, 127, 241, 143, 248, 235, 236, 165, 238, 175, 239, 38, 235, 120, 239, 71, 238, 122, 237, 202, 237, 239, 241, 11, 244, 238, 3, 207, 1, 88, 241, 254, 238, 246, 235, 170, 236, 35, 238, 50, 236, 161, 237, 172, 236, 242, 238, 230, 3, 96, 5, 37, 1, 61, 238, 215, 237, 246, 246, 95, 255, 137, 254, 14, 236, 58, 253, 74, 14, 242, 9, 212, 12, 179, 242, 120, 240, 10, 238, 183, 245, 130, 240, 9, 241, 24, 235, 67, 238, 249, 254, 215, 237, 128, 3, 222, 253, 168, 6, 199, 244, 14, 241, 223, 238, 247, 242, 135, 236, 240, 10, 119, 4, 131, 239, 194, 7, 159, 12, 151, 239, 143, 2, 210, 240, 13, 237, 183, 239, 131, 241, 207, 237, 113, 243, 17, 4, 113, 0, 138, 255, 41, 251, 211, 234, 213, 238, 243, 253, 192, 237, 43, 236, 194, 235, 88, 238, 208, 254, 205, 242, 163, 243, 112, 242, 64, 241, 57, 243, 212, 237, 231, 236, 41, 239, 91, 236, 234, 245, 240, 251, 106, 1, 92, 241, 153, 244, 131, 237, 38, 240, 34, 241, 171, 255, 112, 237, 234, 1, 224, 0, 78, 0, 235, 255, 244, 0, 62, 1, 251, 235, 157, 2, 67, 241, 188, 243, 175, 242, 231, 239, 140, 241, 203, 241, 222, 0, 13, 4, 59, 236, 18, 232, 113, 255, 66, 234, 204, 242, 216, 241, 40, 241, 176, 239, 177, 237, 5, 238, 65, 235, 170, 235, 87, 235, 226, 241, 98, 238, 51, 245, 61, 4, 84, 4, 224, 236, 112, 239, 79, 241, 146, 1, 162, 5, 207, 3, 17, 6, 86, 2, 34, 0, 14, 2, 49, 1, 164, 3, 82, 2, 45, 2, 146, 1, 253, 255, 15, 235, 66, 252, 237, 255, 120, 0, 134, 243, 228, 236, 60, 239, 142, 240, 219, 235, 75, 1, 47, 0, 130, 0, 114, 3, 205, 255, 247, 235, 170, 240, 129, 252, 150, 235, 10, 236, 95, 237, 122, 235, 197, 238, 223, 241, 168, 240, 239, 242, 18, 242, 244, 237, 124, 240, 130, 239, 63, 239, 244, 241, 168, 242, 16, 237, 36, 241, 197, 240, 57, 248, 148, 4, 116, 2, 245, 243, 167, 246, 237, 244, 204, 239, 113, 248, 118, 248, 82, 247, 114, 234, 148, 232, 156, 236, 151, 234, 176, 242, 139, 250, 190, 238, 11, 242, 60, 238, 52, 241, 182, 255, 184, 247, 3, 2, 158, 248, 130, 1, 200, 0, 199, 255, 233, 246, 13, 5, 232, 18, 184, 4, 144, 17, 112, 18, 186, 245, 253, 0, 165, 2, 71, 0, 211, 255, 80, 255, 59, 2, 251, 0, 94, 1, 129, 255, 128, 1, 190, 1, 117, 236, 249, 236, 3, 235, 111, 255, 80, 239, 232, 235, 15, 1, 199, 255, 9, 2, 122, 245, 77, 241, 69, 241, 82, 255, 61, 243, 135, 242, 184, 255, 55, 251, 138, 0, 61, 1, 135, 254, 38, 2, 122, 1, 237, 255, 89, 0, 106, 237, 176, 245, 234, 239, 119, 255, 229, 242, 12, 246, 206, 232, 238, 234, 23, 234, 196, 240, 58, 240, 132, 238, 91, 240, 224, 238, 25, 241, 201, 234, 135, 233, 163, 236, 51, 231, 209, 232, 51, 255, 127, 234, 54, 233, 74, 235, 138, 235, 251, 237, 196, 234, 206, 0, 166, 0, 198, 2, 50, 238, 87, 238, 113, 255, 97, 0, 189, 243, 57, 246, 114, 241, 104, 246, 14, 241, 163, 249, 170, 243, 168, 246, 85, 238, 23, 241, 115, 237, 38, 237, 57, 234, 247, 235, 254, 237, 13, 236, 86, 250, 253, 238, 188, 236, 52, 240, 45, 236, 140, 238, 66, 240, 243, 237, 119, 234, 35, 234, 55, 235, 40, 235, 122, 233, 51, 244, 138, 237, 91, 238, 39, 241, 57, 238, 89, 241, 97, 237, 194, 240, 216, 238, 61, 237, 10, 240, 91, 235, 106, 255, 101, 255, 59, 255, 36, 0, 83, 255, 166, 255, 216, 0, 141, 249, 158, 244, 166, 10, 180, 255, 189, 254, 249, 8, 56, 250, 66, 247, 125, 255, 140, 245, 243, 253, 11, 255, 85, 255, 248, 8, 66, 9, 65, 11, 202, 250, 102, 254, 66, 247, 63, 3, 73, 255, 54, 8, 116, 252, 228, 0, 159, 4, 16, 237, 69, 0, 105, 0, 142, 0, 210, 255, 232, 255, 0, 254, 210, 0, 51, 1, 67, 3, 68, 246, 18, 246, 158, 240, 28, 246, 113, 255, 144, 249, 17, 0, 172, 0, 9, 0, 141, 0, 14, 1, 130, 0, 91, 0, 0, 0, 6, 0, 89, 1, 53, 0, 76, 0, 96, 0, 111, 241, 27, 255, 144, 241, 160, 254, 15, 255, 211, 254, 190, 255, 62, 254, 221, 255, 154, 0, 176, 0, 36, 0, 116, 0, 127, 0, 223, 0, 212, 0, 212, 255, 147, 255, 128, 255, 148, 255, 83, 0, 12, 248, 87, 255, 134, 248, 119, 0, 71, 253, 37, 0, 160, 3, 176, 255, 19, 2, 112, 255, 38, 243, 28, 255, 81, 255, 144, 255, 210, 254, 238, 243, 13, 244, 133, 247, 199, 0, 4, 1, 157, 255, 75, 0, 255, 0, 122, 1, 203, 0, 210, 246, 14, 243, 172, 243, 117, 242, 18, 241, 44, 254, 124, 255, 3, 242, 169, 6, 193, 250, 51, 3, 82, 6, 237, 6, 2, 4, 202, 3, 243, 255, 13, 1, 47, 255, 152, 1, 84, 1, 223, 1, 174, 0, 59, 1, 180, 1, 117, 2, 100, 0, 134, 255, 189, 4, 81, 255, 232, 2, 54, 6, 31, 2, 81, 2, 171, 0, 211, 0, 39, 241, 228, 251, 142, 0, 181, 253, 220, 255, 142, 249, 53, 0, 19, 1, 189, 0, 130, 0, 17, 243, 145, 234, 36, 243, 200, 232, 66, 233, 173, 233, 16, 248, 65, 233, 115, 234, 217, 255, 152, 233, 95, 238, 99, 241, 122, 250, 160, 255, 211, 235, 173, 236, 164, 234, 176, 253, 8, 241, 224, 255, 129, 234, 102, 236, 186, 233, 232, 248, 206, 248, 69, 243, 3, 235, 225, 250, 0, 235, 37, 247, 217, 255, 134, 254, 240, 253, 6, 255, 145, 255, 59, 0, 118, 0, 160, 1, 13, 0, 31, 1, 254, 0, 40, 0, 8, 0, 181, 255, 223, 255, 40, 2, 216, 255, 33, 1, 179, 0, 157, 2, 204, 1, 208, 1, 42, 2, 72, 3, 34, 241, 177, 246, 26, 255, 160, 247, 186, 243, 32, 5, 132, 5, 161, 9, 224, 7, 123, 1, 85, 5, 164, 9, 215, 8, 0, 6, 233, 6, 121, 5, 196, 8, 88, 3, 223, 4, 148, 235, 123, 233, 114, 234, 126, 233, 5, 238, 236, 232, 5, 234, 44, 234, 14, 235, 167, 235, 76, 234, 247, 234, 29, 234, 6, 238, 122, 235, 170, 234, 188, 235, 169, 237, 100, 234, 102, 235, 130, 237, 176, 235, 167, 235, 162, 233, 39, 235, 116, 236, 174, 238, 51, 239, 230, 237, 123, 239, 109, 238, 116, 239, 223, 237, 31, 238, 99, 237, 186, 248, 23, 241, 50, 0, 184, 238, 133, 239, 41, 238, 114, 241, 62, 240, 179, 240, 139, 234, 82, 234, 86, 234, 105, 237, 130, 236, 198, 236, 174, 237, 179, 235, 236, 236, 213, 238, 40, 237, 29, 237, 145, 238, 234, 234, 235, 238, 33, 240, 137, 241, 247, 235, 112, 239, 11, 237, 228, 236, 208, 235, 226, 252, 3, 239, 138, 241, 242, 239, 25, 238, 8, 236, 234, 239, 246, 235, 103, 1, 92, 1, 100, 1, 79, 0, 205, 0, 192, 5, 15, 5, 116, 0, 125, 1, 85, 0, 227, 3, 221, 2, 223, 255, 252, 240, 85, 1, 109, 0, 90, 0, 185, 0, 22, 1, 34, 1, 154, 0, 142, 0, 40, 240, 4, 240, 254, 240, 125, 240, 47, 241, 221, 240, 7, 240, 13, 244, 196, 242, 135, 243, 25, 243, 73, 242, 191, 239, 185, 243, 201, 242, 225, 241, 157, 246, 104, 5, 198, 240, 82, 247, 42, 1, 18, 243, 7, 243, 231, 240, 10, 243, 160, 241, 123, 1, 48, 0, 162, 252, 98, 0, 155, 0, 88, 0, 195, 0, 78, 235, 20, 235, 18, 243, 244, 252, 25, 236, 53, 0, 110, 237, 234, 244, 57, 244, 136, 249, 73, 8, 128, 240, 92, 13, 188, 247, 16, 0, 34, 242, 243, 255, 181, 251, 193, 10, 219, 4, 41, 9, 216, 6, 6, 0, 197, 253, 150, 242, 114, 1, 116, 249, 85, 241, 100, 254, 78, 251, 122, 244, 21, 0, 101, 253, 112, 240, 115, 255, 1, 0, 1, 244, 126, 0, 233, 0, 129, 0, 94, 0, 168, 3, 126, 0, 12, 3, 231, 0, 231, 0, 91, 0, 15, 0, 227, 255, 81, 0, 99, 1, 27, 7, 58, 1, 89, 10, 13, 1, 99, 1, 98, 13, 119, 0, 228, 1, 29, 0, 217, 0, 98, 0, 41, 2, 232, 0, 59, 0, 244, 0, 18, 1, 176, 1, 97, 0, 62, 242, 179, 0, 169, 1, 206, 1, 46, 245, 219, 255, 253, 255, 213, 1, 10, 1, 234, 0, 239, 0, 84, 0, 182, 251, 56, 3, 152, 5, 246, 0, 174, 0, 198, 249, 98, 254, 167, 242, 189, 240, 188, 239, 62, 236, 124, 243, 64, 240, 253, 238, 137, 0, 74, 236, 193, 4, 8, 4, 9, 0, 130, 0, 125, 0, 191, 252, 234, 255, 162, 242, 84, 243, 144, 243, 161, 1, 186, 254, 116, 2, 85, 254, 45, 0, 152, 0, 126, 3, 193, 4, 54, 1, 60, 243, 18, 1, 28, 253, 109, 0, 81, 5, 143, 247, 23, 1, 215, 1, 20, 252, 159, 1, 219, 3, 231, 2, 94, 2, 27, 5, 0, 0, 42, 4, 51, 5, 58, 0, 1, 1, 24, 0, 75, 6, 168, 1, 40, 1, 42, 1, 116, 1, 189, 1, 216, 0, 33, 1, 91, 237, 207, 241, 9, 0, 56, 242, 225, 237, 63, 242, 47, 0, 156, 238, 132, 0, 6, 237, 62, 1, 87, 1, 51, 1, 20, 0, 203, 1, 243, 2, 170, 0, 73, 0, 230, 0, 9, 0, 83, 0, 88, 0, 37, 0, 167, 0, 199, 255, 136, 240, 219, 236, 33, 240, 238, 239, 185, 240, 39, 0, 156, 238, 235, 2, 250, 1, 76, 1, 158, 235, 52, 233, 52, 237, 127, 240, 137, 243, 102, 240, 11, 240, 227, 255, 182, 238, 176, 238, 141, 236, 90, 239, 32, 238, 156, 235, 159, 236, 53, 234, 95, 243, 136, 238, 22, 243, 204, 236, 215, 236, 97, 241, 75, 243, 155, 239, 57, 242, 94, 234, 61, 239, 121, 237, 28, 236, 51, 234, 153, 234, 203, 238, 23, 240, 50, 236, 94, 237, 229, 238, 171, 240, 37, 241, 100, 243, 206, 245, 65, 233, 216, 240, 119, 240, 101, 236, 225, 239, 127, 234, 54, 237, 118, 235, 238, 233, 167, 236, 92, 236, 179, 236, 251, 237, 119, 243, 150, 241, 95, 241, 89, 238, 135, 236, 42, 0, 38, 0, 84, 0, 64, 0, 185, 0, 87, 0, 168, 0, 147, 243, 108, 244, 215, 246, 92, 237, 80, 238, 30, 3, 161, 0, 222, 12, 128, 252, 219, 238, 77, 2, 6, 18, 234, 9, 148, 239, 111, 237, 39, 241, 220, 0, 213, 4, 138, 1, 145, 239, 240, 238, 202, 242, 135, 240, 188, 240, 217, 239, 84, 241, 57, 243, 144, 241, 2, 245, 10, 240, 91, 240, 66, 240, 245, 242, 104, 242, 247, 243, 97, 241, 92, 241, 32, 244, 57, 242, 87, 240, 172, 240, 137, 238, 173, 243, 95, 240, 130, 243, 229, 236, 10, 237, 85, 234, 75, 240, 186, 238, 91, 240, 86, 240, 208, 237, 248, 239, 166, 239, 137, 240, 135, 2, 244, 239, 64, 242, 54, 241, 139, 253, 84, 239, 52, 242, 207, 245, 6, 243, 214, 242, 100, 237, 142, 240, 43, 241, 255, 240, 88, 241, 4, 243, 99, 242, 35, 241, 29, 240, 49, 240, 46, 241, 189, 240, 25, 239, 197, 237, 85, 246, 116, 241, 66, 242, 112, 240, 103, 239, 54, 241, 30, 239, 119, 238, 205, 241, 60, 243, 218, 239, 100, 241, 128, 239, 94, 238, 204, 237, 81, 238, 166, 238, 196, 237, 57, 238, 35, 238, 228, 234, 125, 235, 92, 238, 12, 236, 100, 236, 241, 235, 37, 237, 172, 250, 85, 238, 86, 237, 52, 239, 0, 239, 224, 240, 106, 237, 111, 237, 40, 238, 71, 239, 188, 238, 151, 238, 81, 235, 168, 235, 197, 241, 229, 234, 218, 240, 165, 238, 184, 236, 31, 235, 254, 235, 157, 233, 177, 234, 116, 233, 103, 235, 122, 233, 205, 232, 78, 235, 16, 238, 121, 234, 255, 237, 22, 238, 139, 234, 37, 234, 190, 234, 116, 235, 41, 244, 33, 236, 138, 234, 146, 234, 47, 250, 142, 233, 188, 233, 54, 234, 152, 243, 203, 251, 70, 244, 143, 238, 165, 237, 176, 238, 81, 234, 115, 236, 217, 241, 149, 237, 103, 237, 127, 237, 137, 233, 166, 234, 137, 235, 254, 248, 97, 241, 127, 247, 150, 235, 153, 239, 112, 235, 155, 236, 10, 236, 113, 230, 27, 235, 7, 247, 128, 235, 219, 235, 172, 237, 160, 233, 75, 243, 159, 234, 171, 234, 157, 236, 38, 236, 38, 238, 63, 239, 80, 234, 231, 232, 56, 237, 116, 235, 88, 244, 121, 235, 44, 235, 94, 242, 135, 236, 9, 233, 65, 232, 183, 232, 254, 251, 211, 246, 160, 234, 191, 235, 223, 234, 165, 236, 76, 234, 149, 235, 11, 235, 143, 233, 230, 232, 206, 232, 254, 244, 174, 231, 85, 233, 129, 232, 75, 238, 38, 235, 228, 238, 161, 2, 195, 1, 164, 4, 43, 2, 123, 7, 189, 1, 234, 5, 62, 0, 167, 4, 152, 4, 152, 1, 150, 3, 239, 255, 21, 5, 106, 7, 108, 4, 93, 1, 0, 0, 48, 2, 95, 1, 248, 0, 2, 1, 162, 0, 17, 4, 245, 2, 111, 2, 12, 243, 222, 237, 142, 237, 45, 233, 115, 232, 236, 235, 202, 249, 38, 1, 176, 0, 5, 237, 37, 237, 176, 240, 3, 233, 56, 243, 102, 238, 213, 236, 67, 235, 131, 233, 2, 1, 128, 1, 16, 0, 11, 247, 85, 246, 97, 242, 48, 251, 5, 243, 54, 233, 67, 234, 87, 232, 214, 244, 129, 1, 137, 247, 162, 254, 213, 4, 69, 248, 15, 0, 100, 254, 197, 255, 184, 255, 252, 2, 233, 232, 10, 235, 230, 232, 13, 239, 94, 245, 158, 254, 241, 251, 115, 5, 138, 237, 115, 243, 197, 250, 103, 246, 199, 252, 232, 242, 71, 238, 15, 246, 106, 241, 38, 238, 157, 238, 191, 238, 80, 237, 67, 236, 253, 235, 39, 241, 63, 240, 231, 241, 232, 236, 46, 252, 159, 239, 18, 239, 86, 248, 71, 235, 75, 254, 97, 238, 186, 240, 214, 254, 118, 240, 63, 237, 183, 239, 102, 255, 141, 244, 83, 240, 168, 247, 85, 242, 99, 255, 119, 240, 119, 240, 199, 255, 249, 246, 55, 3, 182, 255, 184, 254, 244, 0, 240, 246, 66, 243, 129, 242, 177, 243, 50, 237, 0, 238, 53, 244, 246, 240, 236, 243, 87, 235, 239, 236, 33, 238, 204, 244, 91, 237, 24, 238, 193, 236, 20, 236, 119, 235, 157, 237, 83, 236, 110, 237, 107, 242, 0, 239, 23, 255, 58, 241, 46, 236, 194, 242, 113, 244, 152, 236, 60, 239, 131, 239, 141, 237, 202, 236, 181, 4, 19, 5, 186, 0, 225, 2, 7, 5, 150, 4, 186, 243, 28, 6, 200, 251, 220, 237, 54, 248, 40, 4, 141, 235, 203, 237, 24, 237, 183, 239, 48, 240, 229, 248, 98, 238, 169, 247, 254, 238, 123, 246, 184, 242, 139, 243, 238, 247, 15, 242, 182, 235, 11, 246, 233, 237, 19, 245, 60, 243, 111, 240, 5, 240, 184, 241, 110, 10, 43, 253, 121, 8, 208, 234, 74, 235, 13, 5, 98, 237, 220, 246, 69, 236, 197, 236, 125, 12, 176, 14, 104, 11, 102, 9, 44, 14, 115, 14, 116, 14, 13, 14, 236, 12, 0, 0, 30, 11, 127, 5, 15, 240, 202, 235, 54, 241, 234, 239, 208, 240, 158, 237, 184, 239, 196, 236, 46, 239, 243, 241, 83, 244, 170, 240, 69, 239, 164, 243, 104, 241, 213, 247, 248, 242, 132, 238, 159, 255, 110, 242, 64, 239, 51, 241, 148, 247, 81, 240, 104, 246, 7, 239, 19, 237, 85, 238, 25, 236, 155, 253, 222, 239, 84, 244, 241, 242, 2, 241, 221, 254, 38, 8, 126, 0, 46, 7, 203, 253, 103, 1, 104, 254, 153, 6, 52, 1, 198, 2, 138, 242, 233, 244, 173, 242, 8, 254, 235, 253, 23, 242, 15, 238, 115, 237, 111, 240, 127, 5, 9, 246, 171, 252, 73, 235, 73, 235, 55, 236, 254, 236, 206, 246, 113, 241, 172, 237, 120, 236, 143, 236, 148, 235, 137, 8, 209, 12, 217, 11, 100, 7, 58, 0, 101, 240, 115, 253, 54, 0, 177, 246, 148, 238, 59, 11, 167, 3, 30, 239, 59, 245, 249, 245, 214, 10, 93, 11, 24, 11, 1, 11, 181, 9, 45, 13, 38, 13, 36, 243, 231, 238, 146, 243, 242, 239, 242, 238, 172, 237, 100, 254, 57, 244, 103, 9, 159, 10, 27, 11, 43, 2, 200, 236, 72, 236, 244, 235, 69, 236, 222, 235, 206, 237, 112, 250, 192, 244, 79, 241, 48, 243, 198, 238, 144, 238, 139, 240, 141, 240, 130, 238, 31, 236, 94, 3, 195, 1, 116, 0, 211, 6, 70, 0, 181, 5, 192, 250, 211, 238, 129, 240, 97, 250, 2, 247, 34, 242, 77, 234, 191, 253, 141, 246, 227, 253, 209, 239, 244, 243, 168, 241, 107, 240, 158, 240, 83, 238, 245, 235, 26, 252, 214, 235, 231, 238, 97, 243, 114, 253, 229, 237, 123, 238, 238, 240, 65, 238, 107, 235, 41, 235, 0, 235, 26, 237, 74, 235, 1, 251, 132, 236, 88, 236, 60, 0, 24, 241, 189, 253, 28, 0, 200, 11, 85, 243, 181, 241, 88, 244, 50, 241, 42, 241, 178, 243, 164, 254, 83, 244, 110, 248, 169, 239, 52, 240, 107, 240, 57, 246, 64, 242, 55, 239, 145, 238, 163, 240, 225, 243, 90, 242, 148, 243, 19, 244, 177, 241, 124, 239, 193, 242, 242, 238, 204, 238, 199, 237, 159, 239, 221, 235, 166, 251, 188, 241, 230, 238, 17, 240, 26, 236, 120, 237, 250, 238, 229, 240, 102, 240, 195, 241, 167, 239, 2, 249, 8, 247, 154, 252, 104, 250, 44, 247, 201, 243, 56, 1, 17, 0, 92, 254, 136, 246, 129, 3, 225, 0, 79, 249, 109, 237, 166, 243, 120, 238, 180, 239, 208, 236, 249, 236, 5, 0, 215, 237, 208, 237, 152, 249, 174, 237, 17, 236, 168, 255, 215, 242, 183, 242, 183, 247, 23, 244, 209, 230, 99, 253, 74, 1, 187, 255, 49, 1, 185, 1, 45, 255, 110, 1, 247, 1, 216, 1, 220, 249, 221, 0, 37, 255, 121, 1, 0, 0, 199, 2, 84, 1, 238, 255, 193, 255, 234, 1, 227, 0, 192, 1, 106, 0, 101, 1, 253, 255, 6, 239, 173, 0, 199, 236, 177, 238, 18, 236, 209, 0, 190, 0, 36, 0, 148, 0, 74, 0, 88, 1, 10, 235, 113, 236, 184, 0, 196, 0, 34, 1, 207, 255, 27, 234, 89, 240, 48, 244, 84, 245, 63, 240, 123, 241, 0, 236, 122, 236, 34, 239, 142, 237, 83, 251, 68, 238, 202, 239, 153, 242, 87, 239, 102, 245, 166, 248, 230, 238, 118, 245, 190, 240, 36, 243, 195, 241, 90, 245, 120, 255, 226, 255, 230, 255, 238, 255, 27, 0, 237, 252, 43, 236, 245, 236, 28, 236, 133, 238, 137, 237, 30, 235, 195, 238, 20, 0, 153, 245, 51, 0, 214, 236, 152, 233, 99, 239, 92, 239, 83, 233, 100, 234, 105, 232, 79, 248, 145, 238, 168, 237, 198, 240, 37, 238, 106, 241, 243, 240, 208, 240, 171, 240, 96, 240, 59, 244, 183, 242, 16, 236, 110, 238, 148, 236, 145, 243, 91, 244, 80, 238, 2, 237, 225, 236, 222, 236, 158, 236, 111, 237, 85, 236, 23, 236, 179, 235, 60, 243, 21, 236, 197, 241, 149, 236, 39, 234, 21, 234, 33, 239, 163, 240, 54, 236, 201, 237, 91, 236, 17, 234, 127, 237, 75, 239, 229, 243, 203, 238, 85, 238, 162, 235, 167, 236, 124, 249, 230, 235, 55, 243, 47, 248, 154, 237, 38, 237, 172, 234, 240, 3, 177, 3, 121, 6, 208, 4, 73, 5, 167, 4, 152, 5, 154, 235, 208, 239, 95, 234, 40, 234, 69, 252, 181, 237, 6, 247, 30, 255, 119, 253, 49, 237, 18, 236, 202, 0, 129, 239, 173, 236, 241, 237, 168, 1, 148, 3, 11, 6, 254, 5, 35, 2, 208, 10, 109, 2, 13, 5, 32, 3, 94, 243, 94, 1, 71, 4, 22, 4, 111, 6, 204, 0, 116, 1, 6, 246, 210, 1, 118, 1, 93, 2, 175, 4, 56, 3, 55, 240, 223, 255, 55, 1, 250, 0, 164, 3, 47, 1, 40, 1, 2, 3, 160, 2, 188, 4, 44, 2, 192, 1, 130, 1, 41, 1, 225, 1, 116, 1, 155, 1, 219, 4, 113, 2, 191, 2, 44, 4, 131, 3, 190, 1, 219, 1, 29, 3, 12, 2, 17, 3, 165, 245, 154, 1, 159, 0, 96, 2, 208, 2, 197, 1, 97, 1, 61, 1, 94, 238, 145, 246, 220, 238, 84, 248, 178, 5, 77, 241, 98, 248, 154, 233, 87, 246, 38, 233, 18, 240, 22, 239, 157, 1, 156, 2, 163, 5, 74, 3, 164, 255, 74, 0, 63, 253, 240, 254, 77, 255, 88, 0, 20, 241, 136, 242, 68, 243, 183, 241, 35, 243, 168, 237, 82, 234, 188, 239, 163, 236, 102, 244, 50, 237, 27, 238, 41, 237, 173, 235, 30, 244, 31, 239, 207, 237, 37, 238, 71, 241, 146, 240, 41, 241, 72, 243, 143, 0, 52, 2, 38, 1, 70, 1, 180, 0, 154, 0, 219, 0, 66, 1, 77, 0, 216, 1, 203, 0, 26, 1, 32, 0, 68, 241, 221, 3, 37, 2, 216, 255, 249, 2, 98, 2, 55, 2, 151, 2, 5, 1, 254, 232, 7, 236, 186, 235, 156, 236, 203, 234, 241, 239, 199, 244, 145, 244, 213, 240, 0, 239, 7, 0, 133, 238, 247, 255, 168, 0, 178, 0, 15, 237, 137, 240, 22, 236, 75, 233, 132, 236, 153, 236, 116, 234, 210, 234, 84, 238, 122, 237, 30, 235, 241, 235, 106, 234, 204, 235, 39, 236, 98, 237, 17, 237, 28, 236, 80, 236, 77, 240, 0, 236, 236, 234, 19, 236, 60, 235, 117, 235, 228, 238, 8, 241, 221, 238, 193, 238, 174, 241, 114, 245, 117, 243, 128, 240, 104, 242, 92, 240, 53, 245, 252, 243, 123, 242, 155, 242, 86, 244, 241, 241, 9, 238, 91, 239, 116, 239, 241, 244, 25, 242, 200, 244, 49, 238, 149, 239, 49, 238, 141, 237, 152, 241, 118, 238, 139, 244, 8, 241, 7, 242, 89, 240, 40, 239, 189, 238, 67, 245, 45, 243, 195, 241, 114, 242, 40, 241, 255, 241, 249, 240, 38, 240, 47, 240, 78, 241, 239, 236, 156, 236, 92, 236, 142, 235, 211, 234, 189, 242, 234, 239, 240, 240, 134, 240, 30, 238, 84, 237, 226, 235, 62, 239, 209, 238, 188, 239, 247, 236, 167, 238, 127, 237, 184, 253, 116, 255, 203, 255, 80, 240, 222, 237, 19, 239, 150, 249, 40, 252, 146, 2, 143, 248, 255, 255, 233, 255, 204, 243, 147, 237, 57, 240, 30, 242, 105, 240, 89, 248, 227, 238, 72, 0, 13, 243, 6, 238, 173, 237, 16, 247, 15, 240, 168, 240, 224, 251, 97, 238, 223, 237, 197, 241, 126, 234, 112, 239, 86, 237, 46, 244, 48, 247, 11, 247, 122, 243, 46, 245, 233, 244, 72, 240, 253, 249, 205, 244, 254, 255, 3, 232, 108, 233, 213, 232, 167, 232, 214, 235, 67, 240, 202, 233, 203, 233, 141, 240, 128, 243, 170, 237, 226, 237, 87, 235, 153, 233, 231, 238, 184, 241, 222, 233, 77, 238, 236, 236, 170, 238, 90, 237, 66, 234, 169, 235, 29, 250, 93, 247, 206, 240, 107, 239, 218, 247, 185, 238, 233, 237, 78, 238, 186, 241, 165, 246, 23, 233, 251, 238, 191, 243, 88, 238, 86, 237, 73, 244, 238, 242, 253, 247, 236, 240, 236, 239, 208, 242, 112, 238, 55, 239, 31, 240, 172, 239, 177, 0, 93, 0, 90, 242, 27, 239, 219, 244, 25, 0, 224, 0, 182, 240, 54, 244, 122, 1, 49, 0, 22, 2, 141, 248, 52, 250, 29, 240, 95, 1, 40, 239, 115, 244, 210, 255, 206, 255, 36, 3, 92, 0, 133, 0, 210, 255, 248, 2, 142, 255, 6, 248, 249, 255, 169, 239, 201, 255, 200, 255, 45, 255, 247, 255, 212, 255, 104, 255, 10, 0, 212, 255, 29, 6, 253, 2, 191, 6, 154, 4, 90, 5, 185, 0, 235, 16, 210, 18, 202, 19, 87, 21, 251, 4, 103, 5, 190, 11, 160, 1, 217, 4, 186, 11, 186, 17, 157, 16, 74, 18, 31, 4, 119, 11, 214, 3, 97, 244, 225, 255, 165, 255, 11, 243, 96, 244, 52, 5, 24, 7, 52, 5, 0, 5, 226, 3, 226, 0, 94, 2, 131, 1, 105, 0, 83, 8, 96, 253, 1, 0, 228, 248, 237, 255, 108, 255, 78, 255, 216, 255, 244, 255, 107, 0, 173, 255, 124, 255, 220, 255, 27, 1, 171, 1, 145, 1, 191, 1, 123, 1, 42, 2, 252, 0, 251, 0, 17, 0, 94, 255, 230, 0, 213, 0, 242, 0, 245, 0, 147, 0, 83, 2, 27, 1, 94, 2, 203, 0, 143, 1, 250, 0, 6, 236, 148, 235, 227, 234, 137, 236, 218, 236, 40, 236, 65, 239, 227, 236, 138, 239, 118, 244, 13, 238, 132, 237, 133, 255, 158, 246, 112, 255, 196, 235, 6, 237, 85, 236, 251, 1, 205, 2, 48, 2, 122, 245, 16, 0, 216, 255, 73, 0, 177, 255, 37, 255, 186, 237, 12, 255, 63, 243, 133, 246, 68, 245, 43, 245, 48, 243, 19, 244, 42, 243, 21, 239, 29, 241, 179, 239, 40, 247, 99, 243, 95, 243, 244, 253, 68, 249, 168, 0, 231, 242, 250, 241, 39, 242, 199, 255, 116, 255, 184, 255, 178, 244, 153, 254, 11, 253, 253, 255, 213, 254, 57, 254, 136, 241, 90, 245, 235, 240, 167, 0, 156, 0, 72, 1, 242, 2, 182, 1, 57, 254, 41, 255, 152, 1, 123, 0, 46, 0, 16, 0, 53, 2, 230, 1, 47, 1, 159, 1, 187, 255, 248, 255, 215, 0, 245, 0, 218, 0, 16, 1, 50, 0, 178, 0, 235, 0, 111, 4, 94, 0, 9, 0, 239, 236, 226, 237, 127, 238, 175, 237, 235, 236, 68, 236, 116, 242, 250, 238, 155, 255, 90, 244, 106, 246, 26, 252, 186, 255, 175, 251, 3, 0, 180, 237, 38, 247, 153, 238, 222, 255, 154, 242, 215, 249, 238, 235, 48, 234, 40, 236, 110, 234, 71, 235, 70, 235, 76, 233, 179, 235, 169, 234, 241, 237, 227, 241, 204, 243, 31, 242, 40, 244, 199, 239, 168, 238, 177, 241, 91, 236, 106, 237, 78, 242, 3, 239, 251, 237, 152, 238, 0, 238, 81, 243, 228, 243, 32, 241, 201, 237, 115, 239, 158, 236, 69, 235, 43, 235, 225, 235, 39, 233, 139, 234, 175, 233, 242, 233, 153, 234, 245, 232, 193, 255, 118, 246, 104, 248, 33, 235, 254, 235, 190, 233, 216, 234, 219, 232, 161, 233, 103, 236, 65, 232, 208, 236, 159, 231, 174, 234, 230, 232, 65, 234, 85, 234, 55, 234, 239, 232, 53, 233, 78, 232, 192, 236, 110, 241, 74, 239, 114, 236, 93, 235, 196, 237, 87, 236, 155, 234, 30, 239, 61, 240, 159, 239, 186, 234, 238, 234, 98, 233, 96, 235, 120, 237, 83, 236, 4, 236, 120, 4, 209, 6, 210, 2, 178, 253, 60, 1, 50, 254, 11, 2, 53, 9, 19, 5, 220, 234, 217, 235, 194, 248, 255, 236, 37, 236, 102, 246, 75, 1, 61, 255, 135, 0, 96, 251, 64, 245, 184, 247, 248, 252, 170, 248, 36, 1, 34, 239, 23, 246, 167, 238, 189, 242, 167, 238, 210, 254, 117, 244, 152, 244, 244, 242, 209, 242, 109, 243, 232, 240, 82, 241, 131, 242, 252, 239, 109, 247, 223, 247, 104, 249, 123, 242, 62, 247, 247, 242, 243, 242, 53, 251, 116, 246, 67, 237, 196, 237, 250, 236, 247, 238, 25, 237, 147, 239, 6, 242, 120, 240, 76, 242, 241, 244, 218, 243, 90, 244, 149, 236, 231, 237, 16, 237, 242, 234, 91, 234, 66, 236, 122, 233, 21, 234, 25, 235, 24, 241, 36, 241, 131, 244, 222, 235, 247, 236, 180, 236, 112, 237, 25, 237, 229, 235, 242, 242, 39, 242, 24, 242, 80, 237, 172, 238, 68, 236, 127, 236, 72, 241, 191, 235, 133, 235, 81, 235, 200, 238, 7, 238, 94, 236, 24, 235, 96, 234, 29, 239, 188, 242, 231, 234, 156, 237, 244, 251, 12, 241, 165, 239, 112, 240, 47, 238, 73, 237, 83, 236, 229, 237, 155, 235, 164, 235, 114, 238, 199, 233, 175, 236, 114, 237, 42, 239, 232, 236, 143, 235, 94, 234, 255, 233, 80, 234, 198, 235, 188, 234, 128, 235, 87, 236, 75, 237, 168, 235, 171, 234, 233, 234, 83, 234, 110, 234, 22, 234, 93, 236, 93, 235, 36, 233, 240, 233, 26, 233, 172, 233, 135, 246, 254, 241, 44, 240, 212, 242, 137, 243, 34, 237, 102, 236, 142, 240, 86, 239, 125, 239, 210, 239, 154, 245, 96, 241, 0, 242, 31, 236, 36, 238, 253, 234, 110, 240, 151, 238, 219, 240, 13, 238, 89, 239, 230, 249, 231, 247, 18, 237, 176, 237, 47, 237, 18, 245, 10, 253, 47, 242, 126, 244, 2, 242, 76, 241, 169, 237, 197, 238, 123, 237, 253, 237, 71, 237, 51, 238, 112, 237, 54, 241, 20, 240, 207, 236, 25, 235, 77, 243, 33, 237, 221, 240, 80, 242, 57, 242, 148, 240, 125, 235, 214, 234, 242, 236, 31, 236, 163, 238, 254, 237, 231, 237, 73, 255, 133, 255, 239, 255, 73, 255, 51, 0, 152, 255, 71, 0, 213, 253, 26, 255, 82, 0, 246, 0, 60, 254, 55, 255, 41, 2, 230, 255, 109, 0, 21, 1, 146, 0, 0, 0, 18, 0, 3, 1, 213, 255, 241, 255, 74, 0, 246, 255, 75, 255, 8, 247, 138, 247, 229, 244, 14, 245, 193, 246, 219, 243, 171, 245, 73, 12, 7, 11, 39, 10, 172, 9, 249, 8, 76, 8, 134, 250, 16, 3, 45, 249, 199, 243, 93, 245, 125, 255, 11, 245, 170, 0, 0, 0, 159, 8, 189, 247, 6, 9, 114, 255, 174, 249, 111, 253, 156, 240, 108, 1, 53, 251, 43, 249, 146, 3, 110, 251, 224, 2, 20, 2, 226, 0, 252, 255, 41, 6, 120, 254, 72, 254, 204, 1, 43, 7, 213, 0, 224, 10, 240, 10, 100, 12, 140, 8, 177, 9, 207, 6, 89, 8, 192, 10, 95, 8, 181, 255, 167, 6, 46, 6, 231, 252, 248, 255, 117, 253, 9, 255, 11, 3, 82, 11, 124, 1, 80, 9, 255, 7, 112, 1, 47, 0, 4, 0, 158, 2, 254, 248, 11, 254, 96, 255, 188, 254, 154, 248, 140, 4, 144, 3, 24, 245, 153, 0, 92, 5, 18, 249, 203, 3, 253, 0, 100, 245, 160, 255, 140, 1, 4, 255, 21, 4, 224, 247, 161, 245, 227, 252, 123, 2, 129, 236, 214, 2, 240, 2, 165, 245, 21, 7, 157, 3, 227, 249, 99, 1, 197, 3, 174, 0, 127, 0, 150, 0, 192, 255, 40, 0, 230, 255, 230, 0, 166, 0, 198, 0, 172, 255, 215, 255, 133, 255, 42, 0, 244, 255, 254, 255, 159, 0, 11, 0, 16, 0, 246, 3, 117, 6, 74, 2, 38, 1, 152, 1, 164, 0, 230, 0, 63, 2, 14, 1, 66, 0, 43, 0, 81, 0, 102, 242, 180, 244, 215, 239, 145, 240, 6, 250, 216, 242, 40, 252, 53, 237, 190, 236, 79, 255, 148, 251, 128, 255, 21, 238, 209, 237, 35, 2, 1, 0, 209, 255, 254, 246, 255, 247, 57, 250, 243, 255, 197, 0, 249, 255, 57, 239, 22, 254, 98, 244, 228, 5, 83, 1, 55, 3, 209, 0, 41, 1, 187, 255, 247, 255, 120, 1, 242, 255, 0, 0, 47, 237, 240, 255, 16, 244, 86, 255, 169, 255, 205, 0, 202, 255, 124, 0, 80, 0, 124, 0, 104, 0, 166, 0, 140, 0, 77, 1, 91, 0, 102, 0, 74, 0, 81, 0, 97, 0, 83, 0, 49, 0, 49, 0, 252, 255, 100, 0, 69, 0, 77, 0, 77, 0, 129, 0, 126, 0, 71, 0, 55, 0, 86, 0, 20, 0, 36, 0, 19, 0, 31, 0, 58, 0, 58, 0, 228, 238, 247, 243, 254, 239, 82, 255, 230, 240, 239, 240, 218, 241, 211, 241, 75, 250, 30, 255, 64, 255, 28, 255, 51, 255, 15, 255, 105, 255, 5, 255, 36, 255, 184, 254, 225, 255, 198, 255, 228, 255, 131, 255, 186, 255, 57, 255, 59, 255, 40, 255, 133, 255, 17, 255, 52, 255, 239, 255, 201, 0, 164, 0, 177, 0, 156, 0, 112, 0, 129, 0, 4, 0, 179, 0, 33, 0, 204, 0, 169, 0, 180, 0, 135, 0, 110, 0, 197, 0, 124, 0, 146, 0, 147, 0, 24, 0, 10, 1, 92, 255, 43, 0, 206, 255, 138, 0, 105, 0, 188, 0, 32, 0, 85, 0, 122, 0, 127, 0, 254, 255, 157, 255, 246, 255, 1, 0, 4, 0, 234, 254, 213, 255, 157, 255, 86, 255, 223, 0, 179, 1, 187, 0, 20, 3, 92, 0, 31, 0, 63, 255, 246, 255, 212, 0, 91, 245, 206, 244, 188, 244, 197, 247, 96, 251, 148, 255, 59, 252, 226, 252, 218, 252, 164, 250, 241, 251, 192, 251, 206, 254, 189, 1, 62, 252, 153, 253, 158, 252, 60, 255, 134, 1, 93, 246, 108, 255, 130, 251, 73, 0, 90, 0, 239, 255, 238, 255, 127, 255, 237, 255, 111, 1, 160, 1, 9, 1, 149, 2, 193, 0, 207, 0, 101, 5, 149, 255, 36, 0, 204, 0, 180, 254, 36, 5, 250, 1, 105, 0, 235, 0, 168, 255, 143, 239, 99, 255, 252, 240, 136, 243, 99, 245, 152, 1, 130, 6, 185, 246, 207, 254, 92, 243, 26, 1, 1, 0, 139, 255, 97, 254, 31, 0, 254, 255, 153, 243, 174, 254, 85, 246, 253, 254, 4, 245, 169, 253, 61, 252, 138, 253, 238, 247, 41, 244, 18, 243, 5, 255, 228, 246, 50, 248, 181, 245, 220, 248, 100, 254, 145, 248, 230, 249, 46, 247, 39, 245, 151, 247, 133, 243, 158, 241, 217, 255, 237, 255, 151, 0, 104, 0, 90, 1, 212, 0, 128, 1, 140, 254, 153, 0, 122, 0, 195, 255, 27, 0, 240, 255, 56, 1, 38, 1, 157, 0, 224, 0, 162, 1, 112, 1, 129, 1, 150, 1, 160, 1, 190, 1, 149, 0, 231, 0, 100, 1, 5, 245, 87, 250, 145, 241, 158, 244, 251, 244, 43, 250, 198, 245, 68, 242, 118, 241, 39, 241, 152, 253, 123, 242, 127, 254, 18, 241, 88, 241, 76, 241, 221, 254, 14, 255, 236, 254, 206, 255, 184, 1, 242, 254, 25, 0, 48, 242, 59, 248, 18, 247, 40, 240, 21, 241, 136, 239, 200, 255, 212, 241, 21, 243, 234, 255, 227, 253, 127, 1, 75, 1, 217, 4, 7, 2, 145, 5, 104, 5, 22, 6, 120, 4, 187, 4, 21, 4, 119, 0, 140, 4, 188, 253, 10, 2, 181, 0, 202, 0, 6, 0, 58, 2, 29, 2, 208, 6, 183, 3, 196, 2, 187, 254, 212, 0, 12, 255, 113, 0, 237, 0, 1, 247, 183, 0, 227, 255, 7, 250, 0, 0, 42, 1, 137, 0, 183, 0, 232, 0, 4, 1, 122, 255, 69, 1, 69, 254, 2, 2, 51, 1, 154, 1, 46, 1, 63, 1, 145, 1, 209, 1, 224, 0, 111, 1, 79, 1, 31, 2, 112, 1, 204, 1, 175, 1, 98, 1, 155, 1, 38, 0, 17, 0, 183, 2, 45, 5, 126, 2, 160, 1, 204, 1, 191, 1, 2, 3, 126, 2, 238, 254, 53, 255, 28, 253, 166, 5, 54, 0, 13, 3, 191, 255, 155, 255, 214, 1, 5, 0, 54, 0, 72, 0, 192, 3, 209, 3, 140, 0, 194, 3, 8, 2, 72, 4, 212, 1, 141, 1, 103, 1, 185, 0, 149, 0, 187, 2, 35, 5, 89, 0, 115, 5, 171, 7, 47, 2, 13, 4, 56, 239, 67, 250, 239, 242, 230, 241, 46, 247, 149, 239, 93, 241, 255, 0, 240, 255, 207, 255, 233, 255, 78, 0, 157, 255, 234, 254, 246, 255, 2, 0, 245, 255, 205, 245, 215, 255, 180, 255, 221, 255, 225, 255, 177, 255, 114, 243, 214, 244, 115, 241, 140, 0, 170, 2, 122, 0, 173, 0, 213, 0, 248, 255, 3, 0, 237, 255, 72, 0, 232, 3, 38, 0, 120, 1, 131, 1, 17, 0, 31, 0, 19, 0, 140, 0, 210, 0, 137, 236, 127, 242, 182, 244, 15, 236, 159, 236, 211, 236, 96, 241, 17, 241, 214, 237, 84, 233, 220, 235, 186, 233, 204, 234, 121, 233, 140, 232, 12, 235, 223, 232, 177, 232, 197, 234, 113, 233, 40, 248, 221, 235, 237, 234, 217, 232, 47, 234, 121, 232, 107, 233, 97, 234, 28, 233, 17, 234, 85, 240, 91, 238, 249, 237, 31, 0, 114, 251, 21, 0, 240, 236, 26, 238, 56, 237, 100, 241, 136, 243, 118, 249, 2, 255, 106, 242, 152, 242, 190, 255, 113, 255, 137, 255, 234, 234, 17, 235, 125, 234, 172, 236, 192, 235, 78, 236, 216, 235, 242, 234, 128, 235, 158, 255, 161, 239, 82, 238, 38, 252, 40, 255, 57, 254, 113, 239, 159, 1, 234, 255, 56, 3, 5, 1, 82, 255, 134, 232, 227, 232, 249, 232, 196, 243, 44, 234, 188, 234, 144, 234, 130, 233, 94, 235, 131, 241, 22, 241, 4, 241, 197, 242, 11, 245, 202, 242, 154, 240, 157, 240, 200, 244, 117, 235, 31, 239, 242, 240, 68, 234, 141, 236, 125, 234, 203, 233, 213, 233, 19, 241, 213, 236, 210, 240, 120, 241, 152, 249, 171, 233, 59, 234, 32, 235, 75, 234, 118, 237, 134, 238, 10, 238, 176, 235, 232, 240, 8, 245, 188, 242, 192, 246, 39, 241, 226, 255, 224, 255, 20, 254, 186, 255, 202, 255, 176, 255, 208, 249, 142, 246, 102, 242, 205, 241, 35, 249, 59, 255, 140, 253, 232, 247, 146, 245, 182, 249, 6, 244, 135, 254, 7, 1, 127, 255, 234, 1, 84, 2, 138, 243, 36, 245, 244, 0, 245, 2, 96, 0, 238, 245, 241, 255, 17, 0, 33, 0, 137, 1, 189, 0, 250, 1, 226, 1, 114, 3, 183, 1, 164, 2, 38, 3, 179, 255, 116, 4, 198, 255, 68, 2, 238, 255, 4, 0, 84, 3, 104, 1, 78, 0, 249, 255, 68, 1, 92, 1, 190, 255, 110, 255, 235, 255, 218, 255, 207, 255, 210, 255, 226, 255, 42, 1, 15, 1, 29, 0, 236, 255, 136, 0, 234, 255, 228, 255, 211, 255, 165, 255, 11, 0, 175, 255, 14, 0, 154, 0, 207, 255, 161, 255, 204, 255, 211, 255, 201, 255, 47, 2, 220, 255, 216, 255, 206, 0, 58, 0, 173, 1, 49, 1, 41, 1, 197, 0, 235, 0, 157, 1, 39, 1, 40, 2, 202, 2, 123, 2, 84, 1, 156, 1, 191, 2, 145, 2, 59, 3, 184, 1, 87, 2, 99, 1, 189, 2, 65, 2, 224, 1, 215, 1, 244, 1, 18, 1, 2, 240, 18, 241, 196, 241, 215, 241, 205, 241, 38, 244, 108, 245, 14, 247, 118, 245, 226, 244, 70, 0, 85, 248, 101, 255, 101, 242, 233, 244, 67, 243, 247, 2, 200, 2, 226, 0, 145, 4, 241, 2, 31, 3, 83, 4, 153, 245, 99, 255, 51, 0, 120, 5, 219, 1, 148, 2, 159, 7, 227, 5, 43, 9, 39, 2, 191, 6, 160, 4, 255, 4, 51, 7, 15, 6, 114, 5, 225, 8, 213, 8, 110, 11, 249, 7, 202, 5, 186, 3, 100, 6, 86, 1, 104, 7, 226, 6, 189, 9, 64, 4, 228, 4, 84, 4, 55, 7, 5, 5, 134, 10, 90, 2, 171, 3, 63, 7, 82, 3, 120, 3, 222, 0, 106, 2, 163, 1, 120, 0, 12, 7, 203, 3, 239, 2, 30, 3, 225, 6, 215, 5, 143, 4, 13, 5, 147, 8, 203, 235, 170, 234, 234, 233, 235, 239, 4, 235, 241, 234, 57, 234, 194, 234, 122, 235, 250, 237, 236, 245, 168, 233, 239, 234, 220, 237, 232, 234, 134, 234, 157, 233, 195, 233, 153, 236, 43, 235, 68, 236, 168, 233, 226, 232, 104, 233, 63, 233, 103, 232, 32, 235, 49, 235, 116, 234, 211, 234, 0, 235, 110, 235, 213, 235, 192, 234, 71, 238, 35, 234, 101, 234, 218, 233, 95, 234, 40, 235, 75, 234, 230, 235, 174, 235, 50, 235, 247, 236, 230, 237, 75, 246, 85, 238, 136, 237, 134, 238, 195, 233, 138, 234, 113, 234, 194, 234, 198, 233, 31, 235, 63, 236, 240, 238, 210, 235, 196, 236, 193, 236, 127, 236, 119, 235, 31, 234, 14, 235, 79, 235, 127, 235, 99, 235, 254, 235, 219, 235, 145, 235, 27, 235, 10, 235, 81, 235, 249, 236, 37, 236, 218, 234, 167, 236, 17, 235, 113, 235, 213, 234, 170, 235, 194, 234, 198, 233, 56, 233, 66, 242, 124, 234, 163, 233, 124, 234, 250, 233, 175, 233, 75, 233, 120, 234, 246, 232, 6, 235, 245, 233, 33, 235, 37, 233, 237, 233, 89, 233, 110, 238, 159, 238, 22, 238, 205, 239, 48, 240, 183, 239, 195, 238, 88, 238, 234, 238, 171, 239, 200, 238, 153, 239, 41, 238, 126, 238, 90, 238, 89, 239, 225, 238, 195, 239, 178, 236, 221, 236, 236, 236, 174, 238, 91, 238, 162, 239, 37, 237, 208, 237, 191, 237, 184, 238, 22, 238, 116, 238, 169, 255, 6, 0, 74, 255, 211, 239, 53, 241, 191, 240, 20, 242, 152, 240, 64, 241, 225, 240, 72, 238, 136, 237, 96, 239, 174, 239, 110, 238, 53, 239, 28, 239, 68, 239, 191, 240, 205, 240, 12, 241, 38, 240, 4, 243, 133, 241, 128, 239, 84, 240, 24, 240, 224, 239, 106, 240, 242, 239, 88, 236, 197, 234, 205, 234, 40, 235, 106, 234, 2, 237, 19, 235, 240, 234, 237, 234, 2, 237, 148, 236, 54, 236, 17, 238, 218, 236, 160, 236, 103, 237, 53, 237, 103, 237, 116, 237, 138, 236, 175, 237, 221, 235, 44, 236, 27, 237, 253, 235, 172, 235, 173, 235, 126, 235, 77, 235, 187, 235, 7, 240, 47, 239, 250, 239, 169, 238, 13, 238, 114, 237, 111, 236, 102, 236, 54, 238, 27, 238, 26, 237, 131, 237, 27, 237, 212, 235, 127, 236, 16, 239, 216, 239, 111, 237, 111, 239, 92, 237, 97, 238, 49, 240, 121, 239, 236, 236, 80, 238, 121, 239, 60, 237, 59, 235, 182, 237, 121, 237, 236, 241, 40, 243, 172, 239, 203, 240, 75, 240, 156, 240, 193, 239, 70, 238, 61, 239, 25, 239, 184, 233, 173, 234, 127, 235, 11, 235, 249, 235, 148, 238, 77, 237, 86, 237, 136, 237, 218, 240, 128, 237, 85, 236, 197, 234, 16, 235, 172, 235, 81, 236, 27, 236, 142, 235, 211, 236, 117, 237, 183, 236, 140, 237, 33, 2, 42, 5, 8, 2, 120, 248, 119, 243, 91, 244, 165, 248, 210, 237, 108, 239, 94, 237, 253, 255, 189, 1, 88, 238, 165, 238, 255, 238, 21, 239, 224, 238, 109, 239, 19, 239, 105, 244, 71, 240, 29, 240, 128, 234, 196, 236, 43, 235, 165, 234, 30, 235, 205, 238, 171, 236, 226, 237, 167, 238, 192, 237, 99, 245, 6, 237, 110, 238, 150, 237, 150, 236, 204, 235, 31, 236, 6, 236, 110, 0, 92, 1, 45, 1, 191, 0, 176, 0, 61, 2, 187, 1, 51, 0, 191, 1, 21, 1, 244, 0, 55, 1, 174, 1, 165, 0, 126, 0, 77, 1, 122, 0, 128, 0, 92, 0, 114, 1, 217, 1, 36, 1, 15, 8, 233, 4, 183, 3, 112, 5, 105, 3, 167, 6, 185, 12, 38, 0, 89, 0, 33, 0, 33, 1, 190, 0, 89, 1, 49, 1, 214, 0, 197, 1, 142, 4, 146, 3, 86, 7, 85, 6, 228, 1, 63, 3, 77, 2, 197, 2, 229, 2, 27, 5, 14, 235, 217, 234, 187, 247, 155, 238, 81, 245, 100, 240, 40, 255, 179, 0, 19, 2, 246, 1, 168, 2, 54, 1, 161, 0, 241, 255, 47, 0, 57, 1, 78, 0, 37, 0, 128, 0, 26, 0, 30, 1, 255, 1, 234, 1, 26, 0, 228, 0, 39, 0, 177, 1, 49, 1, 88, 1, 152, 1, 85, 1, 78, 0, 147, 0, 153, 0, 204, 0, 59, 1, 144, 0, 78, 1, 56, 1, 210, 0, 41, 1, 187, 0, 220, 0, 234, 0, 217, 239, 50, 239, 212, 240, 22, 240, 68, 240, 79, 239, 208, 239, 146, 241, 100, 241, 163, 241, 254, 239, 168, 240, 244, 240, 57, 240, 85, 241, 1, 241, 175, 239, 23, 240, 104, 240, 27, 240, 223, 241, 56, 240, 205, 240, 201, 240, 181, 240, 166, 239, 177, 248, 82, 246, 115, 243, 147, 241, 41, 243, 38, 242, 130, 243, 238, 244, 174, 245, 168, 242, 80, 242, 38, 242, 50, 243, 208, 241, 101, 242, 189, 241, 190, 239, 86, 241, 145, 242, 16, 243, 56, 242, 115, 243, 200, 242, 92, 243, 119, 243, 31, 243, 158, 243, 193, 241, 117, 242, 83, 243, 188, 251, 200, 1, 60, 243, 145, 0, 157, 2, 101, 250, 147, 248, 68, 241, 171, 241, 6, 243, 70, 242, 89, 243, 117, 242, 194, 241, 204, 252, 168, 240, 171, 241, 246, 254, 91, 255, 238, 4, 6, 242, 89, 244, 49, 241, 60, 243, 221, 243, 203, 243, 69, 241, 195, 242, 61, 241, 12, 241, 33, 241, 53, 244, 185, 242, 158, 243, 183, 244, 109, 244, 5, 240, 63, 241, 249, 239, 88, 242, 245, 240, 139, 243, 248, 242, 110, 242, 94, 0, 118, 0, 124, 3, 113, 0, 61, 0, 159, 0, 182, 2, 158, 242, 199, 255, 37, 0, 70, 0, 134, 0, 116, 0, 14, 1, 129, 0, 178, 0, 250, 0, 98, 0, 158, 0, 83, 0, 102, 0, 134, 0, 76, 0, 157, 2, 71, 4, 124, 6, 181, 234, 194, 234, 73, 237, 99, 234, 39, 235, 231, 233, 211, 234, 81, 247, 252, 248, 25, 252, 69, 239, 251, 245, 186, 239, 122, 0, 197, 245, 244, 244, 163, 237, 171, 238, 171, 235, 242, 239, 20, 241, 209, 234, 43, 239, 197, 245, 209, 6, 108, 249, 128, 246, 145, 245, 192, 245, 127, 243, 12, 245, 6, 243, 104, 248, 133, 244, 119, 244, 42, 1, 57, 6, 4, 1, 212, 243, 146, 255, 93, 1, 38, 0, 136, 255, 139, 244, 232, 246, 51, 243, 185, 243, 126, 249, 151, 249, 148, 2, 43, 249, 173, 254, 193, 254, 155, 247, 45, 244, 84, 243, 98, 236, 251, 245, 60, 242, 125, 252, 121, 4, 118, 240, 216, 255, 77, 243, 134, 240, 243, 240, 70, 1, 135, 0, 83, 3, 205, 3, 113, 0, 55, 0, 36, 0, 224, 255, 179, 7, 8, 7, 84, 6, 152, 6, 18, 3, 172, 7, 113, 12, 222, 255, 177, 0, 62, 248, 193, 9, 137, 8, 253, 255, 1, 0, 13, 1, 71, 0, 145, 242, 173, 252, 103, 255, 167, 8, 121, 0, 216, 0, 255, 246, 213, 242, 62, 244, 246, 241, 57, 242, 237, 255, 6, 0, 169, 0, 86, 2, 153, 2, 31, 0, 93, 242, 97, 240, 165, 237, 43, 241, 181, 239, 81, 8, 209, 239, 143, 255, 155, 242, 220, 241, 172, 241, 202, 237, 134, 252, 164, 236, 223, 238, 180, 250, 235, 255, 211, 255, 183, 255, 26, 255, 112, 243, 254, 255, 237, 255, 91, 231, 4, 251, 249, 255, 238, 255, 117, 245, 215, 239, 72, 249, 248, 253, 0, 0, 252, 255, 4, 5, 52, 0, 242, 0, 18, 247, 73, 243, 244, 254, 179, 250, 54, 238, 152, 239, 46, 0, 115, 251, 91, 241, 12, 243, 102, 243, 56, 255, 80, 0, 242, 255, 215, 255, 65, 0, 172, 0, 104, 0, 118, 0, 180, 0, 151, 0, 223, 0, 117, 0, 62, 0, 123, 0, 119, 0, 143, 0, 96, 0, 119, 0, 82, 1, 33, 3, 82, 1, 154, 0, 132, 1, 96, 1, 143, 1, 51, 2, 160, 0, 116, 0, 112, 0, 102, 0, 217, 0, 226, 0, 180, 0, 183, 0, 186, 0, 85, 0, 130, 0, 233, 255, 228, 255, 232, 255, 61, 0, 1, 0, 224, 0, 253, 255, 246, 255, 33, 0, 179, 0, 57, 1, 62, 0, 170, 0, 67, 2, 210, 0, 129, 0, 131, 0, 135, 0, 161, 0, 76, 5, 9, 10, 255, 7, 165, 7, 48, 13, 212, 8, 214, 6, 219, 13, 21, 1, 162, 1, 214, 2, 173, 4, 185, 0, 88, 3, 148, 0, 109, 19, 199, 1, 16, 12, 117, 0, 67, 0, 133, 0, 183, 0, 145, 0, 131, 0, 82, 0, 97, 0, 251, 0, 144, 16, 241, 0, 88, 1, 223, 0, 14, 1, 103, 1, 151, 0, 248, 0, 78, 0, 102, 0, 88, 0, 0, 1, 44, 1, 50, 2, 48, 1, 147, 1, 92, 1, 214, 0, 199, 0, 144, 0, 198, 0, 36, 2, 97, 2, 179, 0, 165, 0, 3, 1, 3, 1, 92, 3, 21, 2, 62, 2, 218, 1, 6, 255, 62, 1, 232, 254, 73, 2, 123, 2, 138, 1, 226, 247, 71, 1, 163, 251, 145, 249, 29, 1, 241, 255, 206, 254, 240, 0, 210, 255, 171, 2, 98, 1, 147, 1, 222, 0, 241, 1, 223, 0, 229, 1, 83, 2, 55, 1, 221, 3, 189, 246, 162, 247, 38, 246, 192, 0, 220, 252, 5, 244, 38, 2, 119, 0, 108, 0, 143, 1, 249, 0, 92, 1, 185, 1, 42, 1, 206, 1, 41, 0, 113, 0, 103, 0, 106, 0, 159, 0, 157, 1, 182, 0, 114, 0, 236, 4, 59, 1, 69, 0, 183, 0, 110, 0, 127, 255, 128, 3, 64, 4, 173, 4, 81, 5, 101, 0, 98, 0, 169, 4, 249, 4, 208, 3, 190, 255, 88, 249, 181, 247, 97, 254, 202, 255, 127, 3, 158, 1, 37, 0, 68, 0, 5, 1, 189, 0, 241, 255, 159, 251, 119, 246, 54, 253, 168, 2, 247, 255, 237, 253, 166, 248, 160, 1, 229, 242, 232, 2, 243, 255, 250, 255, 59, 247, 40, 240, 56, 242, 224, 238, 29, 239, 176, 242, 66, 241, 204, 240, 74, 243, 149, 235, 172, 236, 128, 236, 195, 239, 27, 239, 185, 239, 60, 239, 212, 237, 232, 239, 191, 238, 142, 240, 159, 242, 171, 2, 222, 2, 147, 4, 49, 236, 146, 243, 172, 238, 127, 252, 149, 253, 131, 239, 255, 238, 174, 237, 245, 235, 223, 6, 191, 5, 53, 0, 79, 4, 206, 3, 253, 4, 186, 255, 0, 1, 15, 245, 73, 0, 241, 255, 235, 255, 6, 1, 145, 0, 86, 0, 13, 0, 22, 1, 134, 1, 155, 241, 149, 241, 161, 240, 62, 244, 169, 242, 158, 244, 68, 247, 73, 244, 235, 255, 135, 250, 73, 250, 239, 242, 132, 1, 196, 1, 108, 1, 169, 0, 80, 1, 241, 3, 235, 247, 245, 255, 170, 255, 128, 249, 171, 254, 93, 1, 113, 5, 150, 9, 68, 3, 100, 1, 200, 255, 64, 0, 8, 2, 60, 2, 182, 0, 153, 4, 168, 3, 159, 3, 210, 1, 26, 2, 126, 3, 187, 252, 121, 8, 153, 1, 207, 242, 242, 0, 96, 248, 242, 241, 243, 244, 152, 0, 172, 1, 7, 1, 126, 0, 134, 0, 64, 247, 146, 246, 112, 246, 220, 255, 193, 2, 252, 1, 191, 2, 132, 246, 168, 0, 11, 0, 133, 0, 174, 0, 100, 0, 192, 8, 144, 4, 100, 248, 164, 2, 235, 5, 153, 3, 89, 247, 0, 0, 227, 255, 92, 0, 239, 255, 49, 2, 144, 1, 211, 3, 62, 0, 246, 4, 82, 0, 164, 1, 134, 253, 78, 1, 130, 1, 116, 2, 118, 1, 25, 3, 47, 3, 232, 2, 250, 1, 146, 3, 53, 3, 63, 250, 253, 248, 150, 1, 32, 1, 126, 3, 46, 3, 45, 2, 95, 1, 77, 3, 86, 0, 70, 4, 129, 3, 240, 7, 173, 2, 56, 4, 226, 255, 27, 0, 65, 3, 7, 0, 227, 255, 134, 5, 236, 3, 31, 1, 203, 255, 202, 10, 159, 8, 233, 8, 248, 8, 30, 4, 178, 5, 4, 4, 150, 2, 137, 1, 204, 1, 111, 1, 47, 2, 255, 3, 84, 0, 164, 7, 14, 0, 122, 0, 182, 0, 227, 255, 84, 6, 99, 0, 227, 255, 196, 6, 61, 0, 139, 4, 160, 2, 205, 1, 156, 1, 173, 1, 186, 1, 9, 1, 81, 1, 8, 1, 158, 0, 62, 1, 21, 1, 241, 0, 89, 1, 224, 1, 192, 1, 81, 1, 59, 1, 19, 1, 30, 1, 54, 1, 85, 1, 63, 1, 17, 1, 22, 1, 138, 1, 41, 1, 41, 1, 26, 237, 122, 238, 190, 241, 56, 242, 225, 238, 94, 239, 216, 238, 246, 255, 21, 255, 251, 253, 47, 245, 49, 251, 50, 0, 82, 237, 133, 239, 195, 239, 19, 244, 208, 255, 225, 238, 210, 239, 1, 0, 188, 249, 109, 245, 241, 241, 98, 243, 149, 242, 28, 237, 126, 235, 39, 236, 86, 1, 77, 0, 46, 0, 11, 240, 193, 244, 184, 0, 33, 1, 50, 1, 47, 1, 222, 1, 67, 1, 25, 1, 175, 0, 79, 1, 249, 0, 221, 255, 224, 1, 153, 0, 5, 1, 189, 1, 76, 0, 148, 2, 169, 1, 96, 1, 204, 0, 99, 1, 253, 0, 21, 1, 52, 0, 152, 0, 110, 1, 143, 1, 67, 0, 3, 1, 117, 0, 54, 0, 12, 0, 37, 1, 88, 1, 34, 1, 38, 1, 23, 1, 136, 1, 168, 0, 22, 1, 39, 0, 165, 1, 51, 0, 210, 0, 74, 0, 6, 1, 232, 0, 177, 1, 255, 0, 114, 1, 43, 0, 96, 0, 12, 0, 186, 0, 234, 0, 65, 0, 44, 241, 20, 239, 214, 255, 68, 247, 64, 241, 219, 246, 189, 255, 19, 0, 247, 255, 3, 0, 185, 237, 22, 238, 79, 238, 254, 236, 173, 237, 208, 235, 142, 239, 127, 238, 186, 242, 89, 240, 85, 240, 30, 238, 61, 0, 119, 246, 145, 244, 206, 236, 107, 238, 181, 238, 119, 2, 185, 1, 37, 1, 255, 0, 147, 2, 87, 1, 195, 1, 174, 1, 62, 1, 231, 255, 49, 2, 84, 0, 31, 233, 249, 234, 39, 234, 178, 232, 30, 235, 180, 232, 237, 235, 166, 237, 59, 240, 231, 239, 170, 244, 207, 237, 163, 244, 152, 236, 175, 244, 215, 241, 232, 240, 247, 237, 174, 243, 54, 241, 75, 239, 232, 239, 116, 239, 81, 237, 164, 242, 59, 238, 169, 0, 246, 0, 173, 0, 68, 0, 220, 255, 59, 238, 63, 239, 203, 239, 142, 238, 16, 245, 26, 239, 49, 240, 34, 239, 143, 239, 118, 239, 80, 241, 43, 239, 226, 240, 81, 238, 28, 239, 209, 238, 7, 238, 225, 237, 74, 236, 76, 240, 204, 238, 5, 240, 101, 237, 28, 237, 180, 234, 246, 236, 48, 235, 40, 237, 124, 234, 119, 236, 136, 235, 22, 243, 24, 240, 191, 243, 240, 239, 75, 241, 137, 242, 80, 239, 220, 240, 35, 238, 192, 235, 1, 236, 85, 238, 67, 236, 151, 238, 102, 237, 211, 237, 214, 237, 232, 238, 245, 238, 63, 237, 134, 239, 104, 245, 247, 242, 47, 242, 252, 239, 216, 240, 167, 239, 223, 242, 169, 241, 37, 239, 227, 234, 118, 235, 92, 237, 130, 237, 92, 235, 140, 234, 27, 240, 3, 238, 130, 238, 146, 237, 249, 238, 195, 238, 57, 237, 148, 235, 211, 236, 42, 236, 37, 234, 150, 234, 219, 234, 217, 233, 230, 235, 8, 241, 227, 237, 11, 238, 28, 239, 228, 238, 155, 239, 210, 235, 212, 234, 239, 235, 155, 238, 225, 239, 225, 241, 144, 235, 240, 238, 44, 236, 85, 242, 46, 238, 10, 240, 242, 234, 138, 236, 119, 236, 217, 235, 123, 239, 175, 239, 99, 238, 94, 238, 50, 243, 12, 241, 181, 248, 5, 240, 101, 241, 226, 242, 246, 239, 236, 242, 206, 241, 186, 242, 186, 240, 227, 242, 229, 241, 115, 234, 17, 235, 167, 233, 201, 235, 54, 236, 191, 243, 200, 241, 251, 239, 42, 240, 237, 238, 24, 240, 36, 238, 55, 239, 47, 238, 167, 235, 184, 235, 89, 242, 211, 246, 38, 243, 22, 236, 174, 237, 82, 235, 164, 235, 186, 234, 26, 236, 172, 234, 222, 234, 108, 240, 62, 238, 124, 234, 19, 234, 133, 237, 177, 235, 159, 235, 209, 236, 67, 239, 200, 234, 118, 235, 228, 233, 62, 235, 98, 234, 61, 235, 153, 233, 20, 234, 227, 235, 138, 236, 71, 236, 188, 236, 249, 238, 252, 236, 83, 238, 25, 240, 221, 237, 31, 236, 169, 240, 218, 237, 99, 242, 25, 241, 26, 240, 18, 245, 81, 241, 197, 241, 10, 242, 207, 237, 159, 240, 93, 239, 184, 241, 16, 237, 227, 236, 39, 242, 16, 240, 211, 239, 179, 241, 97, 238, 24, 238, 78, 236, 124, 236, 170, 238, 124, 239, 182, 236, 221, 236, 72, 235, 249, 239, 173, 238, 104, 0, 141, 0, 71, 0, 57, 0, 57, 0, 22, 0, 67, 0, 158, 0, 141, 0, 144, 0, 82, 0, 188, 0, 113, 0, 73, 0, 172, 0, 214, 0, 138, 0, 81, 0, 149, 0, 138, 0, 156, 0, 183, 0, 133, 0, 82, 0, 105, 0, 47, 0, 179, 243, 178, 244, 124, 242, 156, 242, 95, 241, 228, 246, 44, 247, 141, 238, 122, 238, 214, 236, 225, 0, 160, 247, 85, 3, 127, 238, 14, 239, 43, 239, 89, 1, 213, 0, 203, 255, 139, 15, 165, 0, 42, 2, 66, 2, 73, 239, 49, 0, 110, 244, 249, 12, 147, 5, 66, 2, 113, 13, 90, 12, 51, 19, 227, 247, 131, 232, 170, 243, 159, 0, 33, 12, 251, 0, 220, 16, 66, 17, 231, 14, 234, 11, 121, 14, 75, 14, 74, 241, 108, 241, 49, 240, 24, 237, 18, 239, 110, 234, 101, 15, 166, 237, 147, 250, 3, 4, 39, 246, 54, 240, 126, 0, 145, 0, 112, 0, 151, 0, 240, 0, 68, 248, 228, 8, 67, 17, 144, 11, 164, 8, 170, 0, 217, 0, 248, 0, 239, 0, 209, 13, 246, 0, 141, 1, 68, 1, 60, 239, 145, 239, 227, 238, 96, 239, 247, 239, 236, 238, 101, 239, 221, 243, 139, 241, 210, 241, 142, 243, 230, 241, 78, 242, 160, 238, 84, 240, 129, 238, 218, 240, 27, 241, 45, 240, 128, 240, 192, 242, 178, 240, 238, 239, 212, 239, 166, 239, 38, 239, 55, 244, 137, 243, 85, 245, 227, 240, 145, 241, 234, 240, 164, 242, 248, 242, 233, 242, 48, 240, 120, 240, 145, 239, 155, 241, 157, 240, 21, 241, 85, 240, 145, 240, 80, 241, 33, 243, 110, 243, 105, 243, 80, 241, 132, 243, 36, 243, 17, 242, 15, 243, 126, 241, 231, 240, 58, 241, 214, 241, 185, 242, 196, 243, 180, 242, 189, 243, 180, 240, 152, 241, 14, 241, 229, 241, 14, 243, 116, 241, 145, 243, 107, 241, 10, 243, 194, 242, 81, 241, 249, 238, 209, 240, 204, 240, 251, 240, 159, 241, 196, 238, 72, 239, 230, 236, 241, 241, 220, 240, 44, 241, 186, 243, 122, 242, 9, 244, 94, 243, 9, 244, 133, 239, 27, 241, 117, 239, 126, 241, 219, 241, 42, 242, 124, 243, 119, 243, 92, 243, 156, 241, 222, 241, 252, 242, 72, 243, 243, 234, 210, 237, 122, 236, 13, 238, 129, 236, 128, 237, 10, 238, 218, 236, 165, 236, 162, 241, 107, 247, 253, 242, 209, 239, 63, 240, 193, 241, 185, 239, 130, 239, 5, 239, 31, 240, 248, 239, 181, 239, 136, 238, 140, 238, 58, 238, 131, 239, 22, 239, 167, 239, 33, 238, 31, 237, 242, 237, 135, 1, 93, 235, 90, 13, 19, 239, 59, 239, 12, 239, 124, 0, 53, 237, 46, 237, 93, 241, 19, 241, 20, 242, 224, 241, 151, 240, 36, 241, 31, 240, 81, 241, 141, 241, 95, 241, 177, 241, 27, 242, 55, 240, 5, 240, 147, 255, 18, 239, 150, 240, 35, 241, 58, 240, 58, 240, 27, 240, 190, 243, 188, 243, 204, 243, 120, 241, 189, 243, 92, 242, 149, 242, 245, 241, 176, 242, 251, 238, 38, 242, 52, 241, 57, 241, 11, 239, 163, 241, 9, 241, 242, 240, 110, 240, 10, 242, 94, 241, 21, 243, 72, 241, 157, 242, 146, 241, 202, 243, 50, 242, 116, 244, 124, 242, 19, 242, 152, 243, 75, 243, 107, 238, 23, 244, 2, 243, 111, 239, 56, 240, 119, 243, 234, 241, 4, 240, 11, 242, 224, 254, 148, 239, 191, 240, 177, 241, 20, 242, 200, 241, 96, 241, 190, 241, 44, 242, 1, 240, 52, 240, 244, 240, 187, 239, 138, 242, 180, 240, 55, 241, 251, 240, 78, 239, 233, 241, 2, 242, 167, 236, 81, 237, 230, 238, 221, 238, 176, 238, 233, 237, 10, 239, 112, 239, 45, 240, 101, 239, 100, 243, 243, 241, 32, 243, 248, 242, 66, 242, 252, 241, 148, 241, 187, 242, 223, 242, 42, 242, 69, 241, 144, 241, 158, 239, 76, 240, 72, 240, 145, 240, 72, 240, 201, 240, 206, 239, 253, 242, 205, 247, 55, 242, 188, 239, 101, 238, 186, 240, 187, 239, 87, 241, 30, 238, 224, 241, 228, 246, 21, 249, 144, 239, 154, 238, 122, 237, 205, 241, 159, 241, 176, 239, 207, 240, 89, 242, 233, 240, 207, 239, 40, 239, 60, 240, 191, 240, 107, 239, 83, 240, 54, 239, 81, 239, 15, 239, 11, 242, 70, 240, 83, 242, 36, 242, 4, 241, 39, 238, 178, 238, 217, 238, 68, 238, 229, 239, 172, 239, 195, 239, 207, 239, 203, 237, 54, 238, 200, 238, 88, 238, 77, 238, 54, 238, 220, 237, 242, 237, 48, 239, 16, 239, 125, 239, 20, 239, 33, 239, 164, 238, 205, 237, 132, 238, 56, 238, 27, 238, 251, 236, 172, 238, 17, 239, 114, 237, 221, 238, 255, 237, 134, 238, 82, 238, 47, 235, 135, 235, 203, 235, 228, 234, 82, 235, 53, 236, 55, 237, 138, 238, 195, 237, 90, 237, 163, 236, 227, 236, 238, 238, 53, 237, 251, 235, 87, 235, 59, 237, 129, 237, 126, 236, 127, 236, 214, 236, 129, 236, 220, 235, 249, 235, 80, 236, 46, 236, 180, 239, 57, 245, 122, 248, 156, 235, 18, 239, 175, 240, 158, 237, 75, 237, 191, 237, 184, 238, 13, 240, 107, 239, 69, 239, 125, 243, 102, 239, 51, 240, 78, 240, 74, 238, 181, 237, 108, 237, 234, 238, 240, 235, 237, 237, 207, 235, 109, 237, 43, 237, 2, 238, 53, 236, 148, 240, 217, 236, 235, 237, 15, 239, 20, 239, 82, 239, 184, 238, 31, 239, 172, 238, 56, 240, 39, 239, 198, 238, 123, 238, 84, 239, 172, 238, 160, 238, 234, 238, 173, 239, 97, 239, 80, 239, 32, 235, 29, 235, 38, 235, 131, 236, 40, 234, 21, 239, 57, 235, 159, 237, 96, 237, 20, 238, 33, 235, 63, 234, 141, 236, 197, 239, 104, 236, 205, 233, 61, 241, 29, 237, 194, 236, 60, 238, 163, 237, 146, 238, 14, 237, 165, 235, 187, 236, 137, 242, 53, 235, 17, 236, 208, 234, 164, 234, 49, 237, 26, 236, 159, 233, 240, 234, 23, 235, 83, 245, 146, 235, 10, 236, 134, 243, 125, 238, 42, 234, 139, 234, 29, 234, 98, 233, 124, 234, 226, 235, 253, 234, 76, 233, 247, 233, 153, 232, 47, 234, 230, 237, 63, 234, 248, 232, 206, 232, 76, 239, 188, 235, 219, 234, 67, 0, 34, 236, 113, 234, 21, 236, 174, 235, 123, 239, 171, 240, 5, 235, 83, 237, 109, 235, 79, 254, 208, 255, 205, 235, 111, 234, 66, 236, 249, 233, 210, 233, 115, 235, 20, 234, 11, 234, 11, 234, 86, 247, 25, 235, 13, 235, 249, 238, 106, 234, 203, 235, 137, 239, 128, 236, 80, 237, 75, 235, 20, 242, 121, 234, 211, 232, 178, 237, 17, 247, 39, 237, 159, 236, 59, 235, 114, 236, 36, 235, 180, 236, 197, 238, 113, 251, 37, 253, 18, 237, 153, 226, 197, 237, 190, 245, 162, 249, 187, 250, 66, 236, 18, 234, 75, 235, 128, 233, 153, 233, 245, 233, 126, 234, 242, 233, 20, 235, 236, 245, 62, 246, 247, 245, 43, 245, 250, 244, 204, 243, 120, 247, 18, 247, 118, 220, 147, 236, 153, 233, 45, 242, 229, 240, 87, 238, 241, 239, 33, 242, 65, 238, 65, 238, 121, 238, 130, 239, 122, 237, 63, 241, 90, 246, 113, 245, 122, 239, 204, 239, 175, 234, 178, 234, 183, 236, 219, 235, 125, 236, 133, 237, 24, 235, 195, 236, 52, 238, 78, 236, 209, 235, 252, 237, 21, 237, 118, 237, 109, 236, 33, 242, 251, 234, 217, 235, 182, 235, 255, 234, 101, 234, 13, 235, 214, 238, 195, 233, 56, 235, 249, 249, 77, 242, 252, 246, 179, 237, 224, 245, 221, 237, 118, 243, 109, 240, 11, 236, 231, 238, 93, 238, 233, 240, 98, 235, 79, 237, 129, 236, 93, 236, 253, 238, 237, 238, 21, 235, 118, 240, 70, 235, 97, 234, 15, 236, 198, 236, 30, 234, 242, 235, 220, 234, 153, 244, 222, 235, 211, 234, 140, 234, 219, 244, 137, 237, 217, 251, 128, 246, 190, 237, 229, 235, 249, 235, 15, 237, 202, 234, 186, 235, 1, 234, 56, 235, 11, 236, 12, 238, 59, 239, 53, 237, 203, 238, 117, 239, 78, 235, 84, 234, 99, 236, 190, 238, 144, 236, 214, 235, 94, 237, 35, 237, 59, 237, 216, 235, 45, 236, 177, 235, 152, 234, 184, 235, 41, 235, 216, 234, 216, 235, 111, 240, 230, 237, 92, 235, 170, 235, 29, 235, 60, 233, 176, 235, 199, 236, 2, 237, 218, 234, 58, 234, 162, 235, 225, 234, 215, 234, 128, 234, 66, 234, 91, 234, 27, 239, 196, 237, 40, 237, 125, 236, 228, 235, 133, 237, 123, 237, 198, 236, 53, 236, 39, 237, 179, 235, 221, 235, 153, 238, 180, 240, 45, 235, 14, 235, 146, 235, 213, 233, 171, 235, 109, 237, 245, 234, 80, 236, 172, 245, 114, 235, 151, 236, 138, 255, 133, 239, 71, 236, 97, 235, 247, 236, 156, 236, 25, 235, 96, 238, 137, 238, 80, 238, 229, 236, 162, 238, 209, 235, 72, 236, 119, 240, 4, 235, 238, 235, 35, 236, 111, 241, 22, 241, 30, 235, 90, 234, 22, 235, 130, 233, 235, 233, 147, 235, 253, 238, 181, 231, 27, 233, 232, 233, 82, 233, 39, 233, 244, 233, 52, 233, 33, 233, 157, 231, 3, 232, 44, 232, 132, 239, 42, 234, 19, 234, 34, 251, 192, 250, 233, 252, 83, 245, 228, 242, 103, 248, 239, 235, 79, 233, 88, 234, 163, 233, 54, 234, 210, 233, 208, 233, 42, 226, 179, 235, 244, 227, 169, 233, 254, 233, 199, 236, 68, 234, 187, 233, 234, 234, 37, 234, 12, 230, 155, 234, 156, 237, 86, 234, 205, 233, 202, 236, 118, 235, 92, 234, 225, 232, 14, 237, 40, 234, 53, 233, 191, 232, 65, 233, 88, 234, 59, 232, 92, 232, 201, 233, 149, 234, 23, 233, 49, 234, 174, 231, 93, 237, 151, 232, 21, 232, 68, 232, 155, 232, 71, 237, 243, 232, 234, 232, 13, 234, 83, 235, 196, 232, 98, 236, 4, 235, 134, 234, 66, 236, 243, 234, 129, 233, 140, 234, 247, 232, 73, 233, 146, 233, 200, 232, 185, 232, 0, 233, 199, 235, 68, 245, 31, 241, 241, 240, 184, 239, 74, 1, 212, 0, 222, 4, 34, 2, 211, 4, 54, 1, 169, 1, 169, 6, 243, 6, 22, 9, 177, 4, 175, 3, 245, 3, 178, 7, 37, 5, 160, 8, 110, 3, 102, 2, 221, 1, 12, 2, 28, 5, 250, 1, 222, 255, 102, 2, 31, 3, 152, 2, 129, 0, 210, 4, 133, 2, 31, 0, 78, 1, 43, 0, 239, 4, 237, 1, 47, 4, 139, 0, 41, 1, 137, 0, 6, 5, 53, 5, 183, 4, 231, 255, 240, 1, 2, 0, 65, 6, 80, 4, 193, 4, 255, 4, 2, 4, 141, 5, 34, 4, 166, 4, 60, 4, 53, 4, 178, 5, 134, 5, 227, 255, 39, 251, 168, 3, 188, 255, 205, 1, 194, 1, 238, 0, 161, 1, 172, 3, 69, 1, 160, 2, 177, 1, 229, 3, 175, 5, 59, 1, 190, 0, 123, 0, 45, 2, 110, 0, 62, 0, 52, 1, 111, 1, 231, 0, 197, 0, 53, 1, 79, 3, 240, 4, 143, 3, 34, 5, 67, 5, 176, 4, 239, 0, 34, 3, 198, 2, 14, 4, 101, 3, 221, 5, 134, 3, 122, 3, 54, 3, 43, 2, 214, 2, 112, 2, 171, 2, 216, 250, 46, 236, 25, 245, 77, 243, 26, 237, 165, 246, 101, 254, 193, 236, 192, 254, 48, 233, 203, 232, 76, 237, 21, 231, 156, 233, 122, 234, 37, 234, 184, 234, 177, 230, 60, 240, 176, 252, 231, 238, 209, 240, 44, 0, 249, 255, 109, 0, 86, 0, 218, 254, 84, 1, 213, 0, 153, 2, 69, 242, 137, 240, 18, 243, 15, 239, 206, 239, 132, 239, 203, 245, 71, 241, 136, 237, 148, 234, 186, 233, 181, 239, 217, 233, 177, 232, 130, 232, 3, 238, 183, 234, 31, 237, 43, 237, 27, 235, 36, 235, 11, 239, 201, 235, 2, 242, 82, 237, 147, 236, 17, 243, 98, 235, 148, 236, 205, 239, 5, 2, 52, 1, 92, 0, 189, 0, 123, 0, 98, 1, 181, 0, 200, 0, 216, 1, 65, 241, 208, 240, 111, 240, 134, 246, 223, 241, 52, 253, 149, 255, 119, 252, 171, 255, 9, 248, 126, 249, 223, 233, 173, 255, 106, 248, 151, 255, 63, 234, 217, 239, 10, 237, 233, 255, 115, 0, 203, 255, 190, 232, 63, 236, 198, 233, 213, 232, 12, 236, 53, 236, 122, 235, 249, 235, 37, 232, 116, 233, 21, 0, 11, 232, 208, 249, 90, 3, 176, 236, 234, 235, 239, 236, 12, 237, 25, 254, 178, 2, 211, 255, 77, 255, 236, 243, 216, 2, 18, 1, 197, 241, 108, 1, 40, 242, 214, 0, 127, 2, 80, 235, 88, 234, 26, 0, 196, 232, 44, 0, 253, 249, 201, 1, 68, 249, 132, 252, 222, 255, 157, 0, 8, 0, 4, 0, 21, 0, 54, 0, 107, 247, 155, 251, 143, 255, 149, 255, 43, 253, 165, 255, 210, 255, 254, 255, 233, 2, 37, 0, 210, 255, 131, 1, 225, 255, 242, 255, 250, 255, 198, 255, 240, 255, 183, 234, 248, 240, 3, 233, 251, 242, 46, 250, 210, 232, 208, 232, 24, 241, 59, 233, 211, 239, 245, 231, 60, 235, 130, 241, 93, 235, 219, 237, 118, 235, 183, 238, 128, 237, 141, 243, 79, 236, 220, 239, 130, 244, 20, 254, 151, 250, 93, 251, 110, 247, 82, 244, 151, 236, 27, 239, 56, 238, 116, 253, 88, 0, 194, 231, 65, 249, 16, 1, 165, 240, 41, 250, 50, 2, 255, 2, 120, 253, 92, 238, 80, 237, 233, 237, 227, 243, 23, 237, 241, 238, 74, 248, 146, 248, 40, 247, 166, 241, 242, 243, 89, 244, 228, 254, 217, 251, 211, 253, 18, 241, 40, 242, 106, 241, 206, 238, 210, 237, 89, 237, 122, 241, 139, 240, 252, 238, 204, 238, 134, 246, 55, 244, 153, 248, 184, 249, 18, 244, 79, 237, 131, 238, 122, 239, 141, 238, 47, 238, 56, 237, 119, 239, 142, 238, 61, 239, 39, 238, 92, 236, 34, 238, 148, 236, 126, 236, 233, 236, 64, 235, 101, 236, 211, 235, 110, 243, 226, 240, 73, 243, 155, 239, 224, 239, 21, 239, 28, 241, 212, 239, 200, 238, 12, 239, 107, 238, 158, 239, 251, 235, 122, 239, 110, 237, 182, 237, 178, 241, 108, 236, 140, 241, 3, 247, 189, 242, 1, 237, 17, 236, 236, 235, 44, 241, 64, 235, 126, 238, 192, 234, 147, 234, 16, 236, 86, 243, 3, 244, 84, 242, 57, 240, 64, 239, 20, 242, 60, 239, 60, 240, 127, 237, 161, 237, 178, 235, 146, 241, 193, 245, 96, 252, 212, 247, 108, 255, 46, 250, 195, 238, 180, 237, 121, 239, 213, 237, 101, 240, 55, 237, 108, 239, 205, 237, 226, 237, 24, 238, 137, 245, 70, 238, 152, 249, 82, 238, 44, 239, 224, 238, 249, 242, 254, 255, 244, 241, 13, 240, 63, 241, 30, 248, 141, 241, 223, 237, 208, 244, 233, 237, 152, 251, 39, 238, 174, 236, 0, 238, 81, 236, 217, 241, 159, 243, 191, 255, 84, 250, 157, 245, 138, 247, 250, 238, 212, 239, 44, 239, 222, 239, 59, 240, 10, 242, 142, 1, 28, 0, 208, 1, 163, 244, 22, 250, 233, 244, 66, 2, 129, 0, 205, 0, 166, 241, 8, 3, 42, 0, 213, 3, 15, 4, 222, 5, 217, 246, 89, 1, 33, 244, 179, 242, 221, 244, 54, 242, 24, 0, 96, 243, 28, 0, 247, 255, 51, 242, 35, 0, 32, 247, 207, 255, 65, 246, 193, 239, 79, 239, 112, 238, 164, 239, 54, 238, 11, 239, 196, 241, 52, 244, 1, 236, 43, 243, 101, 241, 159, 241, 101, 240, 228, 238, 81, 243, 71, 244, 21, 243, 147, 240, 199, 235, 204, 237, 163, 236, 142, 235, 149, 236, 63, 236, 123, 242, 126, 239, 215, 237, 238, 237, 181, 240, 161, 237, 111, 251, 28, 3, 76, 1, 193, 247, 236, 237, 167, 236, 196, 237, 15, 237, 179, 238, 130, 255, 149, 245, 217, 238, 87, 239, 223, 239, 153, 238, 101, 238, 164, 237, 201, 237, 204, 237, 121, 237, 117, 240, 164, 236, 160, 235, 215, 235, 14, 236, 15, 236, 59, 236, 212, 239, 9, 237, 119, 240, 1, 237, 142, 236, 10, 237, 189, 234, 208, 235, 246, 236, 86, 255, 210, 253, 174, 1, 29, 237, 86, 241, 145, 237, 223, 245, 83, 244, 78, 239, 130, 236, 201, 236, 84, 236, 5, 236, 81, 236, 209, 237, 55, 235, 102, 235, 98, 245, 181, 238, 151, 235, 31, 239, 230, 236, 93, 239, 220, 239, 189, 245, 115, 245, 199, 244, 165, 235, 201, 235, 71, 234, 220, 237, 56, 237, 168, 237, 64, 235, 151, 238, 0, 238, 91, 236, 166, 236, 207, 238, 34, 234, 228, 235, 138, 234, 213, 4, 184, 2, 180, 2, 222, 3, 109, 3, 158, 3, 74, 1, 148, 4, 201, 6, 66, 4, 161, 3, 117, 4, 15, 4, 40, 4, 15, 4, 91, 4, 0, 4, 101, 4, 201, 240, 110, 244, 193, 238, 15, 5, 65, 4, 214, 255, 47, 3, 134, 5, 170, 5, 190, 4, 237, 4, 171, 5, 123, 237, 229, 235, 106, 236, 40, 237, 32, 239, 209, 237, 253, 3, 107, 249, 19, 242, 247, 234, 195, 3, 14, 251, 127, 255, 216, 3, 198, 5, 226, 254, 15, 0, 64, 255, 226, 237, 94, 242, 72, 238, 35, 238, 31, 237, 237, 235, 186, 235, 94, 239, 114, 237, 160, 239, 235, 236, 126, 238, 213, 237, 37, 241, 189, 236, 82, 235, 178, 250, 108, 240, 213, 239, 226, 243, 72, 247, 148, 238, 99, 0, 84, 254, 48, 0, 99, 252, 77, 244, 117, 246, 32, 245, 123, 236, 199, 242, 126, 236, 69, 245, 208, 249, 160, 255, 84, 246, 45, 242, 218, 240, 242, 241, 84, 239, 174, 237, 137, 248, 171, 237, 60, 242, 20, 236, 19, 240, 237, 237, 250, 241, 146, 243, 223, 242, 121, 245, 149, 250, 222, 245, 85, 246, 174, 248, 221, 242, 34, 236, 184, 242, 71, 240, 80, 237, 99, 237, 105, 237, 246, 242, 116, 246, 253, 249, 76, 248, 249, 244, 195, 248, 70, 249, 24, 238, 233, 239, 55, 235, 141, 239, 158, 237, 101, 235, 170, 235, 55, 241, 22, 241, 109, 248, 113, 246, 32, 245, 214, 247, 27, 246, 44, 241, 89, 241, 20, 239, 253, 242, 39, 248, 169, 241, 235, 243, 122, 243, 103, 238, 242, 238, 171, 244, 66, 242, 18, 243, 176, 239, 116, 240, 114, 12, 82, 10, 220, 11, 30, 0, 22, 7, 196, 6, 41, 0, 143, 4, 57, 254, 130, 241, 17, 243, 245, 242, 168, 234, 178, 234, 124, 235, 9, 235, 114, 235, 151, 235, 61, 235, 115, 6, 177, 253, 22, 0, 183, 243, 191, 242, 166, 2, 235, 237, 125, 238, 107, 236, 179, 235, 156, 236, 55, 235, 88, 235, 27, 247, 122, 236, 220, 241, 65, 236, 55, 237, 109, 235, 20, 12, 128, 12, 214, 10, 33, 15, 180, 13, 138, 13, 155, 11, 50, 13, 153, 13, 117, 12, 153, 12, 17, 14, 247, 10, 246, 10, 157, 7, 214, 14, 183, 13, 215, 15, 0, 12, 236, 13, 144, 11, 60, 14, 194, 14, 207, 13, 167, 12, 252, 13, 180, 12, 54, 15, 167, 13, 180, 14, 59, 239, 196, 6, 165, 245, 8, 241, 254, 254, 106, 9, 36, 11, 210, 11, 153, 9, 203, 6, 223, 9, 103, 3, 35, 2, 65, 4, 76, 6, 201, 9, 93, 10, 131, 8, 89, 241, 43, 238, 68, 238, 167, 236, 0, 240, 110, 236, 28, 236, 2, 241, 69, 244, 140, 240, 1, 239, 87, 240, 211, 242, 181, 244, 108, 240, 27, 239, 208, 236, 243, 237, 153, 236, 14, 236, 17, 237, 165, 237, 144, 241, 174, 236, 56, 240, 40, 236, 9, 228, 207, 236, 0, 244, 41, 239, 38, 236, 145, 238, 17, 239, 139, 238, 175, 238, 135, 242, 47, 245, 158, 238, 213, 243, 80, 243, 85, 245, 76, 239, 48, 239, 199, 239, 5, 241, 138, 247, 179, 244, 86, 239, 137, 241, 93, 240, 51, 243, 89, 243, 171, 242, 24, 240, 214, 241, 84, 239, 154, 237, 104, 235, 171, 240, 244, 244, 16, 239, 181, 241, 239, 238, 46, 237, 11, 238, 73, 241, 78, 238, 241, 239, 205, 238, 201, 237, 184, 238, 37, 238, 23, 239, 247, 235, 18, 240, 184, 234, 95, 244, 182, 245, 65, 243, 4, 243, 193, 238, 68, 241, 95, 241, 139, 242, 207, 242, 155, 241, 131, 240, 115, 250, 35, 247, 10, 247, 114, 246, 80, 245, 251, 238, 138, 239, 237, 237, 91, 239, 77, 243, 106, 243, 89, 241, 40, 241, 72, 236, 40, 237, 111, 237, 245, 237, 67, 237, 227, 237, 49, 236, 176, 237, 35, 237, 188, 252, 97, 252, 49, 255, 69, 244, 159, 251, 132, 254, 65, 240, 64, 242, 182, 238, 210, 240, 204, 242, 57, 238, 27, 238, 66, 240, 87, 240, 84, 255, 152, 243, 98, 243, 148, 239, 255, 239, 202, 239, 128, 9, 209, 7, 50, 10, 121, 0, 57, 5, 91, 6, 91, 7, 27, 3, 112, 2, 72, 244, 138, 254, 112, 251, 42, 0, 180, 254, 103, 254, 64, 2, 75, 252, 99, 0, 174, 4, 245, 3, 126, 4, 92, 2, 88, 1, 231, 7, 13, 4, 100, 0, 65, 0, 134, 1, 60, 0, 107, 0, 149, 255, 15, 243, 185, 243, 164, 242, 71, 243, 243, 242, 249, 247, 138, 247, 83, 246, 137, 252, 252, 245, 231, 240, 190, 239, 218, 242, 140, 244, 64, 244, 13, 248, 237, 243, 155, 238, 232, 238, 245, 239, 177, 237, 211, 237, 225, 236, 6, 241, 190, 238, 175, 238, 225, 253, 78, 241, 44, 242, 35, 0, 231, 3, 173, 1, 89, 1, 128, 2, 201, 242, 120, 243, 178, 241, 188, 253, 94, 254, 98, 255, 44, 0, 10, 0, 35, 254, 176, 245, 155, 254, 114, 252, 182, 0, 223, 234, 47, 236, 251, 236, 29, 235, 142, 235, 33, 235, 74, 235, 229, 237, 118, 235, 108, 238, 6, 236, 167, 235, 91, 242, 43, 0, 247, 235, 45, 238, 255, 240, 64, 238, 221, 238, 83, 236, 195, 236, 23, 236, 104, 243, 128, 241, 254, 247, 1, 232, 198, 238, 80, 239, 135, 237, 63, 236, 213, 236, 222, 236, 254, 236, 211, 236, 12, 236, 152, 237, 102, 239, 206, 236, 172, 235, 177, 236, 247, 235, 146, 238, 213, 236, 118, 240, 57, 10, 4, 10, 18, 10, 0, 9, 211, 6, 233, 11, 5, 14, 165, 11, 51, 13, 169, 12, 101, 13, 75, 12, 14, 0, 248, 241, 17, 3, 117, 5, 153, 7, 220, 5, 174, 9, 84, 10, 174, 9, 20, 8, 48, 235, 4, 237, 38, 236, 20, 247, 110, 240, 205, 239, 104, 6, 25, 0, 204, 237, 168, 237, 84, 5, 57, 243, 32, 0, 110, 10, 65, 10, 244, 240, 59, 0, 65, 241, 19, 239, 80, 238, 179, 253, 197, 242, 90, 239, 215, 238, 181, 238, 41, 13, 104, 11, 141, 7, 199, 8, 89, 9, 46, 9, 248, 2, 61, 238, 74, 239, 225, 239, 85, 239, 171, 240, 96, 239, 83, 254, 180, 244, 86, 254, 143, 254, 0, 0, 73, 246, 238, 11, 226, 11, 235, 9, 253, 10, 113, 9, 63, 12, 206, 12, 170, 9, 68, 10, 145, 9, 59, 12, 38, 11, 66, 12, 66, 9, 18, 10, 114, 9, 91, 14, 237, 13, 214, 13, 76, 14, 126, 12, 169, 13, 193, 12, 60, 11, 19, 12, 142, 12, 61, 246, 172, 243, 53, 242, 24, 239, 171, 240, 140, 240, 247, 241, 171, 241, 235, 239, 55, 239, 209, 238, 131, 238, 219, 244, 10, 239, 116, 247, 215, 237, 120, 238, 115, 238, 179, 5, 249, 3, 94, 8, 118, 241, 65, 254, 84, 244, 242, 7, 201, 4, 165, 255, 253, 238, 100, 241, 200, 242, 83, 12, 21, 12, 164, 11, 183, 10, 88, 8, 41, 10, 145, 7, 123, 10, 6, 12, 82, 12, 187, 241, 107, 2, 110, 252, 84, 246, 41, 3, 186, 10, 205, 8, 33, 8, 87, 242, 113, 236, 40, 236, 171, 235, 178, 236, 182, 236, 132, 237, 188, 235, 41, 236, 1, 237, 83, 237, 195, 235, 182, 236, 196, 235, 206, 235, 64, 236, 34, 253, 39, 0, 195, 237, 200, 238, 179, 239, 52, 239, 161, 237, 40, 236, 229, 236, 251, 236, 81, 243, 91, 244, 84, 243, 144, 241, 6, 243, 101, 243, 132, 243, 105, 242, 55, 241, 7, 239, 15, 239, 2, 239, 131, 238, 207, 239, 155, 238, 223, 239, 73, 239, 19, 240, 79, 239, 1, 238, 198, 235, 97, 240, 182, 239, 99, 242, 57, 237, 132, 236, 240, 236, 37, 239, 84, 238, 75, 240, 50, 9, 250, 10, 25, 8, 121, 7, 15, 1, 168, 2, 39, 2, 80, 3, 247, 4, 73, 6, 205, 4, 200, 1, 41, 7, 114, 8, 24, 240, 3, 0, 11, 240, 204, 1, 216, 4, 139, 2, 34, 0, 64, 8, 231, 8, 63, 6, 45, 6, 82, 4, 137, 236, 96, 238, 245, 236, 172, 236, 65, 238, 250, 239, 118, 254, 21, 244, 20, 239, 85, 240, 247, 0, 217, 241, 20, 254, 134, 254, 88, 255, 139, 244, 114, 244, 12, 243, 229, 246, 27, 244, 165, 235, 103, 0, 100, 246, 191, 255, 6, 234, 6, 238, 208, 240, 94, 2, 160, 3, 121, 251, 136, 254, 215, 253, 181, 251, 31, 255, 18, 1, 30, 2, 5, 247, 181, 249, 122, 236, 70, 239, 93, 243, 245, 236, 129, 253, 191, 251, 234, 253, 182, 247, 116, 245, 181, 241, 78, 241, 31, 240, 119, 239, 98, 238, 49, 240, 74, 239, 86, 239, 134, 240, 129, 239, 86, 236, 203, 234, 33, 236, 81, 254, 166, 236, 10, 248, 243, 235, 149, 235, 140, 243, 44, 238, 226, 247, 251, 1, 90, 238, 7, 233, 174, 238, 38, 254, 133, 253, 167, 253, 21, 243, 247, 251, 165, 239, 241, 238, 37, 239, 145, 241, 87, 238, 236, 238, 144, 237, 101, 240, 191, 239, 31, 238, 70, 235, 198, 235, 202, 234, 7, 236, 241, 235, 102, 235, 124, 235, 68, 236, 151, 236, 47, 238, 211, 236, 70, 236, 144, 237, 178, 236, 25, 239, 237, 234, 1, 236, 91, 235, 238, 236, 155, 235, 84, 236, 225, 250, 170, 253, 218, 250, 33, 249, 73, 244, 73, 235, 123, 235, 7, 235, 59, 236, 55, 239, 74, 236, 24, 239, 210, 237, 237, 234, 28, 235, 11, 251, 108, 239, 205, 254, 170, 10, 63, 0, 89, 0, 234, 9, 208, 1, 159, 239, 108, 241, 212, 253, 174, 254, 18, 244, 1, 1, 119, 0, 26, 7, 13, 9, 72, 1, 12, 9, 93, 254, 201, 252, 46, 254, 52, 0, 45, 0, 52, 0, 157, 243, 52, 241, 222, 241, 178, 245, 252, 244, 180, 239, 194, 239, 139, 245, 3, 243, 123, 245, 26, 236, 177, 237, 175, 239, 248, 238, 197, 243, 158, 239, 157, 240, 81, 241, 160, 240, 134, 242, 223, 244, 24, 245, 224, 240, 17, 245, 109, 245, 10, 243, 61, 240, 227, 6, 199, 0, 67, 245, 118, 245, 158, 244, 5, 247, 79, 242, 182, 237, 222, 237, 241, 237, 188, 236, 17, 247, 191, 238, 127, 244, 96, 247, 136, 245, 3, 244, 110, 239, 77, 241, 179, 239, 224, 239, 199, 252, 150, 240, 138, 242, 27, 247, 234, 245, 147, 243, 138, 3, 48, 253, 131, 5, 166, 251, 28, 244, 23, 242, 134, 242, 88, 243, 9, 240, 46, 240, 132, 238, 120, 239, 165, 241, 20, 240, 35, 242, 112, 238, 87, 238, 168, 240, 118, 239, 198, 240, 120, 238, 252, 238, 51, 243, 185, 241, 177, 242, 86, 242, 229, 241, 204, 242, 215, 243, 96, 243, 93, 241, 252, 239, 225, 240, 170, 240, 234, 243, 13, 244, 63, 243, 148, 242, 187, 244, 3, 246, 214, 240, 216, 239, 16, 239, 125, 237, 47, 241, 254, 236, 59, 239, 220, 239, 163, 240, 224, 242, 243, 237, 143, 237, 217, 238, 25, 238, 241, 237, 91, 237, 95, 239, 30, 242, 91, 241, 137, 240, 22, 236, 79, 245, 66, 236, 187, 234, 61, 237, 147, 234, 243, 254, 87, 234, 143, 233, 237, 240, 184, 239, 196, 240, 113, 239, 30, 239, 210, 239, 245, 236, 237, 238, 201, 237, 176, 236, 105, 237, 210, 238, 6, 237, 122, 236, 215, 236, 158, 238, 65, 237, 179, 238, 98, 237, 121, 238, 208, 236, 222, 238, 214, 240, 217, 239, 179, 238, 13, 242, 81, 238, 27, 240, 70, 239, 0, 239, 190, 238, 194, 241, 197, 243, 161, 242, 182, 240, 114, 240, 210, 242, 134, 240, 131, 241, 164, 240, 91, 241, 106, 246, 249, 243, 171, 245, 157, 248, 143, 255, 83, 250, 214, 243, 57, 244, 224, 247, 234, 245, 198, 243, 153, 244, 129, 251, 82, 247, 116, 252, 173, 240, 229, 248, 125, 253, 43, 250, 59, 253, 132, 245, 231, 241, 63, 250, 228, 248, 247, 0, 207, 255, 112, 253, 36, 1, 167, 0, 187, 1, 25, 251, 173, 255, 55, 254, 170, 0, 71, 1, 97, 1, 253, 237, 49, 2, 85, 237, 152, 0, 216, 3, 7, 1, 43, 250, 119, 246, 85, 250, 111, 239, 140, 245, 17, 248, 186, 246, 166, 245, 222, 237, 139, 1, 70, 253, 30, 252, 75, 240, 177, 239, 108, 235, 163, 238, 114, 252, 194, 245, 130, 238, 136, 243, 13, 237, 106, 237, 218, 236, 186, 236, 67, 236, 224, 237, 210, 255, 40, 238, 79, 251, 254, 246, 22, 238, 149, 255, 209, 238, 57, 237, 109, 238, 174, 237, 192, 237, 134, 237, 139, 250, 121, 241, 142, 250, 210, 250, 163, 252, 32, 237, 187, 237, 163, 238, 182, 236, 63, 240, 118, 239, 97, 244, 22, 242, 5, 237, 60, 237, 211, 237, 110, 236, 190, 243, 46, 1, 122, 253, 206, 255, 131, 244, 237, 255, 249, 255, 46, 2, 107, 238, 28, 241, 40, 236, 145, 238, 225, 233, 245, 251, 209, 243, 171, 254, 205, 250, 166, 248, 2, 2, 10, 255, 207, 252, 176, 255, 139, 238, 230, 245, 211, 242, 168, 255, 161, 255, 234, 253, 253, 242, 88, 1, 115, 239, 195, 245, 58, 0, 66, 236, 66, 2, 139, 1, 183, 1, 207, 255, 155, 0, 14, 1, 66, 2, 158, 1, 14, 2, 254, 0, 138, 1, 50, 1, 241, 1, 205, 1, 31, 2, 137, 242, 63, 253, 6, 241, 113, 1, 215, 255, 148, 253, 16, 0, 218, 255, 224, 0, 121, 2, 196, 1, 2, 2, 35, 255, 17, 2, 134, 3, 232, 255, 85, 0, 167, 0, 143, 0, 130, 0, 164, 0, 211, 255, 83, 0, 195, 255, 236, 0, 17, 0, 174, 0, 195, 255, 209, 255, 197, 255, 229, 1, 94, 2, 102, 2, 208, 0, 178, 1, 10, 1, 250, 0, 68, 1, 217, 0, 249, 255, 73, 1, 196, 0, 40, 254, 67, 0, 248, 255, 157, 255, 236, 255, 124, 1, 60, 1, 164, 1, 81, 1, 229, 0, 246, 255, 171, 255, 214, 255, 129, 0, 99, 0, 252, 1, 169, 0, 154, 1, 172, 241, 255, 244, 142, 238, 174, 240, 17, 243, 94, 1, 177, 255, 172, 235, 190, 247, 110, 240, 232, 1, 203, 247, 171, 237, 245, 235, 45, 240, 218, 238, 246, 235, 234, 236, 193, 236, 156, 238, 192, 240, 202, 238, 240, 0, 120, 0, 22, 1, 82, 1, 116, 1, 67, 2, 206, 0, 32, 0, 32, 0, 44, 0, 105, 0, 115, 0, 42, 1, 117, 0, 194, 0, 113, 0, 250, 0, 78, 0, 121, 0, 115, 0, 94, 0, 32, 1, 216, 255, 228, 255, 72, 1, 100, 1, 181, 1, 182, 235, 129, 235, 141, 237, 198, 233, 94, 234, 117, 234, 225, 235, 152, 1, 171, 1, 203, 1, 50, 1, 210, 255, 207, 0, 200, 255, 182, 255, 19, 0, 21, 1, 97, 0, 215, 1, 44, 0, 48, 0, 0, 235, 233, 0, 254, 253, 72, 0, 157, 0, 142, 0, 3, 234, 105, 234, 155, 233, 19, 234, 33, 235, 118, 0, 153, 252, 165, 240, 244, 238, 40, 241, 30, 239, 64, 239, 21, 239, 81, 242, 22, 244, 86, 242, 100, 243, 65, 243, 215, 245, 31, 242, 147, 242, 240, 241, 115, 239, 81, 241, 56, 242, 118, 241, 246, 240, 255, 240, 219, 240, 55, 239, 80, 235, 7, 235, 79, 236, 53, 234, 179, 236, 166, 234, 114, 234, 181, 239, 212, 238, 176, 238, 238, 238, 213, 237, 70, 239, 79, 247, 93, 239, 83, 239, 149, 239, 252, 240, 30, 237, 68, 238, 244, 239, 11, 240, 107, 239, 139, 236, 183, 238, 138, 237, 70, 239, 107, 240, 132, 240, 186, 240, 225, 243, 174, 243, 46, 245, 124, 244, 247, 242, 204, 241, 166, 243, 255, 242, 25, 242, 103, 241, 72, 249, 99, 242, 193, 241, 161, 242, 88, 241, 163, 239, 34, 240, 215, 240, 11, 241, 228, 242, 251, 247, 21, 245, 106, 242, 230, 241, 194, 241, 76, 243, 42, 244, 202, 239, 206, 241, 62, 241, 222, 239, 126, 241, 52, 244, 90, 243, 163, 243, 223, 243, 173, 242, 16, 243, 162, 243, 195, 245, 221, 255, 164, 251, 49, 0, 190, 255, 41, 0, 107, 248, 175, 255, 228, 255, 236, 255, 220, 255, 191, 255, 233, 255, 213, 255, 70, 0, 47, 0, 40, 0, 84, 230, 109, 234, 252, 255, 204, 242, 97, 243, 121, 240, 226, 255, 241, 255, 190, 255, 193, 255, 119, 237, 176, 237, 84, 238, 59, 237, 249, 236, 61, 236, 27, 238, 223, 239, 250, 236, 212, 232, 160, 237, 119, 236, 190, 234, 217, 234, 21, 234, 46, 234, 90, 236, 179, 237, 234, 255, 53, 0, 223, 255, 243, 253, 107, 5, 190, 0, 79, 247, 28, 0, 88, 242, 237, 235, 44, 236, 144, 238, 148, 239, 8, 234, 23, 236, 101, 248, 216, 234, 136, 245, 154, 242, 34, 234, 157, 245, 149, 233, 251, 236, 29, 233, 156, 250, 245, 250, 133, 232, 115, 233, 230, 232, 72, 234, 190, 233, 218, 236, 85, 233, 82, 233, 91, 234, 59, 236, 239, 235, 104, 236, 247, 255, 95, 242, 66, 0, 212, 255, 29, 0, 66, 245, 135, 235, 148, 233, 183, 234, 139, 234, 121, 235, 80, 250, 186, 240, 132, 234, 192, 240, 54, 231, 116, 235, 89, 243, 247, 237, 166, 238, 208, 240, 23, 240, 181, 239, 42, 238, 95, 241, 4, 244, 73, 242, 47, 242, 89, 241, 130, 242, 241, 241, 146, 241, 170, 239, 162, 240, 232, 245, 128, 242, 39, 244, 200, 244, 34, 241, 63, 243, 206, 242, 200, 240, 224, 239, 19, 240, 26, 241, 150, 241, 8, 241, 224, 242, 52, 240, 113, 242, 124, 244, 80, 236, 46, 238, 219, 235, 62, 238, 200, 237, 212, 235, 192, 237, 64, 237, 114, 238, 177, 243, 215, 243, 13, 245, 115, 244, 133, 240, 54, 243, 177, 238, 244, 240, 116, 239, 175, 243, 83, 238, 186, 237, 23, 243, 66, 237, 170, 237, 50, 238, 26, 236, 221, 236, 193, 235, 180, 236, 233, 237, 208, 238, 174, 235, 251, 235, 171, 235, 193, 237, 184, 236, 240, 236, 50, 237, 135, 236, 234, 236, 176, 236, 136, 236, 217, 235, 253, 234, 12, 235, 161, 234, 213, 235, 185, 235, 3, 236, 51, 240, 110, 240, 241, 240, 153, 241, 174, 240, 204, 234, 22, 235, 0, 235, 140, 235, 133, 236, 25, 244, 168, 251, 255, 255, 232, 236, 161, 235, 252, 238, 112, 236, 243, 244, 187, 234, 77, 235, 236, 236, 74, 236, 80, 237, 25, 233, 189, 233, 8, 233, 184, 232, 40, 235, 1, 233, 129, 235, 142, 245, 246, 244, 77, 244, 115, 243, 175, 236, 20, 239, 245, 234, 97, 239, 250, 233, 247, 237, 116, 243, 114, 236, 161, 240, 213, 235, 235, 236, 55, 236, 69, 240, 160, 247, 147, 237, 166, 245, 244, 235, 151, 236, 176, 239, 137, 235, 67, 235, 17, 236, 207, 235, 175, 235, 236, 233, 218, 243, 0, 234, 197, 236, 150, 242, 3, 240, 220, 242, 213, 242, 2, 240, 94, 248, 141, 239, 240, 238, 138, 239, 94, 238, 38, 240, 22, 240, 55, 236, 150, 235, 157, 238, 3, 237, 254, 236, 28, 238, 152, 239, 14, 239, 166, 239, 253, 238, 215, 234, 230, 233, 82, 237, 72, 235, 152, 235, 56, 235, 244, 240, 163, 236, 126, 237, 148, 238, 22, 239, 111, 236, 98, 237, 193, 237, 183, 242, 28, 235, 47, 238, 177, 237, 87, 244, 233, 236, 37, 236, 82, 237, 105, 235, 234, 255, 180, 244, 146, 240, 249, 239, 204, 240, 61, 238, 34, 237, 63, 234, 206, 234, 11, 236, 67, 234, 47, 235, 239, 234, 75, 242, 231, 248, 251, 246, 85, 237, 247, 4, 228, 3, 49, 4, 80, 4, 160, 4, 22, 4, 176, 3, 139, 5, 63, 5, 72, 4, 154, 4, 145, 5, 24, 5, 102, 4, 247, 4, 101, 4, 118, 5, 126, 6, 21, 4, 4, 5, 209, 4, 85, 5, 149, 4, 7, 4, 89, 4, 220, 3, 161, 246, 140, 240, 94, 234, 153, 235, 255, 237, 240, 235, 57, 237, 3, 235, 81, 234, 236, 234, 54, 234, 218, 234, 36, 234, 154, 233, 117, 0, 134, 247, 10, 0, 71, 239, 37, 240, 11, 243, 183, 239, 37, 239, 224, 236, 202, 234, 195, 235, 162, 236, 227, 255, 122, 5, 213, 1, 29, 252, 77, 248, 53, 0, 76, 240, 123, 244, 141, 4, 206, 4, 140, 234, 45, 236, 231, 234, 21, 235, 17, 237, 178, 1, 6, 240, 41, 240, 153, 241, 243, 235, 15, 236, 94, 237, 138, 236, 43, 2, 232, 0, 171, 240, 28, 0, 92, 0, 106, 252, 169, 237, 128, 237, 202, 238, 56, 236, 18, 237, 32, 239, 33, 237, 188, 237, 78, 236, 105, 237, 102, 236, 123, 1, 158, 1, 166, 1, 215, 1, 219, 1, 58, 2, 40, 5, 30, 4, 42, 4, 245, 2, 50, 5, 236, 1, 54, 2, 166, 1, 187, 1, 157, 1, 179, 6, 37, 4, 84, 7, 149, 2, 17, 4, 30, 5, 21, 8, 79, 6, 58, 7, 115, 5, 102, 4, 142, 1, 231, 1, 180, 3, 177, 5, 97, 5, 222, 6, 78, 240, 210, 243, 56, 0, 80, 250, 232, 249, 25, 0, 234, 0, 110, 4, 181, 4, 110, 4, 115, 5, 191, 4, 168, 5, 247, 3, 114, 6, 97, 5, 142, 2, 58, 1, 77, 5, 14, 1, 101, 2, 4, 1, 6, 2, 43, 0, 142, 5, 215, 1, 43, 7, 236, 6, 169, 1, 253, 239, 145, 243, 36, 241, 233, 243, 13, 255, 187, 0, 96, 0, 25, 0, 208, 1, 248, 0, 9, 1, 9, 2, 145, 1, 106, 1, 134, 2, 172, 2, 127, 2, 170, 1, 252, 1, 167, 1, 183, 2, 240, 1, 247, 1, 115, 2, 107, 2, 116, 4, 101, 4, 212, 2, 82, 6, 149, 3, 95, 238, 39, 239, 7, 0, 81, 245, 133, 252, 228, 242, 131, 0, 245, 2, 100, 1, 110, 2, 114, 2, 51, 2, 126, 1, 69, 1, 134, 0, 140, 0, 225, 0, 34, 1, 80, 1, 89, 1, 28, 1, 235, 0, 169, 1, 118, 1, 125, 0, 81, 1, 226, 1, 6, 2, 251, 2, 41, 2, 134, 3, 97, 2, 26, 3, 74, 2, 129, 2, 189, 1, 142, 7, 67, 2, 153, 2, 79, 2, 88, 1, 54, 1, 62, 1, 35, 3, 125, 1, 57, 2, 59, 1, 40, 1, 196, 0, 95, 2, 107, 1, 84, 2, 79, 1, 178, 1, 239, 1, 102, 1, 52, 2, 37, 1, 101, 1, 28, 1, 72, 1, 149, 1, 74, 2, 254, 1, 177, 2, 187, 1, 227, 1, 193, 1, 163, 1, 250, 1, 204, 1, 163, 5, 162, 4, 119, 4, 158, 4, 72, 7, 136, 7, 132, 2, 220, 2, 242, 1, 255, 2, 41, 7, 106, 4, 156, 2, 90, 4, 57, 4, 89, 2, 51, 3, 29, 3, 163, 6, 5, 3, 82, 6, 37, 2, 118, 2, 108, 2, 154, 2, 163, 1, 131, 1, 128, 1, 191, 2, 239, 2, 53, 2, 182, 1, 208, 2, 69, 3, 242, 3, 140, 1, 30, 2, 107, 2, 220, 2, 184, 2, 197, 1, 204, 2, 163, 1, 198, 239, 150, 242, 183, 243, 114, 242, 69, 246, 2, 4, 7, 1, 60, 1, 240, 1, 144, 2, 201, 255, 30, 251, 71, 3, 137, 4, 0, 0, 255, 1, 9, 2, 203, 2, 3, 2, 40, 0, 103, 1, 61, 0, 200, 2, 6, 2, 218, 1, 198, 1, 0, 2, 105, 2, 77, 1, 214, 1, 199, 1, 225, 1, 244, 2, 161, 1, 48, 2, 67, 1, 79, 1, 160, 1, 104, 1, 150, 1, 209, 236, 133, 236, 49, 237, 242, 236, 146, 238, 69, 243, 210, 243, 205, 255, 159, 255, 109, 0, 154, 242, 12, 240, 43, 249, 169, 0, 90, 240, 157, 240, 158, 2, 213, 255, 194, 0, 195, 239, 96, 248, 38, 240, 218, 241, 124, 255, 125, 245, 178, 241, 221, 248, 247, 242, 212, 241, 128, 233, 57, 232, 215, 232, 121, 248, 194, 234, 13, 253, 26, 232, 54, 232, 142, 245, 157, 240, 75, 241, 108, 242, 198, 239, 193, 244, 85, 243, 173, 244, 52, 245, 113, 242, 154, 241, 19, 3, 30, 2, 182, 5, 57, 5, 161, 0, 101, 1, 46, 1, 191, 0, 84, 255, 177, 1, 101, 3, 168, 1, 138, 1, 120, 4, 223, 243, 82, 255, 215, 238, 43, 0, 208, 255, 52, 0, 166, 255, 174, 255, 124, 255, 165, 1, 41, 2, 197, 0, 49, 239, 34, 0, 127, 255, 159, 255, 134, 255, 162, 240, 166, 255, 105, 255, 81, 246, 8, 255, 209, 5, 191, 255, 249, 2, 47, 1, 112, 255, 90, 255, 137, 255, 135, 255, 189, 239, 164, 240, 158, 239, 184, 241, 44, 240, 44, 241, 228, 242, 83, 245, 23, 246, 244, 241, 168, 242, 69, 241, 235, 244, 10, 244, 70, 241, 156, 242, 75, 242, 178, 243, 28, 241, 244, 241, 26, 240, 159, 239, 2, 239, 44, 236, 117, 235, 136, 234, 155, 235, 210, 234, 236, 233, 167, 243, 217, 242, 128, 241, 225, 233, 168, 238, 140, 239, 62, 240, 178, 245, 108, 237, 220, 237, 97, 240, 67, 237, 172, 236, 54, 239, 248, 238, 207, 236, 172, 236, 72, 235, 97, 236, 157, 236, 178, 242, 76, 238, 29, 238, 209, 235, 62, 236, 132, 237, 6, 244, 106, 242, 10, 240, 32, 241, 47, 242, 183, 240, 226, 239, 221, 238, 32, 239, 154, 238, 164, 238, 249, 238, 162, 237, 104, 239, 219, 238, 121, 239, 73, 239, 150, 238, 78, 238, 2, 240, 135, 239, 213, 239, 251, 240, 175, 241, 108, 239, 190, 240, 211, 239, 149, 240, 79, 238, 148, 243, 69, 242, 150, 245, 205, 243, 147, 240, 239, 241, 43, 242, 102, 242, 21, 0, 149, 0, 109, 0, 57, 0, 253, 0, 192, 0, 254, 1, 29, 1, 32, 1, 77, 1, 82, 1, 219, 0, 225, 0, 37, 1, 25, 1, 77, 1, 89, 1, 208, 1, 88, 1, 161, 1, 252, 1, 0, 1, 73, 1, 211, 2, 111, 0, 169, 0, 74, 0, 114, 3, 157, 2, 45, 3, 32, 2, 99, 4, 159, 0, 122, 1, 111, 1, 76, 0, 35, 1, 68, 0, 61, 1, 179, 1, 157, 2, 74, 2, 113, 0, 222, 0, 104, 0, 124, 0, 119, 0, 195, 0, 212, 241, 34, 239, 30, 0, 133, 242, 156, 243, 204, 246, 233, 255, 230, 2, 3, 3, 237, 1, 57, 2, 208, 3, 45, 3, 43, 3, 116, 1, 248, 2, 123, 2, 185, 3, 219, 3, 3, 1, 193, 3, 24, 3, 245, 2, 58, 3, 186, 2, 80, 1, 25, 2, 139, 0, 102, 0, 194, 0, 148, 1, 141, 1, 233, 2, 168, 1, 68, 1, 26, 2, 109, 1, 142, 1, 210, 0, 196, 1, 222, 2, 188, 2, 110, 2, 194, 1, 178, 244, 168, 233, 28, 235, 59, 236, 230, 232, 218, 237, 162, 236, 181, 235, 103, 235, 216, 235, 175, 236, 201, 235, 158, 235, 12, 234, 150, 234, 150, 235, 10, 236, 243, 235, 198, 235, 114, 235, 205, 235, 153, 234, 95, 239, 232, 241, 57, 239, 206, 238, 201, 237, 155, 255, 33, 252, 182, 240, 144, 246, 65, 240, 202, 247, 2, 245, 33, 241, 93, 238, 198, 238, 214, 250, 176, 239, 161, 247, 88, 239, 86, 240, 100, 239, 73, 238, 180, 6, 84, 0, 152, 0, 69, 0, 23, 0, 225, 234, 65, 252, 225, 255, 118, 255, 3, 243, 31, 0, 75, 0, 133, 2, 123, 3, 76, 0, 254, 0, 186, 255, 245, 0, 8, 0, 7, 0, 95, 0, 24, 0, 113, 237, 224, 237, 2, 237, 140, 236, 65, 236, 78, 255, 34, 244, 50, 245, 95, 243, 79, 241, 185, 234, 222, 235, 116, 235, 238, 235, 103, 238, 13, 238, 66, 237, 107, 236, 223, 232, 221, 237, 236, 233, 242, 233, 50, 238, 144, 236, 191, 236, 184, 235, 27, 239, 228, 234, 67, 237, 116, 235, 28, 234, 66, 235, 20, 234, 3, 242, 222, 234, 175, 234, 145, 234, 167, 234, 106, 235, 228, 234, 179, 239, 199, 237, 46, 238, 190, 237, 45, 237, 222, 238, 4, 237, 246, 233, 30, 235, 197, 234, 158, 236, 110, 236, 86, 238, 236, 234, 58, 236, 54, 235, 183, 235, 157, 236, 98, 237, 79, 236, 86, 236, 160, 234, 15, 236, 89, 236, 248, 236, 7, 239, 8, 237, 208, 237, 80, 238, 9, 238, 233, 238, 231, 237, 163, 240, 218, 235, 112, 235, 117, 235, 179, 237, 15, 235, 203, 236, 190, 237, 75, 236, 171, 234, 17, 236, 191, 239, 106, 239, 64, 237, 20, 237, 198, 235, 180, 236, 212, 236, 183, 234, 237, 236, 64, 235, 203, 245, 100, 235, 226, 235, 14, 235, 112, 234, 189, 235, 139, 234, 111, 235, 250, 234, 64, 240, 20, 234, 253, 234, 14, 235, 181, 234, 174, 235, 19, 235, 177, 234, 251, 237, 73, 239, 99, 238, 34, 238, 225, 237, 46, 241, 197, 239, 226, 239, 221, 239, 120, 242, 209, 239, 167, 238, 37, 236, 132, 238, 205, 237, 107, 237, 70, 242, 210, 240, 245, 240, 129, 239, 245, 239, 172, 238, 134, 246, 107, 245, 52, 242, 156, 244, 246, 239, 180, 245, 135, 244, 131, 239, 71, 240, 134, 239, 105, 242, 39, 241, 247, 240, 212, 239, 121, 238, 234, 240, 106, 242, 130, 242, 201, 242, 201, 241, 181, 244, 183, 243, 96, 244, 89, 243, 50, 244, 59, 245, 174, 243, 165, 241, 120, 246, 151, 245, 90, 240, 84, 239, 154, 238, 201, 239, 68, 240, 87, 241, 198, 241, 237, 242, 205, 240, 90, 242, 249, 237, 94, 238, 64, 239, 43, 238, 247, 238, 68, 237, 74, 241, 234, 240, 67, 240, 224, 243, 91, 240, 191, 238, 225, 242, 148, 245, 146, 243, 42, 243, 219, 241, 177, 239, 231, 242, 184, 240, 197, 241, 2, 243, 122, 243, 217, 241, 153, 243, 45, 245, 65, 245, 198, 243, 75, 245, 84, 243, 190, 238, 145, 238, 174, 238, 137, 239, 112, 238, 215, 240, 238, 237, 191, 241, 133, 239, 78, 240, 172, 238, 146, 236, 79, 241, 205, 241, 70, 239, 168, 240, 202, 240, 142, 242, 82, 241, 63, 238, 128, 240, 194, 236, 65, 239, 241, 239, 18, 244, 101, 238, 67, 238, 68, 248, 79, 252, 191, 244, 137, 242, 25, 240, 170, 240, 96, 240, 166, 240, 234, 239, 248, 255, 124, 246, 183, 238, 231, 239, 33, 243, 216, 239, 118, 239, 22, 239, 144, 238, 117, 240, 125, 243, 98, 244, 247, 243, 57, 244, 24, 245, 51, 243, 200, 242, 184, 242, 32, 244, 144, 241, 133, 242, 150, 242, 105, 242, 246, 241, 244, 242, 65, 244, 216, 240, 220, 243, 213, 243, 111, 241, 60, 242, 221, 241, 139, 240, 136, 241, 89, 241, 128, 242, 151, 242, 156, 243, 169, 240, 5, 240, 107, 240, 59, 240, 124, 240, 242, 240, 127, 240, 99, 240, 213, 239, 206, 239, 69, 241, 138, 240, 58, 241, 174, 241, 105, 243, 95, 240, 138, 241, 177, 241, 173, 238, 230, 236, 180, 237, 74, 237, 68, 236, 209, 236, 105, 236, 107, 235, 26, 237, 246, 236, 216, 236, 196, 236, 170, 235, 195, 233, 223, 235, 183, 233, 155, 239, 185, 234, 4, 234, 62, 235, 48, 235, 72, 235, 147, 243, 215, 241, 43, 242, 210, 243, 67, 242, 3, 241, 102, 240, 217, 242, 201, 240, 175, 240, 226, 240, 136, 241, 247, 239, 73, 238, 168, 240, 138, 238, 77, 238, 10, 239, 87, 243, 60, 242, 130, 250, 16, 241, 104, 238, 165, 239, 210, 238, 198, 239, 67, 238, 239, 235, 99, 236, 132, 238, 8, 236, 64, 237, 93, 237, 187, 238, 67, 240, 93, 240, 245, 238, 217, 239, 52, 239, 161, 238, 129, 240, 41, 241, 151, 240, 84, 238, 15, 237, 223, 238, 25, 238, 110, 236, 177, 236, 106, 239, 248, 239, 134, 240, 92, 240, 29, 240, 67, 236, 25, 236, 93, 236, 130, 236, 124, 237, 104, 239, 95, 238, 246, 236, 253, 242, 136, 238, 146, 245, 197, 247, 153, 0, 247, 255, 55, 250, 93, 6, 65, 0, 31, 255, 52, 241, 205, 249, 239, 243, 124, 233, 201, 238, 155, 236, 61, 239, 13, 243, 220, 241, 1, 0, 20, 242, 72, 245, 204, 251, 73, 248, 159, 247, 72, 244, 119, 247, 40, 245, 54, 0, 79, 249, 106, 247, 158, 252, 83, 11, 101, 0, 228, 2, 116, 248, 19, 253, 133, 0, 204, 255, 210, 255, 222, 255, 218, 255, 22, 0, 12, 0, 20, 0, 154, 255, 15, 0, 250, 255, 11, 239, 49, 240, 43, 244, 88, 254, 129, 233, 142, 232, 12, 236, 111, 241, 18, 244, 178, 244, 111, 245, 163, 238, 238, 249, 25, 236, 188, 238, 251, 239, 51, 238, 53, 246, 126, 239, 100, 244, 160, 241, 0, 240, 112, 243, 15, 237, 161, 247, 167, 243, 203, 255, 129, 0, 83, 0, 224, 8, 114, 254, 28, 241, 42, 245, 167, 242, 232, 241, 36, 242, 58, 238, 9, 239, 142, 237, 77, 238, 194, 238, 244, 240, 99, 239, 108, 240, 98, 242, 20, 239, 87, 239, 14, 243, 173, 243, 223, 255, 5, 0, 77, 244, 165, 244, 11, 245, 106, 242, 34, 240, 144, 251, 179, 241, 196, 242, 44, 244, 38, 232, 7, 248, 202, 237, 88, 238, 47, 239, 96, 239, 200, 234, 104, 235, 41, 234, 11, 237, 160, 237, 9, 233, 173, 235, 26, 253, 11, 243, 79, 238, 237, 241, 186, 242, 135, 252, 193, 241, 185, 235, 12, 235, 15, 243, 38, 246, 242, 236, 23, 249, 168, 245, 208, 247, 91, 244, 248, 234, 218, 235, 247, 238, 38, 250, 249, 253, 165, 243, 125, 245, 245, 237, 150, 245, 117, 242, 21, 246, 148, 250, 177, 245, 252, 253, 195, 255, 161, 254, 141, 250, 225, 241, 30, 242, 124, 239, 255, 247, 127, 243, 240, 244, 173, 242, 70, 238, 5, 239, 155, 242, 172, 239, 23, 244, 233, 245, 132, 243, 247, 243, 218, 246, 241, 243, 164, 243, 220, 237, 208, 239, 42, 244, 32, 244, 160, 243, 113, 0, 121, 255, 71, 246, 234, 237, 153, 243, 28, 247, 147, 246, 33, 236, 59, 232, 58, 234, 17, 235, 131, 233, 214, 234, 119, 232, 26, 234, 177, 231, 134, 233, 108, 232, 194, 232, 174, 237, 226, 238, 212, 234, 176, 244, 223, 239, 117, 243, 17, 236, 17, 233, 210, 233, 95, 233, 250, 249, 203, 245, 97, 232, 33, 251, 94, 237, 214, 233, 6, 234, 162, 239, 24, 235, 250, 246, 12, 234, 9, 236, 152, 235, 13, 234, 30, 234, 41, 233, 126, 234, 72, 234, 115, 239, 35, 239, 223, 234, 160, 235, 216, 235, 233, 232, 1, 234, 186, 233, 129, 234, 40, 234, 190, 234, 204, 233, 95, 236, 62, 239, 120, 235, 195, 237, 75, 233, 18, 234, 197, 234, 187, 233, 100, 234, 79, 234, 107, 236, 88, 238, 71, 238, 48, 242, 177, 239, 172, 238, 253, 239, 30, 239, 51, 236, 61, 231, 204, 234, 115, 235, 71, 233, 55, 245, 119, 234, 246, 233, 48, 234, 249, 247, 152, 234, 157, 234, 17, 240, 79, 236, 252, 239, 20, 245, 114, 240, 18, 235, 31, 236, 47, 235, 15, 234, 65, 238, 142, 242, 32, 243, 224, 237, 76, 238, 144, 1, 132, 248, 253, 253, 21, 251, 239, 248, 2, 247, 40, 247, 161, 246, 127, 246, 61, 241, 251, 244, 169, 0, 201, 245, 23, 1, 57, 254, 199, 244, 222, 240, 102, 254, 39, 236, 130, 238, 83, 238, 44, 239, 105, 240, 5, 236, 77, 236, 44, 239, 124, 238, 123, 239, 0, 238, 220, 238, 48, 245, 136, 241, 123, 241, 83, 243, 211, 238, 207, 241, 123, 239, 124, 239, 104, 239, 5, 239, 178, 232, 92, 233, 123, 232, 165, 232, 146, 232, 84, 238, 176, 236, 86, 241, 216, 237, 91, 244, 42, 239, 23, 240, 72, 236, 108, 236, 160, 248, 55, 234, 0, 241, 146, 236, 74, 239, 80, 238, 10, 248, 238, 233, 238, 242, 145, 239, 108, 243, 26, 249, 172, 248, 224, 237, 145, 244, 118, 240, 234, 239, 186, 239, 84, 238, 86, 249, 196, 242, 110, 244, 54, 246, 96, 244, 35, 246, 66, 248, 218, 240, 188, 242, 187, 239, 107, 240, 27, 241, 65, 245, 166, 239, 36, 236, 35, 240, 38, 238, 171, 240, 212, 244, 55, 239, 242, 239, 95, 239, 43, 238, 94, 238, 117, 238, 178, 237, 65, 243, 200, 239, 239, 238, 215, 242, 247, 238, 105, 240, 221, 239, 113, 240, 234, 238, 218, 238, 167, 0, 84, 244, 223, 242, 81, 248, 252, 255, 96, 0, 191, 241, 106, 241, 142, 241, 112, 239, 103, 246, 121, 238, 175, 239, 148, 246, 21, 243, 44, 242, 13, 240, 118, 246, 83, 239, 52, 0, 90, 0, 217, 255, 5, 0, 4, 3, 14, 0, 28, 0, 8, 241, 3, 242, 124, 243, 53, 242, 116, 241, 54, 243, 160, 244, 18, 1, 193, 1, 13, 1, 103, 2, 38, 2, 250, 0, 17, 0, 5, 3, 182, 255, 181, 255, 163, 255, 240, 255, 167, 252, 39, 245, 132, 245, 210, 246, 227, 239, 92, 3, 255, 249, 166, 2, 60, 8, 169, 255, 6, 240, 19, 238, 1, 239, 192, 239, 94, 247, 201, 246, 20, 249, 158, 243, 26, 239, 52, 0, 235, 249, 135, 0, 60, 3, 178, 239, 215, 248, 165, 248, 239, 244, 38, 249, 120, 247, 218, 255, 234, 255, 188, 255, 194, 0, 6, 0, 107, 255, 173, 255, 144, 253, 243, 255, 186, 247, 96, 0, 222, 3, 93, 5, 64, 1, 152, 0, 253, 4, 174, 0, 206, 0, 200, 0, 200, 0, 13, 1, 201, 255, 188, 0, 252, 3, 125, 3, 167, 3, 5, 0, 24, 245, 114, 239, 194, 255, 131, 252, 97, 253, 161, 251, 116, 255, 219, 255, 18, 1, 1, 0, 53, 239, 188, 239, 169, 255, 169, 236, 79, 251, 224, 248, 92, 253, 200, 255, 8, 0, 243, 2, 62, 0, 201, 255, 31, 0, 117, 5, 252, 255, 130, 0, 246, 255, 97, 252, 234, 255, 126, 249, 188, 255, 52, 0, 235, 255, 10, 0, 204, 255, 141, 255, 69, 239, 60, 0, 192, 244, 18, 240, 48, 245, 62, 0, 236, 255, 104, 0, 65, 0, 95, 0, 210, 255, 54, 255, 184, 255, 201, 255, 215, 255, 64, 1, 0, 0, 187, 255, 50, 2, 49, 3, 203, 1, 25, 1, 91, 6, 84, 11, 102, 1, 203, 2, 247, 7, 148, 1, 166, 1, 135, 6, 27, 9, 203, 7, 96, 5, 153, 9, 215, 5, 35, 7, 230, 10, 58, 8, 38, 8, 157, 3, 128, 0, 181, 0, 160, 20, 74, 2, 68, 4, 221, 4, 45, 7, 128, 19, 50, 20, 92, 19, 8, 12, 145, 19, 136, 19, 219, 20, 114, 19, 103, 17, 147, 17, 37, 8, 56, 14, 190, 4, 3, 4, 60, 4, 186, 4, 218, 21, 249, 9, 153, 20, 205, 3, 45, 3, 47, 7, 21, 6, 54, 11, 167, 5, 203, 14, 100, 6, 37, 4, 163, 16, 66, 5, 10, 7, 4, 5, 248, 5, 232, 18, 232, 19, 203, 20, 214, 17, 45, 19, 122, 16, 160, 10, 209, 17, 181, 10, 25, 9, 50, 12, 124, 14, 105, 9, 186, 3, 194, 3, 2, 16, 14, 9, 41, 20, 200, 10, 10, 15, 50, 18, 166, 4, 238, 3, 55, 5, 219, 3, 113, 8, 143, 4, 62, 3, 21, 3, 221, 3, 18, 245, 21, 247, 64, 241, 229, 240, 133, 241, 234, 255, 32, 251, 140, 244, 249, 250, 145, 245, 141, 244, 75, 247, 76, 243, 180, 244, 224, 241, 198, 242, 45, 245, 202, 243, 77, 244, 10, 242, 170, 243, 170, 242, 19, 3, 6, 17, 77, 1, 255, 6, 215, 7, 8, 15, 109, 18, 254, 0, 116, 0, 208, 6, 32, 15, 153, 16, 153, 1, 212, 2, 193, 6, 165, 4, 137, 1, 103, 4, 113, 3, 186, 9, 144, 5, 104, 7, 196, 0, 57, 1, 214, 1, 210, 0, 227, 0, 161, 1, 187, 0, 187, 2, 28, 1, 237, 0, 184, 1, 255, 1, 237, 21, 94, 18, 7, 5, 196, 19, 43, 0, 253, 2, 70, 0, 38, 1, 111, 0, 134, 0, 43, 0, 99, 8, 170, 0, 70, 246, 73, 247, 7, 9, 62, 0, 37, 0, 147, 5, 201, 2, 154, 248, 226, 246, 13, 246, 43, 0, 78, 1, 247, 255, 5, 0, 50, 250, 186, 255, 136, 255, 99, 255, 151, 255, 186, 255, 7, 0, 152, 255, 170, 255, 79, 255, 250, 255, 23, 0, 59, 0, 159, 255, 219, 255, 185, 255, 125, 0, 69, 0, 5, 0, 124, 0, 50, 0, 159, 0, 96, 255, 129, 255, 250, 255, 209, 255, 152, 255, 234, 255, 166, 255, 133, 255, 112, 255, 14, 1, 80, 1, 92, 1, 178, 1, 159, 1, 23, 2, 75, 1, 104, 1, 45, 1, 65, 2, 187, 1, 146, 2, 69, 1, 132, 1, 79, 1, 198, 1, 212, 1, 148, 1, 59, 0, 37, 0, 13, 0, 59, 1, 8, 1, 44, 1, 142, 0, 73, 0, 229, 0, 106, 1, 46, 1, 21, 1, 39, 255, 59, 255, 67, 255, 208, 255, 146, 2, 56, 0, 79, 2, 43, 3, 138, 1, 200, 0, 226, 0, 25, 1, 34, 1, 30, 1, 119, 1, 143, 255, 141, 0, 231, 255, 95, 2, 25, 2, 62, 2, 145, 1, 188, 1, 97, 2, 150, 1, 13, 2, 227, 1, 16, 0, 43, 1, 27, 1, 194, 255, 226, 0, 70, 0, 245, 255, 80, 0, 223, 1, 142, 1, 178, 1, 166, 1, 69, 1, 191, 0, 126, 255, 229, 0, 247, 0, 115, 1, 173, 0, 72, 1, 230, 0, 193, 235, 106, 235, 7, 235, 220, 235, 222, 235, 192, 236, 213, 234, 46, 235, 9, 235, 110, 236, 113, 236, 78, 236, 70, 236, 213, 236, 89, 236, 79, 236, 22, 237, 144, 235, 40, 241, 20, 239, 185, 240, 109, 235, 121, 238, 148, 237, 236, 237, 143, 238, 44, 237, 125, 235, 20, 236, 72, 235, 27, 241, 97, 240, 34, 238, 254, 245, 67, 240, 96, 251, 35, 236, 78, 237, 138, 236, 232, 255, 58, 255, 241, 255, 232, 241, 37, 250, 234, 244, 175, 255, 155, 255, 101, 255, 87, 236, 27, 236, 243, 235, 4, 236, 12, 236, 246, 235, 187, 236, 80, 236, 162, 237, 32, 241, 170, 238, 73, 237, 17, 0, 40, 2, 92, 0, 100, 0, 56, 1, 224, 1, 236, 1, 54, 1, 95, 1, 149, 244, 122, 253, 25, 247, 213, 255, 168, 255, 132, 255, 8, 0, 205, 255, 234, 255, 33, 0, 48, 255, 184, 255, 127, 0, 211, 255, 69, 0, 61, 255, 59, 255, 95, 255, 68, 0, 24, 0, 104, 0, 88, 236, 183, 237, 164, 236, 197, 236, 143, 237, 181, 255, 209, 255, 194, 255, 108, 250, 64, 242, 43, 243, 208, 238, 125, 241, 67, 245, 172, 254, 80, 241, 215, 247, 56, 239, 124, 246, 161, 248, 204, 244, 227, 245, 143, 246, 106, 246, 151, 240, 11, 247, 89, 240, 200, 242, 179, 242, 7, 243, 204, 242, 248, 242, 127, 242, 23, 244, 19, 243, 87, 244, 252, 238, 146, 239, 132, 239, 82, 242, 168, 239, 123, 241, 168, 239, 196, 239, 215, 241, 232, 244, 2, 241, 46, 242, 193, 246, 44, 244, 174, 244, 63, 245, 9, 245, 176, 249, 41, 243, 24, 243, 173, 242, 45, 255, 58, 255, 34, 0, 150, 246, 30, 255, 6, 247, 229, 255, 96, 255, 149, 250, 224, 245, 200, 242, 164, 242, 99, 242, 65, 242, 144, 242, 125, 241, 251, 241, 237, 241, 163, 243, 218, 242, 131, 242, 113, 254, 195, 255, 205, 247, 156, 255, 172, 255, 174, 255, 60, 255, 121, 255, 87, 0, 226, 242, 183, 245, 216, 251, 159, 252, 42, 247, 108, 246, 104, 255, 98, 250, 153, 255, 49, 255, 12, 255, 237, 254, 95, 0, 59, 0, 169, 0, 247, 254, 51, 254, 223, 254, 135, 255, 239, 254, 64, 255, 151, 243, 66, 241, 75, 242, 202, 242, 158, 241, 143, 254, 46, 250, 192, 254, 197, 253, 16, 243, 11, 240, 100, 240, 246, 239, 174, 243, 76, 244, 125, 241, 158, 241, 24, 240, 115, 0, 34, 1, 18, 0, 166, 1, 33, 1, 131, 0, 144, 0, 122, 1, 227, 0, 93, 1, 198, 0, 212, 1, 145, 2, 5, 2, 98, 0, 137, 1, 113, 1, 16, 2, 244, 254, 8, 1, 253, 255, 76, 3, 55, 251, 188, 255, 205, 255, 91, 254, 173, 255, 74, 255, 54, 1, 64, 255, 155, 0, 226, 254, 157, 0, 14, 1, 188, 0, 57, 0, 138, 255, 142, 0, 222, 255, 212, 255, 160, 255, 47, 255, 62, 254, 140, 255, 233, 254, 105, 1, 30, 0, 135, 255, 125, 254, 122, 2, 65, 2, 136, 1, 7, 2, 219, 2, 240, 1, 228, 1, 120, 1, 105, 1, 26, 1, 211, 0, 212, 1, 201, 1, 40, 1, 143, 2, 123, 1, 82, 0, 40, 0, 164, 255, 190, 255, 92, 0, 194, 1, 41, 0, 4, 1, 111, 1, 185, 255, 178, 255, 27, 2, 157, 254, 230, 1, 177, 2, 174, 2, 111, 0, 19, 0, 178, 254, 91, 1, 27, 1, 249, 0, 65, 1, 244, 0, 200, 1, 168, 0, 6, 1, 127, 0, 90, 0, 111, 0, 172, 0, 50, 0, 70, 0, 4, 0, 191, 0, 114, 0, 208, 0, 95, 1, 46, 1, 70, 0, 123, 0, 108, 0, 79, 3, 247, 255, 56, 0, 23, 0, 82, 1, 45, 1, 142, 0, 56, 237, 179, 237, 229, 237, 37, 237, 150, 237, 213, 236, 55, 239, 75, 238, 224, 238, 17, 237, 232, 236, 140, 236, 121, 237, 203, 236, 196, 237, 139, 236, 182, 236, 33, 237, 160, 255, 152, 245, 199, 255, 208, 239, 157, 240, 60, 241, 109, 251, 184, 240, 204, 239, 138, 237, 225, 237, 138, 238, 7, 250, 117, 244, 195, 244, 207, 249, 18, 245, 215, 244, 248, 250, 188, 249, 67, 0, 24, 0, 222, 255, 18, 0, 225, 247, 39, 253, 51, 246, 234, 255, 187, 255, 160, 255, 40, 238, 62, 238, 79, 237, 91, 247, 125, 238, 166, 237, 167, 240, 42, 239, 62, 244, 196, 250, 111, 250, 188, 246, 221, 255, 80, 252, 189, 255, 241, 255, 220, 255, 137, 238, 33, 242, 159, 240, 234, 238, 157, 250, 253, 255, 205, 255, 230, 255, 58, 252, 223, 244, 69, 246, 62, 244, 138, 249, 89, 237, 71, 235, 132, 236, 125, 234, 127, 235, 90, 235, 56, 235, 113, 236, 240, 235, 74, 236, 225, 235, 126, 235, 187, 234, 144, 234, 11, 236, 223, 232, 226, 233, 205, 235, 158, 234, 137, 235, 218, 234, 191, 235, 246, 235, 249, 234, 159, 235, 175, 235, 237, 236, 35, 234, 150, 235, 224, 235, 129, 237, 103, 240, 93, 238, 77, 241, 179, 240, 84, 240, 235, 247, 8, 242, 80, 243, 202, 240, 233, 244, 124, 241, 111, 243, 125, 244, 103, 242, 47, 242, 66, 242, 27, 241, 9, 236, 137, 239, 146, 236, 101, 244, 11, 241, 194, 239, 39, 238, 70, 238, 254, 240, 89, 243, 16, 244, 93, 244, 222, 236, 168, 246, 218, 236, 155, 240, 24, 243, 220, 242, 212, 238, 21, 241, 36, 243, 119, 237, 30, 236, 134, 236, 95, 240, 102, 239, 190, 236, 145, 239, 43, 237, 15, 237, 66, 242, 208, 243, 228, 242, 66, 242, 253, 243, 188, 240, 126, 239, 25, 239, 41, 240, 51, 241, 91, 241, 46, 242, 91, 238, 5, 239, 140, 238, 231, 236, 36, 238, 193, 240, 115, 238, 22, 243, 156, 242, 0, 241, 79, 237, 186, 235, 73, 237, 241, 237, 137, 238, 99, 237, 74, 235, 146, 237, 177, 235, 143, 235, 197, 235, 137, 235, 214, 236, 166, 235, 50, 236, 44, 236, 32, 236, 125, 233, 3, 234, 68, 233, 147, 234, 120, 233, 34, 233, 220, 234, 210, 235, 189, 235, 92, 233, 231, 231, 128, 233, 97, 235, 51, 234, 79, 235, 211, 232, 156, 232, 158, 233, 60, 234, 220, 234, 166, 236, 233, 246, 209, 249, 119, 248, 45, 237, 113, 255, 60, 233, 191, 249, 168, 253, 7, 252, 122, 237, 177, 235, 40, 234, 200, 233, 165, 235, 44, 234, 91, 234, 59, 235, 125, 231, 143, 234, 190, 234, 0, 233, 153, 231, 130, 236, 167, 226, 135, 233, 154, 234, 227, 233, 31, 232, 130, 235, 107, 231, 130, 237, 38, 235, 238, 237, 124, 232, 55, 236, 208, 233, 163, 234, 40, 234, 39, 236, 121, 232, 41, 233, 54, 232, 142, 232, 225, 233, 187, 232, 14, 233, 82, 233, 44, 232, 154, 235, 192, 237, 93, 237, 60, 237, 52, 234, 50, 233, 63, 234, 170, 233, 75, 234, 40, 234, 152, 232, 255, 232, 43, 233, 98, 234, 44, 233, 26, 233, 231, 232, 141, 235, 218, 232, 211, 233, 151, 233, 109, 234, 59, 232, 2, 233, 35, 233, 169, 234, 25, 233, 1, 233, 203, 232, 248, 232, 95, 237, 228, 238, 167, 239, 80, 237, 155, 236, 43, 243, 130, 241, 12, 237, 219, 244, 167, 239, 220, 240, 84, 239, 55, 236, 60, 236, 69, 236, 26, 236, 9, 236, 97, 236, 168, 236, 89, 238, 183, 237, 242, 236, 4, 235, 84, 236, 34, 237, 117, 237, 222, 237, 75, 236, 48, 234, 91, 235, 248, 235, 188, 235, 144, 235, 160, 238, 50, 239, 147, 240, 247, 238, 64, 240, 86, 238, 24, 239, 152, 237, 71, 237, 195, 238, 174, 238, 205, 1, 120, 242, 193, 241, 14, 242, 184, 236, 176, 235, 227, 235, 128, 234, 189, 234, 83, 234, 111, 236, 29, 238, 21, 234, 33, 234, 70, 237, 206, 233, 195, 233, 238, 234, 252, 232, 87, 238, 11, 235, 156, 233, 160, 239, 138, 237, 68, 238, 235, 236, 15, 238, 75, 236, 199, 234, 57, 235, 164, 236, 87, 239, 157, 235, 246, 235, 126, 236, 212, 234, 146, 234, 200, 237, 131, 235, 198, 236, 44, 4, 94, 5, 5, 3, 209, 4, 30, 5, 113, 3, 244, 2, 0, 3, 10, 4, 0, 0, 6, 1, 246, 0, 146, 1, 62, 0, 165, 252, 106, 254, 183, 254, 121, 4, 234, 1, 191, 5, 155, 7, 249, 3, 43, 6, 195, 2, 97, 1, 16, 7, 109, 2, 129, 5, 100, 4, 224, 6, 122, 235, 252, 236, 64, 248, 125, 238, 52, 235, 125, 236, 97, 244, 115, 243, 230, 239, 115, 238, 117, 238, 11, 244, 22, 236, 27, 236, 250, 241, 93, 236, 94, 238, 75, 242, 225, 0, 8, 1, 183, 0, 89, 255, 4, 0, 40, 1, 112, 248, 229, 254, 242, 243, 171, 237, 105, 236, 136, 238, 132, 248, 184, 244, 218, 241, 243, 250, 163, 246, 177, 254, 186, 241, 248, 242, 19, 242, 66, 2, 216, 255, 100, 2, 228, 248, 1, 248, 243, 250, 29, 1, 173, 255, 140, 255, 67, 240, 30, 239, 104, 239, 82, 242, 213, 238, 193, 238, 222, 241, 175, 239, 27, 243, 60, 255, 78, 246, 50, 243, 160, 253, 140, 238, 37, 247, 13, 249, 248, 248, 138, 238, 254, 240, 111, 238, 33, 252, 180, 239, 123, 3, 73, 0, 48, 1, 196, 255, 88, 241, 34, 240, 216, 238, 172, 240, 38, 242, 113, 242, 227, 243, 31, 243, 141, 244, 168, 242, 246, 240, 186, 245, 106, 241, 137, 243, 19, 242, 16, 242, 250, 247, 225, 242, 60, 245, 124, 240, 81, 242, 242, 243, 178, 241, 114, 240, 136, 239, 200, 240, 163, 242, 65, 241, 219, 243, 167, 242, 203, 244, 66, 244, 0, 245, 166, 245, 28, 245, 33, 251, 206, 248, 192, 250, 203, 249, 47, 248, 227, 250, 254, 250, 163, 248, 53, 242, 13, 243, 193, 240, 8, 245, 143, 245, 46, 243, 0, 247, 138, 245, 108, 250, 242, 242, 251, 245, 47, 245, 243, 245, 229, 245, 175, 244, 117, 247, 85, 246, 146, 246, 44, 248, 79, 247, 54, 244, 169, 237, 211, 236, 97, 237, 156, 237, 225, 240, 234, 239, 167, 238, 161, 241, 100, 241, 167, 238, 146, 239, 4, 240, 240, 239, 104, 237, 194, 239, 210, 237, 254, 238, 253, 240, 20, 241, 224, 239, 34, 239, 82, 239, 60, 240, 105, 238, 228, 243, 210, 239, 64, 240, 74, 237, 167, 239, 110, 238, 15, 245, 180, 244, 252, 244, 71, 248, 105, 247, 211, 241, 201, 239, 182, 243, 105, 242, 64, 244, 164, 239, 227, 242, 108, 242, 120, 240, 251, 243, 252, 243, 133, 243, 188, 243, 48, 237, 19, 237, 83, 236, 76, 237, 112, 237, 182, 236, 216, 237, 44, 238, 84, 236, 152, 235, 98, 235, 42, 236, 24, 234, 189, 234, 108, 234, 51, 236, 63, 235, 176, 235, 165, 232, 197, 233, 35, 234, 219, 232, 53, 234, 194, 231, 254, 234, 83, 233, 147, 234, 54, 235, 225, 233, 164, 234, 193, 241, 80, 244, 25, 244, 106, 238, 143, 240, 70, 239, 24, 242, 42, 243, 167, 239, 72, 235, 30, 236, 182, 235, 161, 236, 116, 236, 0, 236, 103, 237, 57, 237, 121, 237, 178, 236, 146, 236, 245, 235, 72, 238, 72, 237, 132, 238, 228, 235, 120, 236, 105, 236, 142, 237, 7, 237, 237, 237, 202, 243, 49, 248, 202, 243, 110, 240, 20, 243, 26, 241, 96, 243, 201, 243, 46, 244, 253, 234, 54, 237, 221, 236, 167, 243, 255, 237, 146, 239, 207, 237, 53, 238, 146, 239, 212, 234, 193, 234, 204, 234, 73, 247, 16, 235, 77, 238, 103, 236, 213, 237, 234, 238, 55, 239, 141, 249, 108, 241, 72, 235, 32, 237, 109, 235, 246, 234, 3, 235, 38, 235, 13, 236, 220, 235, 66, 235, 144, 235, 122, 235, 184, 233, 23, 234, 212, 235, 175, 235, 120, 236, 111, 235, 237, 236, 6, 235, 235, 234, 111, 235, 51, 235, 33, 235, 171, 238, 39, 239, 216, 233, 152, 236, 28, 238, 182, 238, 250, 234, 181, 242, 32, 243, 141, 239, 32, 237, 1, 236, 180, 241, 250, 233, 97, 236, 105, 235, 66, 237, 37, 244, 126, 249, 35, 242, 241, 242, 114, 247, 195, 234, 200, 235, 166, 236, 195, 236, 136, 235, 175, 237, 3, 238, 102, 241, 158, 241, 108, 247, 58, 246, 37, 240, 114, 247, 175, 242, 134, 241, 84, 240, 140, 241, 198, 241, 70, 240, 215, 242, 12, 241, 115, 238, 14, 241, 182, 247, 28, 239, 131, 244, 28, 240, 183, 239, 210, 239, 107, 236, 100, 235, 172, 237, 233, 236, 177, 236, 227, 236, 248, 239, 84, 238, 161, 237, 194, 237, 39, 239, 92, 236, 145, 239, 237, 237, 95, 241, 60, 235, 189, 235, 86, 235, 238, 234, 114, 236, 164, 242, 148, 234, 140, 235, 73, 237, 254, 236, 184, 235, 159, 235, 113, 235, 35, 236, 10, 237, 92, 237, 35, 237, 126, 237, 47, 233, 203, 233, 30, 238, 188, 235, 91, 236, 7, 237, 209, 237, 131, 238, 237, 236, 147, 237, 196, 236, 154, 238, 195, 237, 179, 238, 94, 238, 194, 237, 194, 238, 104, 237, 62, 235, 121, 236, 14, 236, 162, 236, 154, 233, 23, 234, 101, 234, 217, 234, 187, 232, 8, 234, 76, 234, 40, 234, 248, 234, 87, 235, 48, 233, 197, 233, 158, 232, 186, 233, 70, 233, 132, 234, 29, 233, 40, 233, 19, 234, 166, 235, 99, 234, 46, 237, 33, 237, 155, 235, 251, 235, 165, 235, 245, 235, 95, 235, 42, 236, 86, 245, 192, 235, 177, 235, 196, 235, 219, 235, 138, 235, 65, 248, 84, 234, 42, 235, 251, 234, 194, 234, 198, 234, 156, 234, 143, 235, 231, 234, 35, 235, 64, 235, 32, 235, 228, 233, 39, 234, 180, 234, 174, 234, 24, 235, 126, 234, 34, 234, 168, 234, 122, 243, 81, 234, 68, 237, 227, 236, 172, 238, 104, 236, 47, 235, 61, 234, 192, 238, 1, 237, 187, 236, 152, 235, 179, 237, 152, 235, 45, 234, 191, 234, 16, 232, 240, 233, 213, 234, 204, 233, 47, 234, 102, 235, 3, 234, 65, 232, 55, 236, 223, 231, 83, 231, 196, 232, 25, 233, 155, 235, 200, 234, 92, 236, 218, 243, 184, 242, 235, 242, 187, 243, 109, 243, 226, 241, 166, 238, 142, 244, 52, 243, 171, 242, 10, 239, 97, 243, 186, 240, 29, 243, 104, 244, 18, 244, 134, 238, 0, 234, 134, 238, 142, 239, 29, 238, 151, 238, 122, 237, 123, 241, 13, 240, 30, 239, 183, 237, 23, 237, 218, 242, 183, 243, 220, 243, 59, 239, 232, 241, 150, 235, 199, 238, 246, 239, 194, 238, 32, 238, 141, 238, 182, 240, 36, 245, 233, 244, 7, 243, 121, 244, 42, 247, 146, 241, 213, 240, 176, 241, 100, 242, 177, 242, 22, 243, 244, 242, 147, 234, 163, 236, 96, 237, 161, 233, 226, 234, 51, 242, 198, 237, 243, 238, 225, 240, 2, 237, 198, 235, 241, 233, 32, 235, 134, 237, 222, 235, 226, 236, 56, 236, 70, 236, 142, 241, 28, 241, 196, 241, 187, 242, 163, 241, 114, 240, 187, 238, 63, 239, 218, 238, 28, 238, 61, 239, 159, 241, 111, 240, 150, 241, 19, 241, 199, 239, 7, 239, 119, 240, 224, 238, 167, 240, 62, 239, 131, 241, 95, 243, 200, 255, 235, 244, 193, 255, 194, 244, 206, 255, 180, 255, 221, 236, 193, 236, 23, 237, 119, 237, 225, 236, 89, 237, 72, 238, 89, 237, 22, 240, 18, 255, 166, 247, 70, 255, 255, 253, 199, 237, 251, 249, 11, 238, 184, 239, 181, 240, 75, 242, 182, 249, 70, 247, 237, 243, 195, 248, 4, 243, 157, 245, 92, 240, 73, 240, 118, 241, 61, 240, 1, 241, 202, 240, 164, 241, 171, 243, 168, 236, 84, 237, 5, 238, 215, 237, 237, 237, 72, 237, 89, 239, 129, 237, 138, 239, 164, 240, 164, 240, 11, 238, 22, 239, 164, 237, 171, 239, 253, 237, 1, 238, 214, 236, 40, 239, 110, 237, 66, 237, 63, 237, 95, 240, 76, 238, 66, 239, 65, 240, 61, 241, 85, 246, 210, 239, 87, 238, 1, 239, 20, 240, 23, 239, 70, 238, 84, 237, 165, 243, 188, 243, 63, 238, 16, 241, 165, 239, 100, 242, 72, 243, 89, 236, 188, 237, 242, 234, 101, 236, 95, 236, 153, 235, 176, 236, 90, 239, 123, 239, 72, 237, 61, 248, 37, 241, 140, 245, 143, 246, 175, 248, 14, 236, 108, 236, 92, 239, 4, 240, 75, 240, 238, 239, 157, 241, 16, 248, 55, 245, 85, 246, 55, 248, 28, 241, 171, 240, 132, 241, 10, 245, 231, 239, 215, 243, 111, 239, 49, 235, 140, 235, 220, 240, 30, 242, 243, 235, 216, 234, 19, 235, 45, 234, 226, 234, 192, 234, 250, 234, 218, 237, 248, 237, 46, 243, 126, 239, 140, 235, 40, 239, 247, 234, 206, 234, 230, 234, 116, 239, 160, 243, 23, 240, 104, 239, 117, 239, 201, 238, 231, 235, 87, 236, 83, 235, 7, 238, 74, 239, 70, 236, 68, 237, 191, 237, 19, 237, 63, 235, 115, 237, 234, 236, 50, 238, 67, 255, 116, 255, 84, 255, 53, 255, 124, 255, 80, 255, 64, 255, 130, 0, 175, 255, 98, 255, 219, 255, 199, 255, 106, 255, 84, 255, 63, 1, 17, 0, 171, 0, 135, 255, 139, 255, 194, 255, 225, 255, 4, 0, 119, 255, 60, 255, 152, 255, 81, 255, 217, 248, 216, 253, 158, 255, 35, 254, 19, 255, 169, 254, 37, 253, 28, 0, 66, 1, 94, 0, 242, 1, 243, 0, 158, 0, 127, 255, 92, 2, 17, 3, 156, 1, 120, 1, 145, 254, 33, 1, 230, 254, 170, 255, 1, 0, 161, 254, 108, 1, 70, 255, 50, 254, 236, 0, 146, 1, 27, 0, 188, 0, 180, 255, 255, 255, 122, 0, 106, 0, 244, 0, 159, 255, 28, 1, 203, 0, 133, 1, 5, 1, 204, 255, 221, 255, 88, 255, 35, 1, 6, 0, 2, 0, 20, 0, 235, 255, 81, 1, 233, 255, 225, 255, 221, 255, 248, 0, 59, 0, 14, 0, 60, 1, 39, 255, 36, 255, 207, 255, 51, 255, 8, 0, 208, 255, 237, 255, 242, 255, 18, 0, 6, 0, 141, 255, 235, 255, 50, 255, 149, 255, 231, 0, 201, 255, 5, 255, 46, 245, 0, 247, 198, 249, 166, 248, 128, 246, 98, 250, 244, 246, 151, 244, 220, 244, 138, 246, 250, 243, 97, 244, 191, 244, 192, 248, 188, 245, 68, 247, 160, 243, 131, 244, 202, 244, 177, 243, 197, 245, 40, 244, 250, 243, 96, 245, 3, 244, 169, 244, 145, 11, 94, 11, 57, 10, 95, 11, 117, 11, 178, 11, 134, 5, 234, 7, 36, 8, 117, 8, 19, 9, 27, 7, 163, 6, 40, 9, 112, 6, 110, 9, 203, 9, 127, 10, 178, 245, 65, 250, 149, 245, 51, 0, 192, 254, 201, 254, 106, 253, 39, 255, 181, 1, 72, 10, 192, 5, 122, 11, 50, 244, 117, 245, 24, 243, 71, 243, 22, 246, 234, 244, 48, 245, 89, 248, 39, 245, 84, 3, 62, 252, 205, 2, 161, 243, 241, 242, 241, 1, 121, 1, 89, 7, 205, 248, 122, 2, 45, 255, 1, 10, 167, 6, 150, 5, 247, 243, 148, 255, 38, 245, 169, 245, 236, 254, 129, 249, 117, 246, 238, 246, 188, 9, 219, 10, 135, 10, 21, 10, 126, 0, 91, 252, 55, 247, 195, 250, 76, 0, 207, 8, 97, 255, 71, 1, 171, 251, 154, 251, 22, 250, 174, 239, 199, 247, 139, 248, 96, 246, 38, 241, 118, 249, 129, 243, 174, 255, 2, 255, 49, 250, 241, 254, 104, 255, 102, 1, 114, 249, 97, 250, 126, 248, 28, 2, 75, 1, 184, 5, 140, 246, 56, 255, 223, 253, 121, 2, 109, 0, 209, 254, 15, 254, 33, 248, 195, 251, 0, 1, 246, 255, 45, 1, 145, 255, 222, 1, 27, 254, 228, 255, 158, 0, 18, 0, 1, 0, 255, 0, 87, 255, 182, 2, 255, 0, 233, 5, 144, 253, 78, 255, 97, 254, 190, 0, 98, 253, 220, 2, 24, 3, 151, 255, 83, 1, 218, 0, 134, 0, 149, 255, 235, 254, 43, 255, 72, 4, 74, 11, 239, 11, 236, 11, 16, 10, 9, 11, 69, 10, 230, 11, 132, 11, 140, 11, 102, 7, 17, 8, 186, 6, 237, 9, 40, 9, 11, 9, 180, 7, 123, 8, 74, 9, 223, 4, 80, 8, 46, 5, 3, 11, 238, 9, 22, 10, 104, 9, 199, 9, 49, 10, 92, 10, 131, 10, 34, 11, 173, 0, 150, 255, 249, 5, 48, 0, 158, 253, 50, 7, 36, 8, 129, 8, 135, 7, 28, 4, 43, 7, 219, 1, 121, 2, 165, 7, 211, 7, 160, 2, 220, 5, 183, 2, 216, 246, 169, 248, 75, 246, 62, 251, 8, 255, 113, 1, 62, 1, 235, 253, 77, 255, 88, 255, 138, 255, 200, 251, 206, 4, 167, 4, 169, 254, 208, 1, 87, 255, 86, 3, 27, 254, 169, 252, 72, 254, 146, 254, 105, 12, 125, 11, 46, 12, 249, 11, 254, 10, 242, 255, 199, 5, 83, 6, 152, 6, 90, 2, 194, 8, 99, 10, 63, 6, 83, 3, 130, 9, 130, 7, 113, 254, 188, 4, 185, 4, 115, 10, 128, 8, 250, 9, 182, 254, 86, 2, 86, 255, 220, 252, 243, 252, 113, 0, 34, 2, 24, 251, 144, 0, 96, 255, 18, 2, 209, 1, 44, 251, 135, 253, 49, 252, 54, 248, 43, 247, 215, 246, 215, 246, 183, 255, 92, 250, 103, 252, 91, 1, 0, 0, 107, 253, 221, 255, 83, 254, 47, 253, 212, 247, 56, 253, 209, 254, 89, 254, 226, 253, 170, 249, 242, 249, 35, 251, 208, 247, 188, 254, 130, 253, 48, 252, 75, 3, 221, 4, 97, 4, 232, 3, 130, 5, 89, 4, 188, 1, 39, 245, 102, 245, 122, 245, 43, 245, 20, 245, 69, 249, 119, 2, 254, 0, 84, 3, 153, 2, 239, 0, 150, 253, 77, 254, 36, 2, 82, 2, 176, 246, 236, 0, 170, 245, 103, 0, 119, 2, 208, 255, 22, 1, 223, 253, 140, 246, 76, 2, 12, 253, 2, 0, 238, 255, 117, 0, 241, 1, 104, 1, 151, 249, 217, 255, 24, 4, 159, 0, 66, 0, 155, 1, 222, 244, 175, 244, 3, 245, 241, 244, 233, 244, 189, 255, 16, 247, 44, 245, 199, 245, 122, 246, 191, 246, 95, 245, 20, 242, 109, 236, 204, 1, 56, 255, 31, 238, 107, 255, 176, 255, 165, 1, 127, 1, 242, 2, 66, 4, 174, 2, 73, 3, 250, 1, 167, 255, 50, 252, 31, 0, 125, 255, 138, 247, 111, 237, 138, 4, 40, 3, 47, 3, 229, 3, 224, 2, 199, 5, 203, 246, 8, 248, 28, 0, 15, 252, 122, 252, 113, 2, 49, 3, 42, 2, 21, 4, 16, 2, 140, 2, 216, 1, 34, 3, 233, 2, 76, 4, 246, 255, 53, 5, 215, 255, 223, 0, 171, 0, 133, 0, 141, 0, 149, 0, 147, 0, 142, 0, 178, 0, 148, 0, 235, 255, 186, 255, 197, 255, 157, 0, 41, 0, 3, 0, 75, 0, 9, 0, 68, 0, 216, 0, 192, 0, 170, 0, 142, 0, 157, 0, 175, 0, 107, 0, 147, 0, 114, 0, 135, 0, 132, 0, 205, 0, 159, 255, 184, 255, 166, 255, 206, 255, 193, 255, 199, 255, 211, 254, 198, 255, 196, 255, 108, 0, 15, 0, 16, 0, 12, 0, 0, 0, 41, 0, 218, 255, 235, 255, 214, 255, 242, 0, 154, 0, 116, 0, 37, 0, 244, 255, 149, 255, 241, 255, 15, 0, 237, 255, 227, 255, 38, 0, 5, 0, 210, 255, 243, 255, 253, 255, 85, 1, 172, 1, 191, 0, 95, 8, 229, 6, 75, 3, 8, 2, 228, 1, 239, 2, 194, 1, 158, 1, 195, 1, 44, 1, 190, 0, 87, 2, 232, 0, 60, 1, 187, 0, 238, 1, 162, 1, 227, 2, 146, 1, 106, 2, 99, 1, 5, 3, 220, 3, 170, 1, 176, 255, 8, 0, 205, 255, 254, 255, 159, 0, 127, 1, 99, 0, 84, 0, 29, 0, 80, 0, 52, 1, 97, 0, 151, 0, 135, 0, 224, 0, 0, 0, 77, 0, 38, 0, 12, 244, 226, 243, 197, 241, 149, 241, 227, 243, 137, 242, 34, 244, 172, 242, 188, 242, 41, 242, 146, 242, 109, 241, 192, 240, 55, 243, 248, 250, 40, 250, 167, 252, 104, 244, 108, 248, 193, 249, 253, 248, 8, 250, 100, 246, 230, 241, 125, 240, 223, 242, 148, 239, 178, 238, 139, 237, 75, 240, 74, 237, 195, 237, 62, 237, 157, 255, 123, 255, 133, 255, 33, 245, 169, 249, 48, 247, 57, 255, 105, 255, 93, 242, 74, 239, 163, 238, 114, 238, 32, 240, 0, 238, 100, 237, 243, 237, 133, 238, 27, 238, 180, 237, 189, 255, 87, 1, 189, 255, 92, 0, 143, 1, 4, 0, 28, 2, 191, 0, 207, 255, 170, 254, 187, 249, 201, 254, 176, 245, 45, 245, 165, 244, 187, 247, 8, 247, 208, 250, 248, 255, 124, 0, 187, 0, 77, 0, 137, 0, 207, 255, 146, 255, 76, 0, 157, 255, 125, 255, 158, 255, 186, 255, 58, 241, 225, 239, 1, 238, 174, 237, 41, 240, 118, 0, 179, 254, 111, 255, 138, 251, 241, 253, 106, 253, 183, 246, 156, 246, 10, 246, 112, 245, 21, 251, 18, 255, 161, 242, 37, 0, 82, 8, 28, 6, 85, 0, 254, 2, 29, 2, 177, 1, 131, 1, 83, 1, 107, 0, 128, 0, 129, 2, 196, 2, 38, 1, 155, 4, 113, 2, 191, 0, 229, 0, 199, 1, 255, 2, 145, 1, 31, 4, 172, 255, 54, 1, 173, 255, 178, 255, 235, 255, 182, 255, 221, 255, 103, 0, 112, 0, 133, 0, 167, 1, 182, 255, 1, 0, 31, 0, 215, 255, 230, 255, 223, 255, 224, 255, 31, 0, 20, 0, 77, 0, 216, 255, 192, 237, 251, 236, 218, 236, 48, 237, 211, 239, 22, 0, 174, 255, 132, 255, 126, 255, 237, 255, 136, 240, 216, 237, 130, 255, 166, 255, 134, 243, 89, 255, 165, 255, 128, 255, 182, 255, 105, 237, 109, 246, 238, 238, 152, 0, 220, 255, 16, 0, 118, 0, 92, 0, 43, 1, 216, 255, 190, 255, 229, 255, 241, 255, 128, 0, 123, 0, 92, 0, 93, 0, 29, 0, 225, 255, 128, 0, 171, 0, 150, 0, 176, 0, 125, 0, 163, 0, 92, 0, 212, 0, 106, 0, 155, 0, 143, 0, 37, 0, 54, 0, 93, 0, 104, 0, 84, 0, 95, 0, 77, 1, 38, 0, 189, 0, 116, 0, 55, 0, 60, 0, 95, 0, 106, 0, 57, 0, 108, 0, 78, 0, 98, 0, 77, 0, 146, 0, 122, 0, 110, 0, 108, 0, 6, 0, 25, 0, 79, 0, 12, 0, 97, 0, 86, 0, 21, 0, 7, 0, 8, 0, 31, 0, 22, 0, 10, 0, 0, 0, 13, 0, 24, 0, 25, 0, 176, 0, 77, 0, 8, 0, 93, 0, 0, 1, 39, 3, 45, 0, 104, 0, 92, 0, 11, 0, 70, 0, 79, 0, 121, 0, 75, 0, 220, 0, 76, 0, 78, 0, 74, 0, 45, 0, 150, 0, 46, 0, 81, 0, 51, 0, 82, 0, 91, 0, 70, 0, 90, 0, 35, 0, 41, 0, 27, 0, 15, 0, 13, 0, 14, 0, 6, 0, 28, 0, 14, 0, 67, 0, 75, 0, 86, 0, 53, 0, 102, 0, 144, 0, 83, 0, 42, 0, 30, 0, 97, 0, 110, 0, 11, 0, 82, 0, 68, 0, 43, 0, 9, 0, 53, 0, 83, 0, 96, 0, 92, 0, 65, 0, 48, 0, 50, 0, 40, 0, 57, 239, 242, 238, 77, 239, 179, 241, 195, 242, 250, 241, 23, 239, 91, 239, 149, 240, 125, 254, 18, 245, 24, 244, 6, 242, 55, 243, 44, 255, 165, 240, 245, 240, 174, 240, 217, 243, 145, 243, 152, 250, 71, 241, 224, 241, 222, 241, 121, 250, 83, 244, 83, 243, 222, 240, 63, 241, 35, 241, 220, 254, 236, 254, 201, 254, 65, 255, 48, 255, 211, 254, 191, 254, 17, 255, 38, 255, 148, 255, 123, 255, 128, 255, 239, 254, 237, 254, 209, 254, 225, 254, 0, 255, 226, 254, 139, 255, 246, 254, 136, 255, 137, 255, 154, 255, 95, 255, 66, 255, 215, 254, 209, 254, 219, 254, 51, 255, 32, 255, 154, 0, 213, 255, 254, 255, 168, 255, 214, 255, 11, 0, 238, 255, 208, 255, 192, 255, 153, 254, 168, 254, 241, 255, 234, 254, 175, 255, 132, 254, 137, 255, 99, 255, 210, 255, 150, 254, 192, 2, 251, 255, 162, 255, 28, 255, 213, 255, 172, 254, 227, 254, 142, 254, 211, 255, 208, 254, 156, 255, 78, 254, 122, 254, 164, 254, 168, 255, 37, 255, 64, 255, 16, 255, 174, 254, 33, 255, 226, 254, 55, 255, 57, 0, 145, 253, 205, 253, 36, 254, 66, 255, 121, 255, 67, 255, 220, 0, 253, 0, 168, 0, 132, 0, 199, 0, 196, 0, 91, 0, 254, 0, 7, 1, 156, 0, 141, 0, 117, 0, 129, 0, 153, 0, 175, 0, 186, 0, 149, 0, 129, 0, 122, 0, 126, 0, 143, 0, 172, 0, 33, 0, 57, 0, 168, 0, 228, 0, 160, 0, 159, 0, 116, 0, 192, 0, 211, 0, 161, 0, 216, 0, 199, 0, 135, 0, 159, 0, 8, 1, 216, 0, 200, 0, 122, 0, 210, 0, 71, 0, 170, 0, 107, 0, 89, 0, 127, 0, 197, 0, 134, 0, 104, 0, 209, 0, 159, 0, 193, 0, 150, 0, 130, 0, 151, 0, 168, 0, 141, 0, 91, 0, 159, 0, 141, 0, 13, 255, 1, 255, 35, 255, 71, 1, 223, 0, 89, 0, 65, 255, 72, 255, 88, 255, 138, 0, 109, 0, 157, 0, 153, 255, 17, 0, 49, 0, 126, 0, 71, 0, 66, 0, 245, 255, 18, 0, 71, 0, 200, 255, 231, 255, 5, 0, 70, 0, 15, 0, 206, 255, 242, 0, 194, 0, 200, 0, 189, 0, 149, 0, 130, 0, 184, 0, 197, 0, 54, 0, 7, 0, 45, 0, 129, 0, 199, 0, 169, 0, 139, 0, 129, 0, 237, 0, 49, 0, 52, 0, 50, 0, 80, 0, 232, 255, 235, 255, 226, 255, 252, 255, 18, 0, 170, 254, 164, 255, 183, 255, 196, 255, 171, 255, 206, 255, 236, 255, 39, 0, 24, 0, 19, 0, 253, 255, 2, 0, 24, 0, 10, 0, 236, 255, 28, 0, 249, 255, 227, 254, 192, 255, 173, 254, 160, 254, 212, 254, 87, 0, 211, 255, 173, 255, 27, 0, 200, 255, 192, 255, 160, 255, 193, 255, 96, 1, 196, 254, 11, 255, 112, 1, 204, 255, 173, 255, 98, 255, 118, 255, 234, 254, 55, 2, 31, 0, 170, 0, 215, 0, 110, 0, 69, 0, 52, 0, 61, 0, 108, 0, 161, 0, 66, 0, 98, 0, 85, 0, 148, 0, 134, 0, 89, 0, 103, 0, 32, 0, 132, 0, 11, 1, 151, 0, 141, 0, 126, 254, 143, 0, 197, 254, 123, 255, 152, 255, 7, 0, 88, 0, 8, 0, 0, 0, 175, 255, 95, 0, 120, 255, 239, 255, 137, 0, 19, 0, 178, 255, 255, 255, 96, 255, 123, 244, 231, 244, 73, 245, 58, 246, 214, 246, 213, 252, 161, 248, 56, 246, 120, 244, 235, 244, 252, 243, 119, 244, 80, 249, 49, 248, 210, 249, 246, 250, 95, 248, 37, 250, 196, 246, 27, 245, 175, 245, 115, 247, 129, 255, 176, 255, 20, 255, 190, 253, 173, 251, 164, 255, 158, 251, 34, 255, 36, 254, 40, 253, 229, 250, 238, 253, 3, 251, 54, 250, 16, 254, 232, 255, 160, 251, 79, 251, 198, 248, 93, 249, 105, 248, 66, 251, 163, 252, 143, 255, 22, 254, 207, 250, 172, 4, 150, 7, 222, 254, 141, 7, 153, 2, 195, 5, 232, 253, 182, 248, 37, 249, 126, 0, 5, 255, 76, 255, 52, 254, 223, 254, 40, 255, 222, 255, 255, 255, 15, 252, 81, 254, 227, 252, 223, 1, 107, 255, 5, 2, 224, 253, 46, 255, 150, 251, 28, 251, 86, 246, 4, 246, 110, 245, 131, 246, 224, 3, 153, 0, 107, 5, 101, 255, 242, 247, 131, 250, 194, 248, 172, 250, 196, 254, 101, 255, 22, 249, 27, 252, 192, 248, 219, 0, 58, 0, 198, 0, 135, 0, 91, 0, 90, 0, 44, 0, 206, 255, 43, 0, 140, 0, 242, 255, 78, 0, 123, 255, 174, 255, 21, 0, 38, 0, 212, 255, 7, 0, 20, 0, 40, 0, 78, 0, 67, 0, 116, 254, 58, 1, 161, 1, 50, 1, 11, 1, 106, 0, 1, 1, 205, 2, 27, 2, 62, 1, 47, 0, 50, 2, 29, 1, 177, 2, 229, 2, 225, 1, 238, 0, 196, 0, 44, 1, 2, 1, 88, 0, 123, 0, 245, 255, 4, 1, 168, 0, 220, 0, 87, 255, 144, 255, 28, 3, 49, 254, 143, 254, 201, 254, 251, 0, 74, 0, 100, 0, 34, 1, 98, 0, 41, 1, 142, 0, 114, 255, 157, 254, 198, 1, 44, 2, 228, 4, 156, 1, 164, 255, 66, 2, 184, 3, 239, 2, 243, 2, 208, 0, 216, 5, 139, 0, 1, 0, 182, 0, 121, 0, 95, 0, 77, 2, 7, 1, 117, 1, 119, 1, 128, 0, 36, 0, 7, 0, 198, 255, 44, 0, 63, 0, 224, 255, 171, 255, 221, 255, 67, 239, 37, 240, 74, 239, 59, 239, 225, 245, 130, 2, 117, 1, 70, 240, 209, 248, 128, 244, 94, 248, 87, 252, 147, 240, 39, 251, 91, 240, 97, 240, 1, 253, 84, 241, 152, 240, 124, 240, 178, 245, 80, 243, 95, 6, 243, 4, 48, 1, 160, 2, 102, 0, 218, 8, 121, 8, 181, 241, 212, 242, 105, 242, 248, 254, 241, 254, 240, 254, 115, 245, 89, 250, 6, 255, 189, 3, 200, 0, 253, 6, 129, 4, 204, 255, 142, 1, 42, 255, 115, 0, 46, 0, 161, 1, 126, 254, 198, 254, 252, 254, 154, 254, 23, 254, 80, 254, 171, 255, 177, 255, 90, 255, 111, 1, 235, 255, 157, 2, 208, 254, 138, 255, 127, 242, 67, 246, 38, 244, 6, 255, 46, 247, 20, 248, 132, 247, 131, 247, 53, 255, 154, 255, 148, 255, 200, 255, 117, 3, 66, 255, 111, 255, 236, 255, 155, 241, 105, 243, 4, 249, 130, 243, 88, 244, 176, 254, 125, 255, 41, 253, 217, 247, 211, 255, 127, 255, 145, 247, 252, 246, 47, 246, 138, 255, 106, 254, 106, 255, 55, 255, 113, 249, 204, 254, 220, 254, 183, 244, 213, 251, 228, 249, 76, 252, 132, 251, 147, 248, 4, 252, 237, 245, 102, 243, 153, 244, 64, 244, 237, 243, 126, 250, 248, 245, 20, 248, 5, 255, 134, 254, 202, 254, 155, 254, 63, 255, 18, 243, 191, 247, 176, 245, 249, 245, 37, 244, 140, 247, 93, 252, 137, 255, 25, 255, 212, 255, 64, 0, 13, 244, 176, 244, 236, 244, 59, 252, 233, 246, 115, 249, 129, 6, 221, 254, 17, 1, 35, 255, 224, 254, 52, 250, 210, 248, 35, 250, 219, 248, 162, 250, 193, 249, 107, 251, 73, 244, 218, 244, 92, 246, 204, 244, 139, 249, 249, 245, 180, 251, 230, 251, 164, 254, 93, 251, 0, 251, 109, 243, 58, 247, 198, 250, 108, 248, 124, 246, 160, 244, 218, 247, 147, 244, 103, 243, 231, 248, 33, 242, 226, 242, 156, 245, 104, 243, 164, 243, 73, 243, 30, 246, 140, 255, 184, 255, 146, 255, 141, 255, 85, 0, 157, 255, 123, 0, 55, 1, 118, 0, 165, 0, 97, 0, 62, 0, 50, 0, 6, 0, 173, 1, 112, 1, 121, 1, 228, 0, 21, 1, 63, 1, 23, 1, 35, 1, 176, 0, 45, 0, 76, 0, 127, 0, 65, 1, 168, 255, 77, 255, 92, 254, 49, 0, 202, 255, 66, 1, 140, 0, 39, 0, 59, 0, 211, 255, 205, 255, 61, 0, 72, 0, 48, 0, 0, 0, 76, 1, 106, 1, 75, 0, 131, 0, 84, 0, 71, 0, 18, 0, 148, 255, 37, 0, 26, 0, 43, 2, 24, 1, 172, 1, 168, 0, 158, 0, 60, 1, 34, 1, 234, 0, 185, 0, 173, 1, 220, 1, 231, 1, 235, 0, 129, 1, 101, 1, 8, 1, 136, 1, 235, 0, 202, 1, 198, 1, 154, 1, 110, 1, 187, 1, 147, 1, 89, 1, 170, 1, 170, 1, 189, 0, 161, 0, 37, 1, 36, 1, 170, 0, 169, 0, 187, 0, 148, 0, 11, 1, 80, 1, 12, 1, 236, 0, 197, 0, 132, 1, 18, 1, 42, 1, 65, 1, 63, 1, 182, 0, 253, 0, 220, 0, 190, 242, 51, 243, 82, 248, 224, 245, 26, 243, 213, 244, 164, 248, 100, 241, 58, 244, 64, 244, 80, 243, 7, 243, 27, 242, 17, 249, 79, 246, 239, 248, 26, 249, 32, 254, 204, 250, 98, 250, 235, 243, 180, 245, 245, 244, 123, 248, 240, 246, 213, 250, 92, 242, 139, 241, 112, 241, 84, 242, 165, 241, 215, 242, 15, 241, 66, 241, 53, 241, 63, 255, 151, 254, 43, 254, 133, 242, 36, 246, 182, 245, 173, 244, 141, 246, 184, 242, 15, 241, 29, 241, 50, 241, 50, 241, 31, 241, 9, 241, 155, 241, 65, 241, 157, 241, 219, 241, 162, 241, 112, 241, 67, 255, 90, 255, 243, 255, 197, 0, 127, 255, 0, 0, 128, 255, 92, 255, 251, 255, 208, 255, 204, 253, 106, 254, 56, 0, 96, 255, 1, 1, 85, 0, 234, 255, 51, 255, 10, 255, 115, 0, 79, 255, 202, 254, 154, 254, 13, 255, 77, 254, 233, 254, 104, 241, 116, 242, 180, 241, 172, 241, 22, 243, 107, 255, 110, 254, 23, 255, 26, 254, 230, 244, 36, 252, 145, 245, 27, 246, 78, 253, 187, 253, 211, 245, 126, 248, 252, 243, 178, 239, 218, 239, 119, 239, 43, 241, 190, 240, 138, 240, 153, 236, 86, 240, 96, 237, 90, 255, 251, 244, 219, 245, 58, 255, 83, 252, 225, 255, 220, 241, 222, 242, 213, 241, 131, 4, 175, 4, 11, 3, 96, 245, 161, 255, 63, 255, 112, 4, 49, 0, 128, 255, 92, 241, 85, 242, 201, 240, 177, 2, 116, 3, 216, 1, 217, 4, 181, 3, 207, 2, 52, 6, 104, 4, 186, 2, 117, 6, 118, 7, 222, 0, 242, 3, 156, 5, 239, 3, 187, 4, 22, 7, 25, 8, 47, 255, 65, 2, 220, 0, 5, 4, 223, 5, 125, 5, 144, 5, 220, 2, 225, 4, 110, 6, 244, 4, 231, 2, 217, 255, 229, 255, 35, 245, 157, 2, 18, 2, 68, 3, 204, 255, 211, 0, 76, 4, 13, 11, 233, 1, 28, 2, 233, 1, 73, 3, 11, 3, 112, 0, 252, 1, 140, 0, 79, 0, 80, 1, 235, 0, 99, 1, 208, 1, 157, 0, 169, 2, 138, 1, 15, 4, 31, 1, 245, 1, 68, 2, 171, 6, 68, 3, 248, 4, 158, 4, 103, 10, 214, 4, 213, 2, 51, 4, 48, 3, 55, 2, 99, 3, 96, 8, 155, 3, 129, 2, 36, 4, 145, 4, 83, 3, 111, 4, 34, 255, 61, 254, 180, 255, 45, 0, 67, 255, 149, 0, 27, 254, 218, 0, 184, 255, 150, 0, 76, 254, 31, 254, 137, 0, 223, 255, 58, 0, 146, 0, 198, 255, 158, 0, 49, 1, 28, 0, 143, 0, 91, 0, 33, 244, 16, 252, 199, 246, 182, 244, 37, 245, 42, 1, 15, 1, 233, 255, 36, 0, 73, 0, 47, 0, 239, 255, 170, 255, 183, 0, 162, 245, 175, 249, 183, 255, 54, 255, 241, 254, 217, 253, 188, 254, 92, 248, 196, 0, 34, 1, 10, 1, 98, 1, 177, 2, 53, 1, 175, 1, 230, 0, 64, 1, 197, 1, 159, 1, 227, 0, 141, 1, 146, 0, 149, 0, 187, 0, 39, 1, 157, 0, 158, 0, 146, 1, 86, 2, 241, 0, 90, 0, 80, 254, 244, 0, 176, 255, 169, 255, 52, 1, 18, 2, 246, 0, 188, 0, 186, 255, 224, 255, 191, 255, 147, 0, 224, 0, 46, 2, 87, 254, 25, 2, 183, 254, 120, 0, 175, 1, 43, 2, 216, 1, 174, 1, 235, 1, 53, 1, 174, 1, 146, 1, 84, 1, 166, 1, 147, 1, 126, 1, 43, 1, 140, 1, 95, 2, 1, 1, 6, 2, 225, 0, 225, 1, 107, 1, 58, 1, 225, 1, 59, 1, 61, 2, 64, 1, 170, 1, 45, 1, 213, 1, 221, 0, 224, 0, 121, 0, 22, 3, 1, 1, 129, 1, 7, 3, 72, 2, 230, 1, 81, 1, 179, 1, 167, 1, 35, 1, 125, 1, 111, 1, 170, 1, 47, 1, 118, 1, 243, 1, 63, 1, 154, 1, 27, 1, 90, 1, 89, 1, 236, 0, 43, 1, 106, 1, 52, 0, 15, 0, 205, 1, 36, 0, 55, 0, 53, 0, 43, 0, 4, 2, 203, 2, 235, 3, 114, 2, 80, 3, 232, 3, 238, 4, 212, 0, 231, 0, 151, 1, 86, 1, 8, 1, 78, 1, 33, 1, 34, 1, 36, 2, 132, 3, 104, 3, 191, 2, 170, 1, 40, 1, 182, 1, 192, 1, 221, 1, 217, 1, 48, 3, 167, 1, 188, 1, 220, 1, 83, 2, 93, 1, 253, 1, 129, 3, 83, 2, 4, 2, 18, 2, 242, 1, 92, 253, 196, 254, 215, 250, 94, 255, 63, 255, 80, 255, 101, 254, 97, 255, 38, 255, 110, 3, 39, 4, 200, 3, 200, 1, 146, 2, 7, 3, 52, 2, 205, 1, 160, 255, 92, 4, 98, 3, 40, 2, 112, 255, 190, 255, 117, 255, 134, 3, 11, 3, 173, 1, 117, 255, 153, 255, 108, 255, 26, 0, 10, 0, 6, 0, 179, 0, 220, 0, 180, 0, 78, 0, 71, 0, 74, 0, 59, 3, 37, 2, 240, 0, 107, 7, 80, 3, 194, 3, 154, 1, 236, 0, 85, 1, 158, 4, 14, 8, 59, 4, 198, 0, 23, 2, 169, 0, 171, 3, 225, 4, 188, 5, 158, 0, 185, 1, 247, 0, 94, 2, 40, 1, 128, 1, 251, 1, 99, 2, 34, 2, 233, 0, 148, 1, 27, 1, 147, 2, 203, 1, 190, 2, 211, 0, 54, 1, 58, 1, 33, 1, 24, 1, 175, 1, 129, 5, 46, 3, 211, 2, 156, 0, 141, 0, 65, 0, 105, 0, 134, 0, 203, 0, 169, 1, 170, 0, 16, 1, 30, 4, 48, 4, 203, 3, 106, 7, 119, 5, 91, 4, 132, 0, 244, 3, 245, 3, 144, 4, 229, 1, 116, 3, 9, 3, 242, 0, 185, 1, 238, 3, 237, 1, 103, 5, 80, 244, 163, 250, 45, 239, 23, 239, 101, 251, 21, 243, 0, 241, 68, 244, 49, 242, 77, 241, 241, 241, 184, 242, 42, 242, 161, 240, 217, 245, 226, 249, 234, 251, 172, 240, 78, 244, 163, 251, 69, 240, 43, 240, 154, 239, 25, 239, 141, 239, 86, 239, 216, 0, 14, 1, 136, 0, 230, 0, 204, 0, 215, 255, 211, 255, 206, 255, 217, 255, 237, 255, 106, 255, 219, 255, 197, 254, 126, 2, 3, 1, 209, 0, 102, 2, 123, 255, 201, 255, 68, 2, 18, 254, 102, 255, 1, 0, 78, 0, 59, 255, 149, 255, 245, 255, 249, 255, 0, 0, 230, 255, 247, 255, 26, 0, 246, 255, 247, 255, 250, 255, 196, 249, 96, 255, 208, 252, 188, 255, 167, 255, 165, 245, 211, 255, 196, 255, 222, 255, 217, 255, 213, 255, 211, 255, 225, 255, 237, 255, 244, 255, 212, 251, 196, 255, 202, 255, 240, 255, 231, 255, 87, 0, 2, 245, 227, 243, 17, 244, 55, 243, 186, 243, 174, 255, 29, 245, 61, 248, 87, 249, 104, 247, 142, 247, 9, 242, 244, 240, 243, 241, 105, 243, 129, 243, 176, 242, 173, 242, 69, 1, 170, 0, 124, 1, 25, 1, 102, 0, 130, 3, 246, 2, 128, 0, 90, 0, 26, 0, 227, 0, 139, 0, 125, 1, 147, 1, 238, 0, 87, 1, 50, 1, 83, 1, 227, 0, 175, 0, 206, 0, 204, 0, 23, 0, 241, 255, 46, 0, 9, 0, 62, 0, 246, 255, 242, 255, 254, 255, 2, 0, 6, 1, 245, 255, 245, 255, 181, 1, 43, 3, 206, 0, 206, 0, 155, 1, 110, 1, 14, 2, 240, 255, 22, 0, 68, 0, 20, 0, 14, 0, 73, 0, 126, 0, 71, 0, 73, 1, 48, 1, 93, 0, 90, 2, 86, 0, 176, 1, 90, 1, 242, 255, 240, 255, 129, 0, 12, 0, 57, 0, 9, 0, 76, 0, 78, 0, 53, 0, 250, 255, 62, 3, 17, 0, 150, 2, 56, 1, 97, 0, 245, 255, 108, 0, 35, 0, 159, 0, 151, 1, 101, 0, 62, 1, 200, 0, 120, 0, 205, 0, 230, 0, 130, 0, 246, 0, 12, 235, 228, 236, 2, 236, 102, 240, 98, 237, 16, 243, 47, 244, 84, 246, 201, 240, 21, 236, 198, 231, 33, 238, 73, 235, 242, 235, 108, 233, 181, 241, 151, 235, 154, 238, 227, 235, 252, 242, 102, 239, 128, 240, 29, 242, 128, 237, 210, 234, 232, 236, 177, 235, 45, 238, 228, 235, 217, 238, 205, 233, 37, 234, 58, 234, 45, 232, 163, 234, 230, 233, 178, 233, 241, 231, 248, 233, 195, 235, 222, 233, 11, 234, 65, 233, 222, 234, 76, 231, 164, 234, 207, 232, 142, 234, 142, 233, 81, 233, 35, 233, 230, 232, 13, 234, 143, 233, 102, 232, 189, 232, 40, 233, 71, 233, 30, 233, 66, 233, 235, 236, 118, 235, 51, 234, 67, 233, 240, 237, 210, 234, 242, 232, 47, 233, 147, 235, 121, 235, 160, 237, 220, 233, 109, 233, 84, 236, 238, 233, 237, 231, 15, 237, 170, 235, 125, 233, 3, 233, 80, 233, 80, 234, 125, 234, 104, 234, 61, 235, 252, 233, 232, 232, 36, 237, 230, 233, 124, 235, 20, 233, 180, 233, 13, 234, 71, 233, 76, 234, 161, 232, 64, 232, 230, 231, 180, 232, 91, 233, 74, 237, 37, 234, 25, 235, 193, 234, 254, 233, 204, 235, 22, 235, 13, 235, 230, 244, 169, 238, 104, 238, 52, 234, 143, 240, 150, 236, 204, 238, 236, 238, 85, 238, 183, 255, 249, 255, 164, 255, 87, 239, 236, 255, 135, 253, 115, 255, 98, 255, 110, 255, 155, 236, 247, 236, 134, 236, 13, 238, 64, 237, 207, 237, 19, 238, 78, 237, 136, 237, 132, 234, 40, 237, 69, 238, 110, 241, 100, 242, 31, 243, 179, 241, 197, 241, 98, 241, 127, 255, 20, 245, 216, 255, 188, 252, 56, 249, 129, 255, 194, 248, 196, 246, 190, 248, 156, 241, 138, 242, 214, 241, 186, 255, 194, 255, 177, 255, 180, 255, 170, 255, 191, 255, 100, 255, 128, 255, 101, 247, 162, 242, 46, 243, 251, 246, 221, 234, 67, 234, 203, 233, 130, 235, 88, 235, 35, 235, 6, 234, 189, 234, 242, 234, 109, 236, 24, 236, 135, 236, 46, 236, 122, 236, 225, 236, 105, 236, 56, 236, 61, 236, 127, 234, 83, 235, 164, 227, 49, 234, 10, 235, 143, 234, 30, 236, 130, 236, 150, 235, 184, 235, 100, 235, 22, 235, 170, 255, 167, 255, 155, 255, 198, 255, 209, 240, 108, 240, 204, 236, 152, 228, 153, 245, 173, 0, 152, 236, 114, 237, 215, 237, 47, 237, 229, 237, 146, 241, 46, 235, 136, 228, 117, 251, 197, 253, 157, 253, 187, 254, 200, 253, 70, 253, 226, 253, 22, 254, 122, 255, 242, 230, 236, 254, 22, 247, 224, 255, 137, 255, 37, 249, 109, 253, 27, 1, 74, 255, 245, 0, 222, 6, 208, 255, 63, 1, 139, 3, 94, 1, 196, 252, 6, 3, 14, 3, 218, 255, 156, 2, 150, 0, 208, 233, 22, 232, 43, 234, 74, 231, 168, 232, 232, 233, 5, 233, 58, 232, 218, 231, 168, 238, 74, 246, 59, 237, 188, 234, 29, 241, 115, 246, 172, 232, 162, 239, 38, 235, 50, 234, 219, 233, 124, 234, 69, 232, 180, 233, 205, 233, 94, 233, 176, 233, 60, 234, 172, 232, 193, 233, 211, 232, 76, 241, 34, 241, 36, 241, 250, 241, 87, 241, 225, 241, 240, 240, 3, 241, 252, 240, 145, 241, 237, 240, 102, 242, 228, 240, 185, 240, 146, 255, 153, 243, 239, 240, 8, 252, 166, 248, 102, 255, 57, 231, 213, 240, 179, 240, 196, 240, 43, 248, 25, 244, 220, 241, 56, 241, 185, 241, 239, 240, 149, 235, 1, 233, 212, 234, 159, 232, 66, 229, 228, 236, 212, 236, 187, 236, 126, 243, 7, 237, 6, 237, 100, 231, 66, 237, 19, 232, 183, 232, 199, 236, 1, 242, 216, 239, 77, 232, 9, 234, 91, 234, 0, 232, 7, 232, 96, 233, 20, 235, 95, 234, 66, 235, 53, 234, 41, 236, 106, 235, 4, 234, 247, 233, 211, 232, 121, 233, 199, 233, 9, 234, 221, 233, 223, 233, 2, 234, 219, 233, 30, 241, 252, 249, 6, 241, 33, 241, 40, 241, 9, 235, 98, 255, 227, 249, 228, 247, 243, 251, 204, 240, 186, 240, 128, 250, 199, 237, 43, 241, 86, 241, 69, 252, 184, 242, 83, 243, 158, 247, 253, 251, 22, 241, 77, 232, 32, 234, 179, 236, 41, 239, 61, 231, 124, 233, 45, 234, 201, 234, 17, 234, 99, 234, 211, 234, 231, 230, 149, 237, 60, 237, 234, 233, 27, 238, 195, 235, 202, 233, 122, 235, 9, 233, 220, 233, 219, 232, 117, 227, 94, 236, 187, 236, 33, 237, 251, 235, 85, 237, 234, 235, 247, 235, 123, 228, 120, 235, 222, 235, 212, 234, 144, 233, 214, 232, 241, 233, 58, 236, 233, 236, 241, 235, 185, 240, 167, 240, 126, 240, 218, 240, 2, 245, 8, 245, 210, 245, 81, 244, 189, 244, 52, 245, 254, 248, 128, 242, 34, 241, 34, 241, 41, 248, 220, 247, 145, 243, 227, 241, 30, 245, 26, 245, 5, 248, 101, 249, 241, 255, 241, 255, 215, 255, 221, 255, 232, 255, 247, 255, 223, 255, 25, 254, 74, 255, 187, 255, 39, 255, 31, 255, 137, 253, 211, 255, 190, 255, 205, 255, 154, 255, 170, 247, 207, 255, 180, 255, 35, 251, 122, 255, 60, 255, 210, 255, 170, 255, 207, 255, 254, 240, 139, 241, 245, 240, 8, 241, 143, 246, 193, 240, 130, 249, 22, 241, 9, 241, 94, 254, 157, 244, 78, 249, 210, 246, 0, 241, 37, 255, 119, 252, 163, 251, 251, 251, 75, 255, 17, 255, 24, 247, 159, 247, 224, 252, 124, 252, 176, 253, 205, 247, 5, 245, 214, 245, 106, 245, 18, 245, 218, 245, 140, 251, 199, 249, 95, 251, 250, 251, 121, 248, 106, 242, 25, 246, 78, 243, 51, 243, 143, 244, 24, 248, 223, 249, 250, 248, 206, 254, 76, 252, 62, 254, 64, 255, 70, 255, 188, 0, 181, 0, 151, 255, 208, 255, 120, 255, 52, 1, 169, 255, 145, 3, 113, 2, 163, 255, 215, 1, 57, 4, 85, 3, 5, 0, 50, 254, 146, 255, 127, 255, 43, 242, 196, 241, 124, 255, 125, 242, 18, 251, 46, 242, 45, 244, 229, 2, 212, 0, 50, 0, 92, 1, 205, 0, 148, 1, 25, 1, 59, 2, 34, 2, 61, 241, 139, 255, 202, 252, 4, 242, 191, 0, 119, 255, 226, 1, 56, 2, 12, 1, 162, 255, 75, 0, 0, 0, 38, 0, 38, 0, 22, 0, 25, 0, 61, 0, 176, 2, 183, 0, 160, 0, 34, 1, 0, 1, 43, 0, 67, 0, 173, 2, 217, 0, 234, 3, 43, 0, 134, 1, 60, 0, 107, 1, 1, 3, 14, 1, 18, 0, 189, 0, 13, 0, 240, 2, 235, 255, 174, 0, 149, 255, 155, 255, 123, 4, 30, 4, 180, 2, 119, 2, 250, 255, 204, 1, 246, 255, 74, 2, 198, 1, 130, 2, 176, 1, 169, 2, 230, 255, 100, 238, 64, 255, 31, 239, 69, 235, 196, 255, 200, 0, 1, 0, 37, 1, 36, 1, 125, 1, 59, 5, 78, 255, 206, 255, 216, 255, 244, 254, 9, 0, 62, 0, 245, 255, 60, 0, 22, 0, 42, 1, 152, 255, 82, 255, 9, 0, 94, 1, 84, 0, 69, 0, 198, 0, 65, 6, 127, 0, 255, 255, 230, 255, 203, 0, 33, 0, 220, 0, 185, 2, 66, 1, 202, 1, 240, 0, 119, 3, 133, 1, 34, 3, 215, 0, 111, 0, 161, 0, 43, 2, 83, 1, 85, 2, 117, 255, 175, 245, 156, 255, 116, 255, 144, 255, 137, 255, 186, 255, 214, 255, 243, 255, 235, 255, 233, 255, 3, 0, 210, 255, 193, 255, 213, 255, 226, 255, 223, 255, 209, 255, 210, 255, 186, 255, 237, 255, 224, 255, 233, 255, 191, 255, 219, 255, 192, 255, 56, 2, 31, 0, 144, 0, 145, 1, 78, 0, 31, 0, 6, 0, 247, 255, 236, 255, 67, 0, 247, 255, 42, 2, 46, 1, 6, 0, 15, 0, 21, 0, 182, 0, 219, 0, 241, 255, 251, 255, 252, 255, 236, 255, 232, 255, 218, 1, 182, 2, 238, 255, 131, 0, 152, 0, 131, 1, 42, 0, 214, 255, 203, 255, 227, 255, 221, 255, 215, 255, 216, 255, 219, 255, 243, 255, 234, 255, 231, 255, 114, 248, 154, 255, 55, 255, 145, 255, 254, 255, 163, 1, 211, 0, 213, 255, 108, 0, 75, 1, 186, 255, 167, 255, 180, 1, 199, 2, 87, 2, 90, 0, 208, 1, 29, 0, 193, 0, 171, 255, 208, 255, 180, 0, 213, 254, 205, 255, 198, 255, 207, 255, 22, 0, 160, 255, 134, 255, 207, 255, 196, 255, 217, 255, 156, 255, 196, 255, 202, 255, 207, 255, 6, 0, 161, 0, 204, 255, 206, 255, 225, 255, 217, 255, 210, 255, 210, 255, 206, 1, 99, 2, 85, 2, 5, 3, 72, 0, 213, 255, 205, 255, 206, 255, 28, 0, 52, 1, 208, 255, 212, 255, 225, 255, 4, 0, 197, 255, 108, 1, 210, 255, 5, 0, 16, 0, 240, 255, 1, 1, 91, 0, 149, 0, 90, 0, 165, 0, 129, 1, 145, 1, 36, 1, 130, 1, 118, 1, 103, 1, 36, 1, 244, 0, 235, 0, 217, 0, 210, 0, 235, 0, 238, 0, 29, 1, 215, 0, 11, 1, 230, 0, 39, 1, 194, 0, 73, 1, 75, 1, 26, 2, 109, 1, 197, 2, 94, 3, 5, 1, 105, 2, 57, 2, 157, 2, 227, 1, 181, 2, 244, 1, 128, 2, 87, 2, 114, 2, 148, 1, 54, 1, 228, 0, 210, 0, 246, 1, 14, 2, 209, 1, 18, 2, 4, 2, 247, 2, 46, 3, 80, 3, 217, 3, 142, 2, 162, 2, 43, 2, 16, 3, 201, 2, 224, 2, 0, 1, 166, 1, 250, 0, 73, 2, 228, 1, 28, 2, 62, 2, 233, 1, 211, 1, 177, 2, 75, 2, 148, 2, 218, 2, 164, 2, 32, 3, 56, 2, 121, 2, 81, 2, 73, 2, 161, 2, 170, 2, 253, 1, 18, 2, 5, 2, 118, 1, 130, 1, 189, 2, 195, 1, 233, 1, 230, 1, 229, 1, 252, 0, 85, 1, 255, 0, 11, 1, 6, 2, 108, 1, 164, 1, 87, 1, 229, 239, 86, 240, 19, 241, 64, 242, 189, 240, 118, 240, 136, 241, 144, 241, 205, 241, 252, 240, 155, 242, 16, 242, 60, 242, 150, 241, 185, 241, 141, 241, 190, 245, 142, 254, 172, 242, 205, 243, 213, 244, 202, 244, 124, 251, 197, 241, 145, 242, 200, 241, 169, 244, 220, 244, 156, 244, 91, 246, 109, 245, 247, 248, 110, 245, 238, 244, 185, 245, 81, 9, 119, 0, 131, 1, 10, 248, 218, 0, 198, 255, 139, 255, 68, 2, 79, 253, 96, 241, 104, 243, 149, 242, 67, 245, 203, 243, 144, 243, 251, 244, 45, 243, 101, 246, 165, 245, 113, 246, 208, 245, 89, 2, 174, 1, 75, 6, 243, 7, 12, 3, 198, 4, 44, 3, 255, 255, 34, 8, 112, 2, 248, 4, 223, 2, 110, 4, 101, 6, 117, 4, 185, 3, 104, 4, 82, 4, 118, 3, 156, 3, 111, 5, 231, 5, 151, 2, 113, 6, 54, 4, 55, 6, 186, 242, 145, 245, 70, 244, 121, 243, 216, 244, 221, 6, 168, 0, 108, 3, 87, 255, 45, 255, 35, 255, 215, 244, 193, 253, 13, 0, 200, 255, 13, 0, 226, 255, 198, 252, 198, 5, 79, 4, 107, 2, 37, 7, 120, 4, 168, 3, 252, 0, 171, 2, 183, 1, 140, 7, 156, 10, 242, 7, 21, 7, 146, 7, 164, 7, 139, 8, 251, 7, 185, 6, 174, 255, 59, 8, 182, 7, 70, 3, 110, 1, 144, 1, 42, 5, 59, 4, 38, 7, 134, 8, 172, 7, 87, 7, 90, 5, 74, 5, 110, 6, 53, 5, 173, 5, 35, 10, 48, 6, 218, 5, 8, 8, 45, 8, 170, 5, 179, 8, 27, 8, 224, 8, 223, 9, 19, 10, 61, 8, 47, 13, 174, 13, 111, 10, 255, 10, 22, 12, 108, 12, 87, 10, 66, 6, 85, 8, 73, 8, 68, 6, 209, 8, 213, 7, 210, 253, 125, 1, 106, 255, 26, 5, 106, 4, 65, 6, 134, 7, 173, 6, 55, 5, 106, 6, 163, 5, 27, 9, 63, 8, 41, 4, 177, 6, 184, 7, 242, 4, 95, 5, 180, 5, 49, 3, 251, 8, 254, 4, 67, 5, 87, 8, 180, 7, 255, 6, 222, 6, 93, 7, 241, 5, 213, 6, 234, 6, 158, 9, 184, 5, 216, 5, 155, 8, 15, 5, 193, 6, 191, 8, 112, 5, 1, 5, 223, 5, 43, 7, 71, 6, 1, 7, 101, 7, 102, 8, 253, 6, 108, 5, 54, 3, 232, 2, 227, 2, 116, 2, 73, 2, 248, 3, 59, 4, 184, 8, 222, 10, 218, 7, 167, 4, 194, 3, 235, 2, 230, 2, 29, 3, 141, 2, 157, 4, 105, 3, 90, 4, 232, 2, 221, 4, 184, 2, 181, 255, 39, 3, 172, 0, 211, 255, 96, 0, 41, 7, 156, 5, 83, 1, 196, 1, 134, 2, 207, 4, 20, 3, 70, 6, 111, 8, 244, 3, 121, 255, 110, 7, 56, 4, 209, 1, 9, 3, 152, 3, 70, 1, 176, 3, 242, 2, 98, 3, 25, 4, 114, 4, 15, 3, 234, 2, 4, 4, 88, 4, 182, 3, 76, 4, 47, 3, 137, 6, 139, 8, 26, 5, 141, 5, 56, 7, 232, 5, 99, 4, 34, 3, 193, 3, 241, 5, 234, 3, 64, 3, 134, 5, 29, 5, 253, 5, 223, 6, 242, 5, 51, 4, 122, 5, 143, 2, 17, 3, 229, 5, 200, 4, 16, 4, 125, 4, 115, 6, 110, 3, 8, 6, 24, 235, 80, 235, 62, 235, 15, 235, 217, 234, 224, 234, 196, 237, 175, 234, 32, 234, 24, 236, 153, 234, 155, 234, 138, 234, 156, 234, 106, 234, 1, 234, 105, 236, 112, 234, 162, 238, 45, 238, 249, 231, 134, 234, 89, 234, 15, 234, 80, 235, 158, 240, 28, 236, 31, 236, 52, 237, 76, 234, 134, 235, 227, 234, 2, 238, 53, 237, 133, 236, 20, 234, 185, 233, 118, 233, 82, 233, 40, 233, 235, 232, 86, 234, 198, 232, 28, 234, 241, 236, 97, 236, 56, 235, 203, 236, 88, 236, 28, 238, 122, 233, 61, 234, 56, 234, 44, 234, 213, 233, 37, 235, 196, 233, 72, 233, 209, 233, 200, 233, 170, 234, 182, 233, 212, 234, 242, 233, 29, 236, 142, 235, 188, 236, 75, 234, 168, 234, 165, 234, 116, 233, 123, 233, 235, 232, 54, 234, 164, 233, 138, 234, 78, 232, 196, 233, 248, 233, 179, 234, 54, 234, 27, 233, 122, 234, 49, 233, 91, 233, 240, 233, 175, 233, 208, 233, 255, 232, 104, 232, 57, 235, 32, 233, 36, 234, 182, 232, 98, 234, 28, 235, 15, 233, 234, 232, 175, 232, 47, 233, 206, 234, 235, 234, 209, 234, 51, 234, 232, 235, 174, 235, 232, 234, 255, 234, 116, 235, 96, 235, 227, 234, 245, 234, 212, 234, 1, 235, 233, 234, 31, 235, 15, 235, 103, 235, 92, 236, 180, 237, 200, 238, 73, 235, 253, 235, 177, 236, 207, 235, 177, 235, 200, 234, 249, 234, 67, 234, 99, 233, 103, 234, 227, 233, 91, 235, 154, 234, 144, 234, 137, 234, 166, 234, 155, 234, 64, 234, 237, 233, 113, 234, 253, 233, 127, 235, 123, 234, 21, 235, 134, 234, 139, 234, 177, 234, 199, 235, 134, 234, 177, 234, 208, 235, 46, 237, 90, 235, 56, 235, 203, 234, 2, 235, 42, 235, 182, 235, 151, 234, 19, 238, 172, 236, 167, 235, 31, 237, 157, 236, 55, 237, 148, 237, 167, 238, 197, 234, 117, 239, 68, 241, 75, 238, 140, 236, 170, 237, 238, 236, 238, 237, 248, 238, 172, 237, 230, 232, 190, 233, 74, 233, 76, 234, 2, 234, 109, 233, 63, 234, 217, 234, 231, 234, 151, 236, 82, 235, 159, 235, 93, 234, 68, 234, 225, 234, 6, 234, 144, 234, 181, 232, 79, 234, 196, 233, 25, 232, 57, 234, 240, 238, 81, 235, 67, 237, 14, 237, 46, 235, 179, 234, 145, 234, 92, 234, 190, 239, 77, 239, 154, 236, 236, 237, 244, 237, 35, 238, 61, 238, 22, 236, 155, 236, 67, 236, 100, 236, 230, 235, 43, 237, 33, 237, 50, 236, 109, 236, 191, 235, 114, 238, 67, 237, 188, 237, 86, 234, 223, 237, 249, 235, 171, 236, 200, 236, 108, 237, 93, 234, 121, 234, 29, 234, 121, 234, 161, 234, 231, 234, 209, 235, 199, 235, 42, 235, 123, 235, 239, 234, 169, 234, 151, 234, 113, 234, 192, 235, 88, 234, 106, 236, 23, 236, 55, 238, 227, 235, 146, 235, 30, 236, 40, 235, 229, 235, 120, 235, 73, 235, 182, 233, 249, 234, 103, 235, 168, 234, 181, 234, 203, 235, 253, 233, 192, 235, 47, 234, 162, 235, 31, 236, 220, 235, 93, 236, 33, 236, 167, 236, 11, 236, 111, 236, 42, 236, 210, 235, 246, 234, 170, 235, 98, 236, 41, 237, 10, 236, 237, 234, 54, 236, 174, 235, 204, 236, 148, 236, 255, 234, 177, 235, 72, 235, 90, 235, 225, 235, 253, 235, 165, 235, 111, 235, 62, 235, 124, 235, 240, 234, 165, 235, 117, 235, 112, 235, 125, 235, 15, 234, 18, 235, 251, 234, 68, 235, 187, 235, 128, 234, 237, 240, 7, 234, 137, 233, 217, 232, 136, 233, 90, 234, 15, 234, 56, 233, 30, 233, 65, 233, 206, 233, 191, 233, 165, 234, 10, 240, 53, 233, 195, 234, 200, 236, 249, 233, 224, 233, 246, 236, 74, 234, 244, 233, 112, 233, 4, 234, 53, 234, 84, 235, 196, 233, 34, 234, 119, 233, 86, 234, 93, 235, 15, 234, 153, 233, 142, 233, 26, 234, 68, 234, 66, 233, 183, 233, 139, 233, 174, 233, 244, 233, 162, 233, 120, 234, 239, 233, 231, 236, 21, 235, 60, 234, 153, 233, 56, 233, 135, 233, 157, 233, 223, 231, 242, 234, 154, 235, 20, 235, 200, 236, 215, 234, 207, 234, 123, 235, 230, 234, 114, 234, 25, 234, 53, 235, 233, 233, 151, 233, 112, 233, 100, 233, 89, 232, 73, 232, 148, 234, 114, 233, 186, 235, 95, 234, 248, 234, 204, 233, 173, 232, 104, 233, 8, 233, 97, 233, 142, 233, 41, 233, 84, 233, 113, 239, 27, 238, 201, 238, 94, 239, 57, 238, 214, 238, 217, 237, 83, 238, 53, 238, 38, 240, 186, 239, 225, 240, 241, 239, 154, 239, 167, 238, 208, 238, 63, 239, 25, 239, 164, 238, 82, 238, 121, 239, 70, 238, 161, 238, 61, 238, 248, 238, 244, 238, 168, 240, 141, 238, 76, 238, 148, 238, 163, 239, 170, 239, 195, 239, 136, 239, 252, 238, 87, 239, 52, 240, 19, 239, 94, 240, 192, 237, 70, 238, 196, 237, 144, 238, 83, 238, 106, 238, 132, 238, 208, 237, 223, 238, 144, 240, 37, 239, 97, 239, 134, 238, 236, 238, 243, 238, 4, 239, 234, 238, 7, 239, 143, 238, 147, 238, 187, 239, 57, 237, 125, 236, 234, 236, 65, 236, 222, 236, 91, 237, 237, 236, 113, 236, 65, 237, 146, 238, 47, 239, 101, 238, 248, 238, 96, 238, 116, 238, 98, 239, 202, 238, 167, 238, 8, 237, 73, 237, 203, 237, 184, 237, 144, 237, 55, 237, 253, 237, 197, 237, 53, 238, 252, 236, 239, 237, 106, 237, 214, 238, 123, 238, 116, 237, 116, 238, 147, 238, 250, 237, 57, 238, 248, 237, 0, 238, 94, 238, 126, 239, 34, 238, 199, 238, 241, 238, 200, 238, 60, 238, 71, 238, 200, 238, 126, 1, 232, 255, 131, 0, 126, 255, 69, 2, 56, 1, 31, 0, 205, 1, 68, 0, 29, 240, 158, 240, 139, 240, 177, 240, 91, 240, 228, 239, 202, 241, 147, 242, 178, 240, 163, 240, 251, 241, 132, 241, 77, 251, 166, 242, 10, 255, 63, 240, 47, 241, 217, 240, 99, 239, 107, 241, 43, 242, 224, 237, 246, 238, 148, 238, 30, 239, 188, 238, 43, 243, 126, 238, 22, 239, 51, 238, 64, 239, 174, 239, 65, 238, 156, 239, 253, 239, 25, 240, 2, 240, 9, 241, 231, 238, 33, 239, 186, 241, 255, 238, 229, 241, 144, 239, 148, 239, 169, 239, 127, 239, 157, 239, 183, 239, 155, 239, 52, 238, 193, 240, 240, 241, 145, 240, 176, 240, 102, 241, 229, 240, 140, 240, 2, 241, 177, 240, 170, 241, 90, 241, 147, 241, 244, 240, 21, 241, 203, 240, 208, 240, 5, 240, 78, 241, 111, 239, 15, 239, 213, 239, 81, 240, 43, 240, 217, 237, 85, 240, 231, 239, 3, 240, 101, 239, 87, 240, 48, 240, 80, 240, 138, 239, 93, 240, 138, 239, 95, 240, 251, 239, 139, 240, 39, 241, 9, 240, 5, 240, 173, 240, 97, 240, 74, 240, 162, 240, 211, 239, 123, 239, 206, 239, 153, 239, 181, 234, 47, 235, 77, 233, 119, 235, 80, 235, 169, 234, 165, 234, 228, 234, 7, 235, 198, 236, 146, 232, 58, 236, 100, 234, 12, 234, 210, 234, 46, 235, 71, 235, 176, 234, 44, 235, 177, 234, 23, 236, 44, 235, 148, 234, 26, 234, 141, 234, 101, 234, 201, 234, 78, 236, 143, 234, 235, 234, 120, 236, 233, 236, 114, 236, 110, 237, 161, 236, 32, 237, 102, 236, 149, 236, 112, 236, 200, 237, 236, 236, 152, 236, 186, 236, 104, 237, 87, 236, 40, 237, 139, 236, 21, 237, 20, 237, 23, 237, 241, 236, 100, 236, 203, 236, 127, 236, 153, 237, 137, 237, 235, 236, 188, 237, 105, 237, 152, 236, 217, 236, 189, 236, 159, 240, 215, 236, 34, 237, 189, 236, 106, 238, 81, 237, 88, 236, 186, 235, 187, 235, 96, 236, 151, 235, 253, 235, 44, 235, 68, 237, 67, 236, 251, 235, 189, 235, 171, 235, 166, 235, 102, 236, 41, 236, 143, 236, 170, 235, 89, 235, 208, 235, 245, 236, 83, 235, 134, 236, 83, 237, 62, 235, 56, 237, 121, 235, 137, 234, 65, 236, 36, 235, 94, 235, 119, 235, 97, 234, 145, 235, 78, 234, 8, 235, 89, 235, 164, 235, 152, 235, 232, 235, 251, 234, 133, 240, 111, 240, 168, 239, 147, 239, 98, 239, 10, 239, 168, 240, 6, 239, 179, 239, 223, 238, 162, 240, 26, 240, 24, 238, 129, 237, 15, 239, 95, 239, 231, 238, 251, 237, 249, 238, 221, 239, 231, 238, 186, 239, 14, 238, 146, 237, 223, 237, 254, 237, 180, 238, 155, 235, 91, 235, 206, 236, 32, 236, 218, 236, 181, 236, 194, 236, 105, 241, 87, 238, 158, 238, 122, 238, 143, 237, 21, 238, 71, 237, 227, 237, 199, 237, 66, 237, 202, 236, 94, 237, 80, 236, 68, 237, 62, 237, 33, 237, 255, 236, 80, 237, 115, 237, 78, 237, 153, 236, 219, 236, 191, 236, 129, 238, 178, 236, 179, 236, 91, 236, 3, 236, 200, 236, 84, 236, 104, 236, 141, 236, 100, 239, 126, 239, 129, 238, 126, 240, 117, 238, 190, 236, 171, 236, 23, 237, 102, 238, 87, 240, 37, 238, 194, 238, 26, 238, 238, 237, 95, 237, 213, 237, 94, 237, 153, 238, 64, 240, 13, 239, 97, 239, 148, 241, 73, 240, 88, 237, 226, 236, 147, 238, 46, 237, 4, 238, 41, 238, 198, 238, 117, 240, 33, 240, 187, 240, 184, 240, 23, 239, 8, 240, 254, 238, 115, 239, 146, 239, 253, 239, 91, 235, 194, 235, 194, 235, 150, 234, 220, 234, 164, 235, 92, 234, 229, 238, 128, 237, 73, 235, 231, 237, 4, 238, 153, 238, 0, 235, 193, 234, 56, 234, 208, 237, 133, 236, 94, 237, 223, 236, 144, 238, 31, 238, 120, 237, 74, 232, 239, 237, 178, 237, 60, 246, 98, 244, 253, 244, 108, 244, 123, 242, 240, 242, 252, 241, 34, 240, 116, 240, 36, 240, 249, 239, 81, 239, 9, 241, 165, 242, 221, 239, 103, 240, 163, 239, 66, 241, 7, 240, 97, 241, 17, 240, 39, 240, 194, 240, 133, 241, 200, 240, 187, 241, 111, 237, 196, 238, 21, 238, 232, 237, 70, 238, 202, 239, 135, 239, 169, 239, 112, 239, 16, 239, 0, 240, 224, 238, 135, 239, 130, 239, 106, 239, 176, 239, 251, 238, 222, 238, 240, 234, 46, 235, 65, 235, 243, 234, 237, 234, 23, 236, 235, 233, 93, 234, 203, 233, 90, 236, 165, 234, 38, 234, 224, 235, 111, 235, 242, 234, 32, 235, 209, 236, 230, 235, 6, 236, 199, 234, 72, 233, 108, 233, 162, 237, 227, 239, 61, 238, 68, 237, 67, 238, 183, 236, 85, 237, 155, 236, 138, 238, 137, 238, 222, 237, 237, 236, 59, 237, 97, 243, 223, 237, 87, 238, 6, 237, 158, 236, 84, 238, 151, 235, 219, 237, 75, 237, 94, 237, 152, 237, 74, 237, 86, 237, 187, 234, 36, 235, 35, 234, 214, 233, 42, 235, 72, 234, 108, 234, 242, 235, 19, 236, 204, 236, 32, 237, 20, 239, 229, 237, 116, 236, 209, 237, 243, 235, 94, 237, 90, 235, 14, 233, 160, 235, 93, 236, 89, 236, 87, 236, 235, 234, 158, 236, 57, 234, 214, 235, 43, 237, 46, 237, 138, 237, 160, 236, 27, 237, 103, 237, 203, 236, 149, 238, 16, 237, 218, 236, 227, 236, 31, 236, 8, 237, 169, 237, 59, 237, 159, 236, 135, 237, 21, 0, 47, 0, 254, 255, 156, 255, 95, 1, 206, 6, 112, 2, 79, 253, 240, 0, 103, 255, 205, 3, 21, 0, 26, 242, 171, 240, 76, 246, 232, 242, 123, 241, 176, 241, 195, 246, 182, 6, 253, 250, 206, 255, 114, 245, 79, 245, 2, 241, 36, 245, 231, 238, 5, 0, 214, 4, 28, 237, 191, 237, 200, 237, 125, 240, 50, 238, 49, 239, 162, 237, 81, 238, 186, 238, 217, 3, 69, 3, 13, 0, 111, 0, 107, 252, 118, 2, 168, 248, 34, 241, 6, 243, 135, 1, 23, 239, 179, 237, 226, 238, 185, 239, 184, 237, 1, 239, 223, 237, 3, 240, 244, 238, 91, 238, 65, 239, 169, 239, 23, 239, 65, 239, 26, 238, 251, 253, 35, 239, 111, 238, 105, 240, 89, 238, 59, 239, 164, 239, 93, 240, 5, 238, 155, 238, 171, 238, 81, 0, 98, 240, 170, 0, 23, 0, 9, 253, 187, 237, 59, 239, 75, 238, 83, 238, 134, 239, 104, 240, 81, 241, 159, 240, 126, 239, 62, 240, 102, 239, 162, 239, 53, 240, 83, 235, 189, 234, 59, 234, 107, 235, 211, 234, 254, 236, 83, 236, 174, 235, 141, 235, 61, 236, 224, 235, 185, 234, 63, 236, 93, 236, 204, 234, 248, 234, 73, 234, 68, 234, 202, 235, 80, 235, 110, 235, 171, 234, 197, 237, 235, 237, 116, 238, 101, 239, 97, 239, 30, 237, 62, 238, 159, 237, 137, 238, 36, 237, 82, 237, 204, 237, 70, 238, 92, 237, 143, 238, 223, 237, 45, 237, 161, 238, 138, 237, 17, 238, 171, 237, 82, 238, 50, 244, 85, 242, 14, 243, 65, 243, 116, 238, 158, 236, 98, 240, 96, 238, 160, 236, 31, 237, 65, 240, 103, 241, 98, 237, 144, 237, 152, 237, 74, 237, 21, 237, 129, 236, 148, 236, 174, 239, 14, 238, 134, 238, 241, 236, 178, 236, 21, 237, 215, 235, 100, 236, 148, 236, 157, 235, 18, 236, 162, 235, 253, 235, 227, 235, 114, 235, 102, 235, 21, 237, 99, 236, 170, 235, 180, 235, 216, 235, 59, 0, 138, 0, 146, 0, 127, 0, 102, 0, 44, 1, 79, 1, 71, 1, 77, 1, 159, 1, 24, 1, 230, 0, 169, 0, 122, 0, 111, 0, 131, 0, 31, 1, 210, 0, 27, 1, 226, 0, 10, 1, 148, 0, 121, 2, 41, 2, 28, 2, 89, 2, 139, 1, 62, 2, 21, 2, 197, 1, 67, 1, 70, 1, 169, 1, 126, 1, 185, 1, 100, 1, 134, 1, 118, 1, 236, 0, 217, 0, 193, 1, 30, 1, 96, 1, 74, 1, 127, 1, 20, 1, 117, 1, 135, 1, 173, 1, 43, 1, 129, 1, 8, 1, 61, 0, 155, 0, 212, 0, 114, 0, 182, 0, 168, 1, 37, 1, 116, 1, 243, 0, 62, 1, 64, 1, 72, 1, 5, 2, 216, 0, 225, 0, 180, 0, 41, 0, 66, 255, 49, 0, 164, 1, 190, 1, 169, 1, 118, 1, 145, 1, 87, 1, 155, 1, 120, 1, 4, 0, 179, 0, 38, 0, 1, 2, 133, 1, 153, 0, 89, 1, 48, 1, 47, 1, 132, 1, 192, 1, 50, 1, 166, 1, 152, 4, 64, 4, 184, 4, 34, 5, 118, 5, 115, 5, 45, 8, 42, 3, 203, 3, 131, 3, 127, 4, 173, 4, 177, 4, 49, 5, 149, 3, 6, 5, 131, 7, 153, 9, 127, 8, 223, 6, 215, 5, 96, 7, 180, 6, 13, 5, 97, 8, 184, 5, 92, 0, 20, 0, 55, 0, 150, 0, 34, 0, 84, 0, 105, 0, 48, 0, 105, 0, 173, 1, 217, 0, 12, 1, 57, 1, 255, 0, 97, 1, 93, 2, 232, 0, 212, 0, 208, 1, 180, 1, 187, 2, 136, 0, 246, 0, 154, 0, 77, 1, 121, 1, 243, 0, 235, 0, 205, 0, 128, 0, 78, 4, 23, 3, 246, 5, 6, 5, 101, 3, 109, 4, 182, 3, 2, 9, 209, 8, 67, 5, 93, 6, 250, 4, 174, 7, 153, 5, 105, 1, 207, 1, 214, 1, 37, 3, 58, 2, 90, 2, 11, 3, 170, 2, 124, 3, 31, 5, 85, 4, 185, 3, 157, 2, 211, 1, 35, 2, 216, 3, 162, 4, 205, 1, 79, 3, 139, 2, 193, 1, 31, 2, 227, 9, 187, 4, 254, 6, 219, 6, 141, 4, 88, 3, 196, 3, 226, 3, 218, 234, 189, 234, 248, 234, 219, 234, 83, 235, 224, 234, 129, 235, 113, 244, 225, 240, 163, 242, 117, 242, 227, 255, 159, 238, 82, 236, 232, 252, 224, 252, 108, 254, 211, 239, 125, 245, 180, 241, 218, 255, 188, 251, 152, 243, 153, 235, 232, 238, 98, 236, 3, 0, 211, 0, 224, 1, 71, 2, 156, 0, 28, 1, 123, 1, 214, 0, 255, 0, 15, 1, 22, 2, 100, 1, 108, 3, 49, 1, 113, 1, 133, 1, 225, 255, 48, 251, 78, 0, 18, 0, 36, 0, 3, 0, 88, 0, 52, 2, 225, 0, 178, 0, 69, 0, 51, 0, 130, 0, 178, 0, 147, 0, 101, 0, 221, 0, 156, 0, 12, 1, 234, 255, 22, 0, 235, 255, 143, 0, 84, 0, 62, 0, 92, 0, 66, 0, 127, 0, 147, 1, 116, 1, 27, 1, 247, 1, 55, 2, 178, 0, 211, 4, 89, 1, 87, 1, 14, 1, 0, 1, 232, 0, 223, 255, 94, 0, 249, 255, 252, 255, 1, 0, 236, 1, 1, 1, 96, 3, 57, 2, 5, 1, 242, 255, 18, 0, 241, 255, 23, 0, 147, 0, 153, 0, 123, 0, 37, 0, 142, 2, 90, 2, 155, 2, 66, 2, 20, 2, 83, 1, 96, 1, 113, 1, 84, 1, 101, 1, 161, 1, 43, 2, 70, 1, 50, 1, 100, 1, 37, 1, 50, 1, 127, 1, 79, 1, 220, 1, 145, 1, 190, 1, 97, 0, 157, 0, 112, 0, 51, 0, 56, 0, 214, 0, 191, 0, 187, 0, 150, 0, 142, 0, 183, 0, 139, 0, 20, 1, 34, 1, 114, 0, 65, 1, 239, 0, 73, 1, 140, 1, 94, 0, 120, 0, 104, 0, 71, 1, 119, 0, 33, 1, 25, 1, 153, 0, 52, 1, 218, 0, 215, 0, 57, 0, 130, 0, 241, 0, 131, 1, 97, 1, 223, 0, 157, 0, 33, 1, 254, 0, 230, 0, 25, 1, 200, 0, 7, 1, 185, 0, 206, 0, 214, 0, 253, 0, 20, 1, 248, 0, 238, 0, 193, 0, 246, 0, 175, 0, 204, 0, 90, 1, 249, 0, 11, 1, 37, 1, 12, 1, 150, 0, 212, 0, 185, 0, 100, 239, 165, 238, 17, 240, 114, 240, 232, 239, 230, 238, 90, 239, 118, 240, 149, 240, 41, 240, 47, 240, 150, 240, 56, 240, 217, 239, 173, 240, 85, 240, 13, 240, 103, 240, 146, 239, 111, 239, 36, 239, 175, 238, 242, 239, 190, 239, 155, 239, 187, 239, 174, 241, 83, 241, 138, 241, 47, 241, 132, 241, 37, 241, 82, 241, 207, 241, 157, 241, 77, 240, 245, 239, 86, 240, 102, 240, 141, 240, 122, 240, 193, 240, 96, 240, 218, 240, 117, 240, 173, 240, 168, 240, 57, 241, 237, 240, 222, 240, 3, 241, 222, 240, 254, 240, 66, 241, 34, 241, 74, 241, 167, 239, 216, 239, 204, 239, 58, 240, 84, 240, 26, 240, 165, 239, 186, 239, 142, 240, 119, 240, 115, 240, 213, 239, 174, 239, 79, 239, 159, 240, 8, 241, 157, 240, 158, 240, 109, 240, 67, 240, 189, 240, 195, 240, 125, 240, 195, 239, 233, 240, 146, 239, 206, 240, 244, 240, 25, 241, 162, 240, 72, 240, 107, 240, 68, 240, 196, 238, 136, 240, 197, 240, 228, 239, 45, 240, 98, 239, 139, 239, 236, 239, 83, 240, 238, 239, 215, 239, 107, 249, 151, 247, 45, 246, 172, 245, 78, 248, 132, 246, 72, 244, 144, 245, 216, 244, 118, 241, 42, 242, 189, 241, 156, 242, 124, 242, 76, 242, 184, 242, 111, 242, 251, 243, 17, 243, 137, 243, 108, 242, 143, 243, 46, 243, 36, 243, 148, 243, 205, 243, 19, 245, 108, 245, 151, 245, 101, 245, 154, 242, 236, 241, 52, 242, 95, 243, 82, 242, 201, 242, 90, 240, 30, 242, 177, 240, 130, 243, 66, 243, 199, 243, 213, 241, 97, 242, 231, 241, 214, 241, 187, 242, 168, 241, 136, 241, 120, 241, 6, 241, 94, 240, 228, 240, 92, 240, 201, 242, 171, 241, 233, 240, 69, 241, 168, 241, 42, 239, 205, 241, 254, 241, 240, 241, 119, 243, 161, 242, 198, 242, 39, 242, 134, 242, 214, 242, 152, 242, 99, 242, 139, 242, 147, 242, 32, 245, 240, 243, 18, 243, 253, 242, 85, 243, 107, 243, 39, 243, 132, 243, 192, 242, 57, 243, 105, 242, 56, 243, 97, 243, 226, 242, 104, 243, 22, 243, 22, 243, 229, 241, 186, 242, 209, 241, 170, 241, 57, 242, 95, 243, 127, 242, 177, 242, 28, 243, 93, 242, 55, 244, 74, 242, 204, 242, 214, 243, 223, 242, 36, 242, 129, 242, 135, 242, 111, 0, 132, 2, 44, 255, 234, 249, 174, 6, 60, 0, 36, 0, 171, 242, 227, 243, 195, 0, 44, 254, 152, 246, 153, 255, 42, 0, 100, 7, 249, 255, 241, 255, 11, 0, 5, 0, 216, 2, 151, 244, 115, 250, 237, 245, 255, 251, 11, 254, 253, 254, 1, 240, 218, 240, 192, 240, 9, 241, 63, 241, 185, 241, 206, 241, 18, 242, 107, 241, 193, 241, 186, 243, 116, 243, 73, 243, 144, 244, 248, 241, 173, 243, 133, 240, 130, 241, 128, 242, 92, 242, 51, 243, 162, 241, 255, 252, 3, 243, 102, 242, 205, 241, 185, 239, 192, 241, 58, 242, 126, 0, 90, 244, 135, 1, 121, 243, 48, 242, 25, 242, 4, 0, 77, 4, 252, 3, 219, 236, 139, 0, 135, 241, 184, 7, 59, 4, 40, 2, 150, 240, 103, 242, 132, 241, 8, 244, 217, 243, 27, 243, 143, 242, 57, 244, 107, 244, 168, 245, 96, 244, 12, 244, 156, 242, 103, 243, 12, 243, 92, 243, 206, 243, 93, 240, 48, 238, 9, 242, 126, 242, 233, 242, 184, 252, 110, 245, 85, 245, 31, 243, 129, 243, 92, 245, 250, 244, 149, 245, 249, 241, 99, 241, 3, 242, 178, 241, 14, 241, 44, 243, 182, 242, 12, 241, 170, 241, 220, 241, 112, 241, 40, 241, 37, 241, 156, 239, 214, 240, 62, 241, 231, 240, 252, 240, 200, 240, 99, 241, 48, 241, 42, 241, 82, 242, 221, 242, 158, 244, 186, 242, 0, 244, 107, 241, 141, 242, 254, 242, 103, 242, 217, 242, 15, 243, 157, 244, 64, 243, 107, 245, 123, 243, 74, 243, 27, 243, 165, 243, 209, 243, 81, 244, 113, 244, 195, 245, 107, 240, 100, 240, 68, 240, 246, 240, 119, 240, 54, 241, 84, 243, 244, 240, 199, 240, 230, 242, 223, 241, 104, 240, 96, 240, 65, 241, 113, 241, 64, 241, 12, 241, 44, 239, 231, 243, 45, 240, 66, 240, 109, 240, 113, 244, 31, 243, 185, 243, 39, 244, 245, 242, 113, 237, 243, 242, 151, 240, 212, 241, 147, 242, 41, 239, 72, 242, 187, 241, 17, 242, 213, 244, 106, 241, 36, 236, 215, 242, 174, 0, 216, 0, 119, 0, 212, 0, 51, 0, 76, 0, 43, 0, 174, 0, 155, 3, 9, 1, 207, 3, 189, 1, 161, 3, 87, 0, 79, 0, 104, 0, 43, 2, 67, 0, 100, 0, 35, 0, 171, 4, 56, 2, 41, 1, 89, 0, 26, 1, 172, 0, 11, 244, 39, 250, 57, 251, 130, 243, 35, 241, 121, 246, 237, 255, 51, 0, 58, 0, 59, 0, 119, 0, 220, 0, 47, 0, 89, 3, 185, 0, 174, 255, 59, 0, 217, 0, 20, 0, 7, 0, 249, 0, 98, 0, 187, 0, 14, 255, 225, 0, 140, 1, 233, 0, 211, 0, 246, 0, 212, 0, 228, 0, 177, 0, 172, 0, 214, 0, 152, 0, 110, 0, 102, 0, 69, 0, 117, 0, 136, 0, 113, 0, 149, 0, 117, 0, 181, 0, 90, 0, 104, 0, 74, 0, 149, 0, 156, 0, 152, 0, 95, 0, 135, 0, 99, 0, 200, 0, 127, 0, 193, 0, 17, 2, 70, 1, 30, 1, 164, 1, 221, 3, 64, 0, 51, 6, 31, 2, 180, 1, 146, 2, 113, 0, 66, 4, 154, 0, 131, 0, 111, 0, 117, 4, 132, 0, 218, 1, 185, 234, 184, 234, 111, 234, 164, 234, 10, 235, 108, 235, 43, 235, 2, 0, 111, 235, 196, 238, 213, 234, 197, 234, 111, 236, 193, 234, 139, 234, 140, 234, 94, 233, 166, 233, 183, 234, 55, 234, 116, 234, 169, 235, 200, 234, 100, 234, 85, 234, 81, 234, 30, 247, 106, 250, 207, 251, 144, 247, 27, 249, 12, 244, 201, 251, 106, 255, 58, 1, 25, 245, 14, 239, 26, 244, 133, 247, 245, 240, 75, 251, 65, 239, 234, 241, 210, 247, 202, 255, 90, 252, 255, 244, 179, 242, 255, 254, 53, 1, 237, 241, 25, 251, 227, 247, 30, 250, 208, 244, 238, 250, 249, 239, 19, 242, 221, 241, 103, 238, 186, 236, 148, 238, 107, 238, 198, 234, 221, 234, 107, 248, 143, 226, 131, 236, 120, 225, 54, 246, 144, 239, 128, 240, 153, 240, 130, 238, 3, 240, 143, 238, 36, 251, 226, 235, 199, 254, 248, 255, 71, 251, 24, 236, 130, 249, 127, 255, 125, 252, 0, 0, 132, 244, 246, 246, 99, 0, 35, 243, 8, 255, 122, 3, 86, 235, 205, 234, 243, 234, 162, 235, 45, 244, 250, 255, 132, 246, 120, 255, 218, 246, 225, 246, 77, 247, 75, 245, 67, 246, 226, 245, 131, 251, 8, 246, 111, 245, 187, 243, 27, 243, 215, 246, 195, 243, 134, 242, 131, 244, 247, 242, 149, 244, 5, 245, 49, 246, 89, 250, 208, 249, 165, 249, 61, 250, 1, 250, 146, 243, 169, 246, 84, 243, 9, 245, 112, 243, 142, 244, 241, 0, 20, 1, 219, 0, 195, 11, 13, 7, 206, 1, 104, 1, 211, 1, 255, 10, 190, 250, 1, 253, 35, 0, 174, 241, 28, 244, 23, 242, 43, 4, 40, 0, 16, 6, 81, 245, 204, 240, 89, 244, 118, 3, 31, 1, 70, 2, 60, 246, 94, 244, 155, 242, 71, 0, 203, 255, 136, 0, 241, 249, 166, 250, 57, 248, 209, 244, 80, 253, 42, 253, 101, 242, 59, 243, 99, 244, 233, 248, 112, 0, 188, 250, 91, 5, 44, 2, 164, 255, 212, 255, 102, 0, 236, 247, 137, 2, 172, 255, 71, 1, 70, 243, 0, 0, 164, 244, 62, 0, 242, 255, 214, 1, 12, 244, 204, 250, 92, 242, 9, 246, 76, 247, 241, 243, 204, 246, 168, 242, 97, 242, 164, 242, 233, 242, 52, 244, 225, 243, 246, 248, 179, 243, 245, 243, 162, 244, 12, 252, 52, 244, 17, 249, 70, 240, 234, 240, 60, 236, 219, 236, 47, 238, 20, 237, 4, 241, 72, 239, 138, 252, 181, 243, 190, 255, 88, 237, 179, 236, 96, 0, 87, 0, 105, 248, 117, 1, 203, 2, 216, 1, 22, 0, 153, 238, 235, 246, 100, 248, 117, 246, 30, 241, 61, 241, 95, 245, 1, 240, 92, 0, 102, 245, 77, 246, 100, 246, 112, 1, 77, 243, 209, 241, 123, 241, 169, 242, 248, 239, 220, 239, 0, 243, 64, 240, 29, 241, 59, 241, 237, 241, 126, 240, 60, 1, 182, 0, 228, 0, 139, 1, 157, 8, 95, 0, 116, 0, 210, 11, 194, 0, 104, 1, 136, 0, 151, 0, 11, 8, 206, 0, 22, 4, 86, 9, 105, 0, 254, 2, 171, 1, 44, 1, 238, 10, 167, 10, 184, 246, 78, 254, 125, 252, 0, 0, 237, 255, 84, 0, 147, 4, 23, 0, 11, 0, 71, 0, 170, 0, 186, 0, 29, 1, 237, 6, 29, 0, 185, 0, 34, 0, 79, 0, 191, 3, 16, 9, 212, 8, 221, 9, 30, 6, 205, 7, 53, 11, 174, 4, 86, 7, 74, 4, 12, 9, 52, 10, 93, 3, 104, 2, 148, 5, 31, 5, 14, 6, 189, 2, 39, 5, 49, 6, 29, 5, 7, 5, 55, 247, 234, 2, 246, 12, 235, 4, 249, 6, 41, 1, 113, 3, 156, 247, 9, 249, 62, 244, 139, 4, 5, 0, 47, 1, 248, 255, 4, 0, 108, 5, 71, 9, 185, 9, 14, 7, 84, 7, 128, 8, 62, 8, 98, 7, 52, 9, 175, 7, 6, 8, 9, 0, 45, 0, 73, 0, 42, 0, 219, 255, 0, 0, 221, 255, 142, 2, 220, 1, 24, 0, 187, 0, 79, 0, 166, 0, 116, 0, 101, 241, 125, 244, 3, 245, 43, 253, 77, 249, 229, 249, 235, 255, 26, 251, 180, 255, 12, 0, 242, 255, 225, 255, 24, 8, 42, 7, 32, 7, 146, 5, 155, 5, 112, 255, 69, 0, 7, 0, 196, 0, 140, 1, 75, 1, 231, 1, 44, 2, 186, 0, 206, 0, 247, 8, 216, 0, 187, 3, 116, 249, 172, 247, 95, 248, 204, 247, 217, 244, 131, 244, 49, 244, 5, 242, 108, 243, 113, 242, 75, 246, 214, 244, 18, 242, 198, 241, 236, 242, 161, 241, 91, 242, 187, 241, 151, 241, 145, 243, 20, 242, 110, 243, 13, 255, 233, 255, 96, 0, 3, 0, 4, 0, 236, 255, 245, 255, 156, 6, 149, 6, 42, 0, 55, 0, 26, 0, 158, 255, 200, 1, 164, 3, 16, 2, 189, 255, 18, 245, 110, 0, 247, 0, 34, 236, 217, 255, 192, 255, 95, 2, 165, 1, 90, 0, 5, 243, 15, 240, 250, 239, 49, 242, 235, 241, 112, 242, 29, 240, 29, 242, 86, 241, 122, 240, 254, 240, 191, 240, 80, 240, 103, 240, 218, 7, 80, 0, 171, 4, 197, 234, 222, 255, 203, 255, 71, 242, 102, 237, 174, 240, 187, 239, 120, 240, 19, 240, 74, 243, 26, 244, 125, 243, 189, 242, 142, 242, 198, 255, 179, 241, 227, 232, 31, 249, 78, 240, 155, 241, 138, 242, 249, 241, 133, 241, 136, 241, 127, 241, 73, 241, 19, 242, 149, 234, 178, 239, 6, 236, 161, 236, 117, 236, 221, 252, 180, 252, 42, 236, 221, 251, 236, 251, 35, 247, 112, 238, 243, 236, 176, 248, 73, 236, 84, 236, 191, 237, 225, 237, 98, 237, 26, 238, 254, 236, 95, 238, 64, 0, 255, 255, 203, 253, 174, 255, 152, 247, 16, 0, 89, 0, 79, 247, 134, 245, 210, 242, 215, 255, 104, 255, 221, 255, 229, 243, 57, 243, 125, 243, 1, 0, 87, 255, 40, 0, 42, 0, 31, 0, 19, 0, 254, 255, 81, 255, 221, 255, 239, 255, 158, 249, 171, 253, 16, 232, 221, 239, 221, 244, 252, 236, 0, 0, 243, 255, 201, 251, 162, 0, 14, 0, 0, 0, 55, 0, 9, 251, 252, 255, 249, 255, 129, 247, 84, 242, 238, 241, 98, 238, 242, 253, 3, 0, 15, 0, 2, 245, 225, 241, 162, 247, 243, 252, 11, 0, 230, 255, 181, 252, 254, 255, 211, 255, 35, 252, 58, 255, 229, 255, 9, 0, 67, 255, 130, 249, 0, 0, 251, 255, 28, 254, 5, 0, 81, 253, 157, 254, 227, 0, 7, 1, 74, 6, 55, 9, 189, 2, 125, 0, 228, 7, 236, 255, 99, 0, 6, 0, 44, 2, 116, 0, 239, 242, 130, 241, 218, 255, 93, 247, 94, 249, 151, 245, 26, 252, 34, 0, 200, 255, 6, 0, 210, 255, 18, 235, 105, 248, 193, 255, 44, 250, 43, 248, 196, 242, 34, 238, 44, 238, 3, 0, 72, 238, 98, 241, 254, 255, 224, 1, 160, 253, 12, 241, 239, 255, 8, 254, 39, 243, 5, 244, 4, 238, 199, 236, 0, 0, 218, 252, 239, 255, 111, 255, 23, 249, 90, 241, 100, 241, 103, 241, 140, 241, 124, 241, 54, 243, 254, 248, 17, 244, 109, 242, 109, 245, 26, 243, 180, 255, 242, 247, 15, 242, 190, 247, 21, 243, 46, 245, 252, 0, 69, 0, 1, 1, 109, 0, 235, 255, 218, 254, 220, 255, 204, 255, 240, 255, 24, 0, 162, 241, 253, 255, 182, 248, 106, 241, 137, 254, 18, 0, 235, 255, 254, 255, 176, 0, 137, 0, 98, 0, 140, 0, 40, 1, 125, 0, 159, 0, 99, 0, 96, 0, 138, 0, 116, 0, 126, 0, 112, 0, 73, 0, 218, 0, 122, 0, 221, 0, 180, 0, 229, 0, 51, 1, 123, 0, 210, 0, 141, 0, 112, 0, 140, 0, 111, 0, 148, 0, 94, 0, 98, 0, 76, 0, 73, 0, 87, 0, 58, 0, 230, 0, 130, 0, 11, 1, 71, 0, 139, 0, 124, 0, 151, 0, 139, 0, 122, 0, 98, 0, 86, 0, 42, 0, 92, 0, 87, 0, 102, 0, 62, 0, 60, 0, 69, 0, 49, 0, 153, 1, 93, 1, 111, 1, 158, 2, 146, 2, 0, 2, 87, 2, 62, 2, 99, 3, 233, 0, 5, 1, 193, 1, 201, 0, 177, 0, 147, 0, 142, 2, 10, 1, 122, 2, 123, 1, 105, 1, 45, 1, 168, 2, 20, 2, 246, 1, 134, 0, 84, 1, 23, 1, 226, 3, 116, 2, 92, 3, 110, 0, 99, 0, 93, 0, 121, 0, 113, 0, 208, 0, 113, 0, 72, 0, 116, 0, 78, 0, 113, 0, 107, 0, 140, 0, 107, 0, 102, 0, 104, 0, 96, 0, 106, 0, 194, 0, 193, 0, 245, 0, 185, 0, 213, 0, 170, 0, 182, 0, 111, 0, 125, 0, 127, 0, 193, 0, 158, 0, 193, 0, 132, 0, 147, 0, 145, 0, 164, 0, 97, 0, 128, 0, 148, 0, 182, 0, 167, 0, 139, 0, 193, 0, 151, 0, 163, 0, 137, 0, 229, 255, 237, 255, 233, 255, 230, 255, 246, 255, 227, 255, 227, 255, 227, 255, 145, 0, 170, 0, 253, 0, 6, 0, 25, 0, 27, 0, 183, 0, 77, 0, 34, 0, 242, 255, 18, 0, 29, 0, 242, 255, 245, 255, 239, 255, 21, 0, 8, 0, 0, 0, 240, 255, 248, 255, 237, 255, 211, 0, 210, 1, 226, 0, 171, 0, 239, 0, 218, 0, 147, 0, 104, 0, 133, 0, 135, 0, 127, 0, 83, 0, 85, 0, 209, 0, 15, 1, 161, 1, 232, 0, 119, 0, 186, 0, 174, 0, 243, 0, 245, 0, 248, 0, 167, 0, 132, 0, 87, 0, 0, 1, 88, 0, 54, 0, 228, 0, 197, 0, 192, 0, 119, 0, 106, 0, 89, 0, 58, 0, 107, 0, 46, 1, 175, 0, 176, 0, 95, 0, 81, 0, 126, 0, 215, 0, 118, 7, 200, 7, 207, 6, 204, 12, 201, 9, 147, 2, 251, 10, 217, 7, 142, 15, 194, 15, 31, 14, 141, 14, 19, 4, 107, 7, 123, 1, 72, 3, 133, 14, 160, 3, 177, 2, 62, 2, 185, 1, 241, 10, 4, 10, 180, 9, 16, 1, 134, 2, 70, 4, 114, 12, 216, 11, 20, 12, 126, 1, 210, 3, 87, 2, 184, 1, 181, 1, 55, 1, 26, 12, 235, 2, 82, 14, 153, 0, 1, 2, 137, 0, 117, 3, 212, 0, 65, 1, 218, 0, 142, 1, 96, 1, 146, 16, 34, 14, 10, 17, 235, 7, 121, 11, 19, 16, 222, 3, 143, 5, 51, 8, 217, 3, 253, 11, 139, 6, 168, 0, 166, 0, 204, 0, 84, 0, 32, 0, 66, 0, 171, 0, 120, 0, 59, 0, 212, 0, 163, 0, 189, 0, 164, 0, 211, 0, 180, 0, 107, 0, 181, 0, 144, 0, 104, 0, 128, 0, 152, 0, 70, 0, 78, 0, 53, 0, 185, 0, 94, 1, 145, 0, 98, 0, 112, 0, 147, 0, 238, 7, 226, 1, 154, 13, 95, 5, 6, 2, 201, 0, 183, 0, 190, 0, 238, 0, 4, 1, 214, 0, 209, 6, 11, 1, 187, 0, 244, 0, 219, 2, 179, 1, 231, 2, 4, 1, 91, 1, 233, 1, 195, 0, 145, 0, 244, 1, 54, 2, 243, 0, 139, 1, 27, 1, 111, 2, 53, 2, 187, 0, 124, 1, 143, 0, 162, 0, 108, 0, 100, 0, 190, 0, 79, 1, 187, 0, 176, 0, 99, 0, 29, 0, 149, 0, 115, 0, 67, 0, 102, 0, 87, 0, 150, 0, 78, 0, 67, 0, 53, 0, 29, 0, 52, 1, 132, 1, 207, 0, 229, 0, 216, 0, 48, 1, 178, 0, 143, 0, 177, 0, 87, 0, 88, 1, 220, 2, 154, 1, 195, 1, 121, 1, 37, 1, 67, 1, 216, 1, 114, 1, 35, 2, 175, 1, 40, 2, 156, 0, 152, 0, 59, 1, 17, 1, 195, 1, 248, 0, 69, 1, 94, 2, 102, 1, 21, 2, 211, 0, 171, 0, 254, 0, 63, 1, 224, 0, 65, 0, 240, 0, 177, 0, 106, 0, 81, 0, 9, 1, 206, 0, 50, 1, 67, 1, 7, 1, 91, 0, 151, 0, 169, 0, 89, 2, 144, 2, 83, 1, 50, 2, 124, 1, 35, 3, 204, 2, 40, 1, 214, 0, 78, 1, 119, 0, 152, 0, 138, 0, 247, 0, 196, 0, 168, 0, 209, 3, 80, 1, 71, 4, 147, 1, 98, 0, 121, 1, 8, 0, 14, 1, 129, 0, 55, 2, 101, 2, 200, 1, 191, 1, 102, 1, 35, 2, 2, 1, 200, 1, 186, 1, 20, 2, 129, 254, 163, 254, 22, 252, 8, 2, 90, 1, 44, 0, 0, 0, 73, 0, 127, 0, 194, 2, 111, 2, 185, 1, 169, 1, 171, 2, 13, 2, 15, 2, 35, 2, 90, 2, 217, 1, 91, 2, 91, 2, 224, 0, 6, 5, 187, 249, 114, 252, 31, 252, 164, 250, 173, 242, 172, 244, 21, 245, 156, 254, 8, 251, 58, 1, 218, 0, 204, 0, 152, 255, 23, 254, 86, 253, 165, 254, 214, 1, 10, 250, 23, 255, 119, 254, 143, 254, 239, 244, 1, 253, 64, 245, 254, 0, 198, 0, 127, 1, 199, 0, 83, 0, 153, 255, 72, 0, 224, 255, 155, 255, 253, 255, 33, 1, 61, 0, 139, 4, 142, 1, 182, 1, 96, 0, 94, 0, 23, 0, 85, 1, 7, 1, 7, 1, 147, 1, 79, 1, 74, 1, 43, 1, 18, 1, 128, 1, 28, 1, 92, 1, 66, 1, 100, 1, 32, 1, 30, 1, 113, 1, 31, 1, 187, 0, 142, 2, 121, 2, 191, 2, 134, 1, 160, 1, 46, 2, 78, 2, 177, 1, 84, 1, 220, 0, 251, 0, 35, 1, 147, 248, 45, 246, 153, 247, 79, 244, 91, 244, 254, 245, 31, 250, 160, 246, 255, 254, 172, 0, 218, 0, 209, 0, 183, 255, 205, 0, 185, 255, 167, 245, 226, 244, 224, 243, 129, 1, 31, 0, 43, 0, 5, 0, 248, 0, 73, 0, 195, 0, 7, 1, 148, 0, 78, 246, 27, 0, 118, 254, 131, 1, 111, 1, 208, 1, 103, 1, 72, 1, 2, 2, 246, 0, 254, 0, 209, 0, 247, 1, 191, 1, 138, 2, 174, 1, 200, 1, 95, 1, 128, 2, 65, 2, 105, 1, 90, 0, 85, 0, 35, 0, 154, 0, 57, 0, 84, 0, 168, 0, 113, 0, 185, 0, 253, 0, 198, 0, 178, 0, 226, 0, 181, 0, 28, 1, 214, 0, 203, 0, 83, 0, 188, 0, 132, 0, 57, 0, 78, 0, 127, 3, 247, 1, 199, 2, 54, 2, 92, 1, 190, 0, 2, 1, 55, 1, 131, 0, 140, 0, 176, 0, 136, 0, 130, 0, 100, 0, 183, 0, 50, 3, 247, 0, 215, 0, 131, 1, 175, 3, 223, 0, 215, 0, 245, 255, 69, 0, 238, 255, 189, 0, 166, 0, 208, 0, 239, 0, 106, 0, 146, 0, 247, 0, 29, 1, 16, 1, 174, 255, 2, 0, 87, 2, 81, 4, 122, 255, 45, 1, 167, 0, 229, 0, 241, 0, 226, 4, 126, 0, 50, 2, 143, 1, 185, 255, 68, 2, 66, 5, 88, 0, 92, 0, 178, 0, 96, 0, 2, 1, 85, 0, 71, 0, 100, 3, 118, 0, 80, 0, 41, 4, 143, 3, 86, 253, 10, 4, 116, 4, 89, 5, 103, 4, 178, 3, 170, 1, 170, 255, 20, 249, 8, 250, 119, 255, 22, 248, 235, 255, 30, 250, 197, 247, 26, 0, 211, 251, 197, 254, 26, 0, 119, 2, 14, 0, 249, 254, 115, 0, 218, 0, 146, 0, 25, 2, 50, 0, 126, 0, 120, 0, 237, 3, 74, 5, 11, 1, 255, 2, 19, 6, 18, 1, 152, 5, 108, 1, 190, 0, 0, 0, 155, 1, 2, 0, 51, 0, 130, 0, 218, 1, 100, 0, 133, 4, 11, 3, 108, 0, 232, 0, 36, 1, 247, 0, 127, 0, 106, 0, 178, 255, 69, 0, 22, 0, 235, 255, 28, 0, 216, 248, 197, 251, 100, 0, 78, 252, 217, 245, 181, 247, 218, 248, 53, 0, 102, 252, 139, 0, 125, 246, 55, 0, 103, 252, 212, 242, 216, 244, 174, 255, 109, 255, 150, 252, 146, 255, 207, 253, 237, 255, 161, 255, 28, 247, 170, 255, 3, 244, 186, 245, 125, 245, 8, 245, 213, 0, 112, 254, 205, 249, 149, 254, 226, 255, 125, 255, 145, 1, 240, 255, 70, 255, 133, 245, 121, 244, 151, 247, 244, 245, 128, 242, 111, 250, 227, 245, 232, 3, 54, 2, 74, 252, 3, 0, 164, 246, 62, 251, 247, 243, 110, 0, 126, 251, 245, 255, 238, 0, 143, 242, 106, 249, 182, 243, 143, 244, 232, 2, 19, 243, 0, 254, 93, 1, 11, 247, 247, 242, 139, 240, 158, 241, 7, 240, 129, 242, 229, 241, 110, 243, 226, 244, 94, 238, 83, 238, 118, 237, 216, 236, 29, 238, 114, 239, 33, 237, 44, 238, 33, 237, 188, 240, 50, 242, 198, 243, 118, 240, 17, 241, 221, 239, 120, 241, 246, 240, 199, 237, 111, 238, 234, 235, 16, 236, 105, 236, 60, 236, 23, 236, 194, 237, 44, 236, 223, 236, 223, 236, 217, 236, 182, 236, 221, 239, 199, 239, 51, 240, 140, 238, 79, 239, 105, 239, 90, 239, 77, 239, 252, 238, 140, 247, 57, 240, 230, 240, 128, 240, 60, 241, 110, 238, 200, 242, 157, 241, 147, 238, 13, 239, 49, 240, 94, 243, 240, 238, 56, 238, 132, 238, 188, 244, 173, 238, 156, 243, 147, 238, 207, 238, 191, 238, 82, 3, 93, 2, 23, 4, 64, 2, 23, 2, 215, 1, 179, 3, 190, 3, 55, 3, 20, 236, 131, 236, 140, 236, 183, 236, 129, 236, 210, 235, 53, 254, 2, 250, 179, 255, 201, 255, 96, 242, 164, 242, 24, 1, 27, 254, 0, 2, 186, 237, 216, 239, 6, 238, 38, 1, 54, 245, 11, 1, 167, 244, 212, 241, 194, 241, 142, 241, 0, 239, 25, 240, 209, 236, 213, 237, 172, 245, 153, 239, 249, 235, 182, 235, 188, 238, 243, 235, 1, 236, 30, 242, 231, 237, 250, 242, 52, 2, 97, 0, 86, 1, 132, 2, 55, 7, 100, 3, 44, 0, 121, 4, 180, 4, 189, 1, 93, 5, 159, 4, 37, 2, 52, 5, 219, 0, 133, 2, 165, 4, 38, 2, 40, 255, 40, 253, 154, 249, 62, 0, 193, 255, 105, 0, 241, 250, 199, 250, 193, 0, 76, 4, 99, 3, 143, 3, 141, 0, 1, 0, 246, 255, 105, 0, 243, 255, 58, 0, 178, 255, 233, 255, 209, 255, 93, 0, 58, 0, 113, 0, 203, 2, 247, 0, 246, 5, 141, 0, 115, 0, 141, 0, 210, 1, 187, 1, 107, 2, 180, 255, 0, 0, 156, 0, 166, 251, 94, 255, 177, 254, 52, 0, 41, 1, 244, 255, 29, 241, 19, 241, 160, 240, 244, 241, 102, 241, 24, 242, 117, 240, 13, 241, 9, 241, 173, 245, 29, 243, 192, 244, 103, 242, 174, 242, 104, 244, 222, 243, 102, 243, 234, 242, 94, 0, 101, 253, 43, 0, 216, 244, 213, 242, 1, 242, 249, 243, 50, 246, 154, 242, 39, 242, 19, 242, 178, 241, 27, 2, 138, 246, 240, 255, 27, 1, 164, 255, 114, 0, 101, 245, 123, 0, 183, 1, 189, 0, 54, 249, 122, 246, 255, 243, 19, 244, 145, 243, 222, 242, 23, 243, 45, 243, 162, 1, 174, 1, 192, 1, 131, 1, 119, 1, 124, 1, 212, 1, 143, 1, 80, 2, 126, 7, 86, 3, 242, 3, 163, 2, 113, 3, 66, 255, 223, 1, 54, 2, 153, 1, 40, 0, 183, 253, 8, 2, 73, 2, 37, 253, 134, 0, 39, 250, 154, 248, 179, 255, 242, 1, 174, 0, 245, 2, 52, 2, 81, 251, 69, 4, 188, 255, 169, 251, 132, 250, 96, 2, 100, 254, 112, 0, 134, 3, 164, 3, 190, 3, 87, 7, 201, 6, 241, 9, 0, 7, 100, 4, 230, 5, 42, 8, 97, 0, 46, 8, 104, 2, 254, 255, 158, 1, 34, 255, 0, 0, 179, 255, 149, 3, 52, 1, 224, 255, 162, 1, 168, 1, 11, 1, 118, 2, 74, 2, 190, 2, 17, 1, 146, 1, 145, 1, 3, 5, 41, 4, 179, 3, 252, 2, 111, 3, 126, 4, 158, 3, 172, 3, 134, 3, 87, 2, 181, 2, 239, 2, 169, 1, 29, 2, 121, 1, 225, 3, 229, 2, 211, 2, 191, 2, 140, 2, 103, 2, 22, 0, 229, 255, 213, 255, 0, 0, 61, 252, 205, 3, 38, 6, 191, 4, 48, 6, 189, 0, 97, 1, 241, 254, 191, 255, 188, 7, 131, 6, 240, 255, 30, 7, 187, 255, 42, 240, 52, 246, 45, 240, 221, 239, 155, 239, 158, 0, 209, 255, 160, 241, 47, 254, 124, 245, 204, 244, 171, 241, 163, 242, 62, 245, 124, 241, 227, 245, 164, 246, 80, 244, 46, 244, 18, 241, 253, 239, 132, 240, 178, 0, 216, 0, 172, 0, 100, 0, 84, 0, 101, 2, 186, 1, 253, 0, 45, 1, 151, 1, 87, 1, 43, 1, 84, 0, 97, 0, 99, 0, 122, 0, 238, 0, 116, 0, 196, 0, 208, 0, 184, 0, 132, 0, 98, 0, 34, 253, 158, 0, 227, 247, 139, 250, 188, 244, 103, 248, 132, 246, 167, 246, 99, 250, 13, 255, 73, 250, 89, 4, 230, 3, 221, 255, 60, 3, 31, 5, 194, 5, 173, 252, 1, 247, 122, 248, 125, 247, 192, 0, 135, 1, 239, 0, 103, 1, 222, 251, 106, 3, 112, 3, 150, 3, 235, 2, 104, 2, 204, 244, 77, 245, 237, 245, 245, 249, 55, 255, 43, 3, 252, 255, 47, 251, 126, 0, 96, 0, 140, 0, 148, 0, 217, 0, 56, 0, 16, 0, 95, 0, 73, 0, 19, 0, 102, 0, 104, 0, 135, 0, 123, 0, 205, 0, 111, 0, 131, 0, 87, 0, 115, 0, 121, 0, 174, 0, 121, 0, 102, 3, 234, 3, 54, 4, 8, 5, 42, 6, 165, 3, 115, 4, 112, 7, 181, 5, 92, 9, 39, 254, 213, 253, 219, 247, 242, 4, 240, 7, 200, 5, 58, 247, 104, 255, 108, 3, 178, 248, 94, 247, 112, 247, 8, 250, 132, 4, 170, 2, 11, 2, 29, 0, 103, 0, 227, 255, 227, 255, 0, 0, 0, 0, 0, 0, 97, 0, 4, 0, 156, 0, 12, 0, 74, 0, 254, 255, 230, 255, 236, 5, 170, 5, 248, 8, 208, 3, 178, 8, 120, 1, 200, 5, 125, 3, 178, 0, 227, 255, 254, 255, 235, 255, 202, 0, 150, 247, 89, 251, 247, 255, 250, 255, 173, 252, 44, 2, 43, 7, 193, 248, 117, 247, 30, 0, 37, 0, 11, 0, 11, 0, 144, 0, 65, 0, 117, 0, 14, 0, 88, 1, 119, 2, 113, 1, 195, 1, 97, 1, 70, 0, 148, 252, 189, 253, 77, 252, 208, 252, 233, 255, 200, 1, 229, 0, 155, 0, 179, 0, 170, 0, 155, 253, 107, 1, 232, 2, 153, 2, 212, 1, 45, 1, 35, 1, 16, 2, 55, 2, 72, 2, 127, 1, 27, 3, 253, 2, 160, 2, 168, 2, 201, 1, 73, 4, 13, 3, 218, 3, 208, 1, 159, 2, 79, 2, 228, 3, 222, 3, 124, 3, 206, 3, 23, 4, 229, 3, 98, 3, 86, 2, 76, 3, 239, 2, 157, 247, 221, 255, 108, 253, 11, 250, 61, 249, 7, 248, 94, 2, 136, 2, 0, 0, 39, 3, 241, 4, 55, 3, 27, 1, 27, 0, 4, 3, 2, 3, 54, 3, 99, 3, 254, 2, 156, 2, 44, 4, 119, 2, 92, 3, 199, 255, 123, 255, 203, 2, 132, 4, 223, 3, 191, 3, 178, 0, 8, 0, 187, 2, 233, 3, 102, 3, 219, 3, 251, 4, 1, 0, 108, 252, 70, 252, 57, 253, 148, 5, 116, 4, 80, 5, 161, 1, 237, 5, 216, 4, 136, 4, 69, 4, 170, 3, 41, 3, 215, 3, 16, 6, 183, 6, 193, 2, 100, 9, 94, 10, 44, 9, 11, 2, 93, 3, 245, 1, 61, 4, 220, 1, 239, 1, 222, 4, 169, 2, 5, 3, 239, 255, 51, 1, 233, 255, 180, 0, 101, 0, 75, 0, 50, 0, 109, 3, 11, 7, 28, 5, 207, 3, 137, 4, 34, 3, 0, 0, 227, 255, 227, 255, 164, 0, 249, 0, 75, 0, 100, 0, 6, 4, 247, 6, 236, 3, 39, 1, 212, 2, 76, 0, 236, 255, 17, 0, 212, 2, 196, 255, 206, 255, 220, 255, 46, 2, 202, 9, 67, 7, 21, 7, 109, 7, 141, 6, 163, 2, 132, 6, 23, 7, 251, 5, 173, 3, 134, 5, 3, 10, 33, 5, 143, 5, 53, 6, 197, 6, 11, 4, 35, 6, 31, 6, 54, 6, 92, 4, 238, 5, 222, 3, 12, 8, 235, 2, 67, 5, 184, 3, 213, 2, 197, 2, 41, 1, 27, 6, 85, 3, 134, 1, 177, 4, 141, 3, 188, 3, 193, 4, 73, 252, 241, 1, 198, 251, 241, 255, 251, 1, 38, 2, 249, 2, 209, 0, 222, 1, 208, 0, 208, 2, 248, 2, 107, 5, 197, 5, 225, 1, 53, 3, 111, 1, 13, 4, 150, 1, 245, 1, 86, 1, 238, 1, 63, 0, 232, 255, 247, 255, 227, 0, 54, 1, 81, 9, 157, 11, 7, 0, 21, 1, 77, 3, 187, 3, 9, 0, 115, 1, 34, 1, 60, 1, 81, 1, 22, 0, 115, 0, 8, 0, 4, 0, 1, 0, 191, 0, 227, 255, 227, 255, 0, 0, 0, 0, 0, 0, 135, 7, 123, 8, 56, 7, 236, 10, 17, 5, 66, 4, 14, 2, 207, 10, 241, 4, 0, 0, 0, 0, 10, 7, 157, 0, 58, 8, 81, 0, 234, 255, 0, 0, 40, 1, 33, 0, 63, 0, 76, 0, 144, 0, 91, 6, 119, 8, 131, 7, 106, 7, 69, 5, 87, 7, 31, 1, 76, 3, 78, 7, 11, 5, 220, 0, 166, 4, 234, 0, 84, 2, 52, 2, 89, 2, 234, 1, 250, 0, 172, 1, 51, 1, 221, 1, 43, 2, 129, 1, 157, 1, 131, 1, 48, 2, 242, 1, 50, 1, 250, 0, 24, 1, 11, 1, 42, 1, 152, 0, 86, 1, 21, 1, 161, 1, 166, 1, 135, 1, 91, 1, 185, 255, 63, 0, 246, 0, 219, 0, 26, 1, 124, 0, 221, 0, 75, 1, 245, 0, 107, 1, 24, 1, 247, 0, 63, 1, 253, 0, 249, 0, 240, 0, 253, 1, 226, 1, 157, 0, 202, 1, 130, 1, 222, 1, 90, 1, 14, 1, 68, 1, 153, 1, 31, 1, 33, 1, 88, 1, 55, 1, 107, 1, 131, 1, 18, 1, 42, 1, 16, 1, 52, 1, 59, 1, 95, 1, 0, 1, 93, 1, 252, 0, 132, 1, 97, 1, 80, 1, 77, 1, 27, 1, 82, 1, 27, 1, 37, 1, 48, 1, 61, 1, 19, 1, 34, 1, 33, 1, 53, 1, 28, 1, 169, 1, 96, 1, 120, 1, 114, 1, 176, 1, 67, 1, 43, 1, 54, 1, 68, 1, 137, 1, 3, 1, 72, 1, 32, 1, 43, 1, 32, 1, 103, 1, 61, 1, 247, 0, 207, 237, 35, 238, 222, 237, 10, 239, 80, 237, 152, 237, 4, 238, 67, 248, 157, 240, 66, 239, 119, 243, 51, 243, 249, 242, 40, 237, 33, 239, 119, 238, 171, 237, 57, 237, 216, 237, 167, 237, 138, 240, 112, 239, 57, 241, 4, 239, 43, 241, 23, 239, 220, 255, 250, 255, 206, 255, 0, 0, 247, 255, 43, 0, 52, 240, 190, 250, 249, 239, 57, 250, 108, 255, 2, 0, 157, 243, 25, 248, 23, 243, 36, 0, 57, 0, 2, 0, 223, 237, 65, 238, 105, 239, 48, 238, 241, 237, 26, 237, 33, 240, 51, 239, 37, 241, 72, 250, 250, 242, 169, 240, 47, 247, 33, 251, 168, 241, 89, 244, 230, 255, 117, 249, 241, 251, 69, 237, 190, 237, 142, 240, 6, 239, 228, 240, 157, 238, 139, 239, 251, 255, 174, 249, 106, 248, 183, 255, 234, 255, 8, 0, 13, 244, 44, 247, 100, 243, 135, 241, 124, 242, 73, 245, 191, 242, 80, 241, 204, 240, 103, 252, 220, 242, 137, 244, 75, 243, 242, 243, 43, 243, 138, 242, 151, 238, 249, 241, 129, 240, 191, 240, 80, 242, 175, 242, 239, 243, 5, 243, 237, 236, 69, 236, 107, 236, 69, 237, 76, 236, 47, 237, 10, 236, 84, 236, 215, 235, 118, 0, 187, 0, 83, 0, 221, 0, 159, 0, 184, 0, 85, 242, 74, 0, 188, 255, 101, 244, 147, 247, 53, 0, 209, 238, 62, 241, 175, 238, 25, 0, 145, 253, 59, 0, 25, 251, 175, 255, 75, 247, 30, 1, 67, 1, 2, 1, 13, 1, 70, 1, 91, 1, 50, 1, 52, 1, 39, 1, 105, 1, 99, 1, 51, 1, 58, 1, 103, 1, 244, 1, 16, 1, 37, 1, 44, 1, 206, 0, 154, 0, 98, 0, 37, 1, 166, 0, 240, 0, 55, 1, 191, 0, 239, 0, 39, 1, 19, 1, 59, 1, 188, 255, 245, 255, 251, 255, 123, 0, 61, 0, 1, 0, 184, 1, 82, 0, 165, 1, 181, 0, 233, 0, 148, 0, 83, 3, 163, 1, 50, 2, 63, 0, 254, 0, 100, 1, 79, 2, 134, 1, 107, 1, 190, 1, 139, 1, 4, 2, 185, 1, 159, 1, 98, 2, 29, 1, 252, 2, 244, 1, 109, 0, 1, 1, 66, 1, 43, 1, 240, 0, 79, 1, 171, 1, 95, 1, 97, 1, 38, 1, 175, 0, 153, 0, 240, 0, 247, 0, 110, 1, 86, 1, 89, 1, 248, 0, 245, 255, 216, 0, 223, 0, 230, 0, 87, 1, 37, 0, 16, 0, 242, 0, 113, 0, 98, 0, 76, 0, 128, 0, 130, 1, 137, 1, 62, 1, 132, 1, 79, 1, 168, 1, 181, 1, 191, 0, 189, 0, 7, 1, 6, 0, 255, 0, 59, 1, 58, 0, 22, 0, 115, 1, 64, 1, 117, 0, 133, 0, 71, 0, 246, 1, 195, 1, 47, 0, 14, 0, 46, 0, 51, 0, 44, 0, 37, 0, 92, 0, 63, 0, 78, 0, 56, 0, 39, 1, 25, 1, 8, 1, 17, 1, 5, 1, 105, 1, 73, 1, 15, 1, 65, 1, 169, 0, 70, 1, 55, 1, 30, 1, 164, 1, 15, 1, 22, 1, 7, 1, 33, 1, 28, 1, 20, 1, 28, 1, 55, 1, 47, 0, 213, 0, 49, 0, 77, 0, 46, 1, 247, 0, 203, 0, 254, 0, 23, 1, 181, 0, 125, 1, 210, 1, 150, 1, 97, 1, 226, 0, 186, 0, 12, 1, 237, 0, 94, 0, 182, 0, 202, 0, 150, 1, 27, 0, 57, 1, 83, 1, 116, 0, 95, 0, 157, 0, 61, 0, 5, 0, 0, 0, 119, 0, 66, 0, 55, 0, 155, 0, 106, 0, 5, 1, 16, 1, 126, 0, 180, 0, 197, 1, 195, 1, 174, 0, 55, 1, 130, 1, 18, 1, 56, 2, 46, 1, 53, 1, 178, 0, 207, 0, 76, 1, 80, 1, 230, 255, 28, 0, 247, 255, 39, 0, 86, 0, 11, 0, 12, 0, 96, 0, 141, 0, 216, 0, 155, 0, 192, 0, 230, 0, 137, 0, 139, 0, 49, 0, 98, 0, 114, 0, 190, 0, 134, 0, 170, 0, 220, 238, 27, 238, 150, 240, 153, 239, 14, 240, 27, 240, 70, 241, 233, 255, 126, 255, 74, 255, 94, 255, 231, 255, 173, 243, 177, 241, 140, 242, 63, 245, 203, 255, 32, 242, 209, 242, 6, 241, 198, 255, 73, 247, 184, 253, 237, 242, 168, 247, 183, 243, 74, 0, 15, 0, 33, 0, 29, 0, 17, 0, 233, 255, 241, 255, 220, 255, 0, 0, 241, 255, 9, 0, 31, 0, 53, 0, 251, 255, 249, 255, 10, 0, 234, 255, 237, 255, 96, 237, 12, 238, 106, 238, 85, 238, 215, 237, 254, 240, 4, 239, 49, 238, 91, 238, 211, 236, 103, 236, 36, 236, 222, 239, 121, 237, 114, 238, 220, 236, 175, 242, 143, 238, 161, 242, 60, 240, 230, 243, 85, 238, 159, 238, 31, 239, 77, 241, 52, 239, 15, 239, 5, 238, 78, 242, 137, 237, 65, 238, 224, 237, 184, 240, 96, 240, 118, 239, 101, 239, 165, 238, 46, 239, 218, 246, 117, 0, 68, 255, 235, 255, 243, 255, 36, 0, 6, 1, 9, 242, 69, 255, 146, 251, 230, 235, 46, 237, 15, 237, 56, 238, 175, 237, 57, 237, 94, 243, 44, 248, 146, 244, 245, 240, 145, 240, 74, 239, 136, 1, 135, 2, 90, 2, 158, 1, 178, 1, 146, 1, 15, 1, 27, 2, 88, 1, 74, 0, 245, 0, 7, 1, 182, 1, 20, 1, 160, 2, 181, 2, 225, 1, 74, 2, 1, 1, 226, 0, 164, 0, 32, 1, 106, 2, 161, 2, 183, 1, 92, 3, 101, 1, 228, 1, 114, 1, 241, 1, 19, 238, 80, 0, 197, 247, 118, 245, 104, 242, 239, 0, 212, 1, 238, 2, 73, 2, 161, 1, 45, 0, 21, 247, 255, 247, 186, 0, 168, 0, 14, 2, 155, 1, 78, 0, 79, 236, 27, 237, 147, 234, 241, 234, 254, 233, 199, 233, 143, 233, 156, 233, 21, 234, 178, 235, 25, 234, 153, 235, 37, 235, 186, 234, 130, 236, 249, 233, 34, 236, 89, 232, 171, 233, 37, 233, 73, 235, 90, 233, 10, 235, 39, 234, 152, 233, 54, 233, 116, 238, 65, 239, 181, 238, 78, 237, 14, 237, 8, 240, 35, 242, 234, 237, 201, 237, 215, 237, 114, 242, 49, 237, 47, 243, 241, 237, 45, 238, 176, 238, 231, 234, 9, 234, 30, 239, 51, 238, 183, 240, 3, 238, 170, 242, 132, 241, 134, 244, 101, 245, 138, 242, 243, 242, 167, 238, 170, 237, 26, 242, 66, 247, 1, 242, 211, 240, 111, 243, 228, 237, 77, 242, 218, 236, 145, 242, 166, 242, 127, 238, 131, 241, 55, 241, 3, 245, 167, 238, 88, 240, 208, 238, 222, 240, 218, 241, 167, 240, 127, 239, 225, 238, 129, 241, 254, 243, 104, 241, 52, 241, 171, 237, 153, 240, 34, 237, 52, 236, 174, 235, 27, 238, 77, 237, 59, 243, 151, 238, 224, 241, 18, 237, 21, 239, 187, 235, 204, 236, 197, 240, 201, 237, 181, 238, 87, 236, 137, 1, 187, 0, 221, 0, 71, 1, 106, 0, 156, 0, 38, 1, 19, 0, 187, 2, 12, 0, 44, 2, 142, 0, 249, 255, 200, 255, 43, 0, 6, 0, 27, 250, 3, 0, 57, 0, 149, 0, 72, 0, 67, 0, 56, 238, 85, 241, 71, 238, 175, 238, 245, 238, 86, 239, 73, 238, 177, 238, 231, 240, 16, 239, 27, 239, 236, 239, 96, 245, 234, 255, 159, 239, 216, 241, 21, 240, 30, 242, 77, 238, 91, 238, 97, 238, 142, 238, 19, 238, 101, 241, 222, 238, 142, 237, 59, 238, 113, 242, 218, 240, 248, 238, 139, 239, 36, 239, 4, 240, 212, 239, 58, 238, 180, 238, 178, 237, 184, 237, 82, 239, 237, 240, 135, 242, 215, 243, 55, 243, 146, 237, 234, 255, 74, 240, 108, 242, 217, 255, 72, 244, 127, 238, 228, 238, 205, 238, 193, 238, 115, 238, 201, 242, 77, 243, 208, 243, 110, 240, 23, 239, 53, 240, 58, 240, 137, 241, 137, 243, 138, 239, 15, 243, 143, 238, 231, 237, 98, 239, 23, 239, 178, 237, 196, 237, 95, 236, 245, 236, 185, 235, 102, 238, 104, 237, 60, 237, 72, 236, 55, 238, 209, 237, 175, 239, 95, 239, 28, 239, 82, 238, 39, 239, 41, 239, 247, 238, 195, 238, 70, 239, 107, 238, 66, 238, 39, 238, 67, 235, 210, 237, 252, 235, 13, 237, 79, 237, 71, 236, 141, 237, 44, 237, 51, 236, 16, 238, 40, 237, 176, 238, 28, 236, 58, 234, 251, 234, 85, 237, 244, 236, 18, 237, 31, 236, 136, 235, 191, 234, 183, 234, 63, 234, 22, 235, 47, 237, 85, 234, 156, 233, 5, 236, 166, 234, 29, 236, 32, 240, 94, 242, 189, 242, 241, 242, 147, 245, 114, 244, 190, 242, 164, 245, 120, 244, 71, 240, 125, 240, 95, 242, 166, 239, 39, 240, 130, 239, 228, 243, 163, 241, 15, 242, 99, 239, 49, 238, 7, 238, 46, 241, 138, 239, 158, 241, 195, 238, 105, 238, 74, 239, 15, 241, 151, 239, 205, 241, 54, 237, 19, 235, 2, 234, 220, 235, 76, 237, 232, 236, 152, 236, 28, 238, 140, 236, 127, 237, 100, 240, 94, 238, 249, 239, 94, 239, 174, 237, 187, 234, 37, 237, 76, 237, 176, 236, 125, 238, 115, 237, 248, 237, 138, 238, 114, 236, 56, 239, 18, 238, 230, 238, 92, 240, 22, 238, 17, 240, 85, 235, 83, 238, 136, 238, 82, 236, 158, 238, 149, 237, 243, 246, 224, 242, 14, 239, 16, 239, 19, 239, 124, 240, 227, 237, 22, 239, 8, 238, 135, 237, 117, 237, 68, 237, 23, 245, 2, 245, 65, 244, 53, 244, 241, 246, 75, 244, 233, 244, 120, 245, 105, 243, 186, 239, 30, 240, 239, 239, 199, 240, 253, 241, 24, 239, 125, 240, 118, 239, 218, 244, 229, 240, 225, 238, 160, 238, 250, 241, 225, 241, 69, 243, 210, 239, 240, 239, 37, 240, 238, 241, 119, 241, 210, 241, 199, 236, 162, 234, 149, 234, 46, 236, 242, 233, 227, 234, 211, 237, 253, 236, 43, 239, 136, 238, 86, 235, 20, 236, 34, 236, 243, 235, 156, 238, 241, 233, 65, 234, 235, 235, 30, 241, 187, 238, 94, 238, 178, 238, 141, 240, 76, 240, 150, 236, 78, 238, 114, 236, 251, 234, 200, 236, 126, 236, 179, 238, 17, 239, 227, 237, 158, 237, 63, 239, 158, 240, 100, 238, 32, 238, 48, 240, 96, 239, 207, 239, 48, 240, 222, 237, 3, 236, 235, 238, 188, 238, 154, 238, 140, 238, 50, 238, 8, 237, 6, 237, 169, 235, 66, 236, 15, 237, 109, 235, 42, 236, 98, 235, 168, 234, 23, 235, 231, 235, 22, 234, 57, 236, 182, 234, 196, 234, 122, 234, 162, 234, 229, 234, 104, 235, 22, 235, 246, 233, 117, 234, 20, 234, 89, 235, 85, 235, 2, 235, 15, 235, 223, 234, 113, 235, 62, 240, 41, 241, 36, 240, 9, 238, 7, 240, 140, 239, 46, 239, 118, 238, 213, 237, 26, 243, 180, 240, 50, 242, 37, 237, 240, 238, 54, 238, 240, 239, 189, 239, 86, 238, 88, 236, 213, 233, 226, 235, 222, 236, 143, 235, 197, 236, 236, 235, 108, 236, 189, 236, 156, 236, 41, 238, 125, 236, 173, 240, 243, 240, 169, 241, 72, 239, 53, 238, 202, 239, 14, 242, 236, 239, 194, 241, 76, 236, 197, 236, 72, 236, 54, 237, 29, 237, 187, 235, 126, 237, 245, 236, 47, 237, 21, 242, 43, 241, 67, 241, 121, 240, 83, 240, 70, 239, 250, 237, 60, 241, 104, 240, 223, 237, 6, 238, 158, 239, 78, 236, 69, 237, 7, 237, 47, 235, 219, 236, 142, 241, 154, 237, 204, 238, 179, 238, 129, 236, 90, 233, 234, 235, 196, 236, 187, 236, 48, 236, 245, 236, 119, 237, 254, 236, 37, 237, 17, 237, 17, 238, 38, 237, 156, 237, 167, 240, 109, 240, 204, 240, 67, 239, 251, 239, 248, 239, 186, 240, 239, 237, 62, 239, 200, 237, 50, 238, 36, 241, 231, 239, 167, 240, 166, 237, 151, 238, 197, 239, 177, 243, 175, 246, 182, 241, 71, 244, 133, 243, 61, 244, 84, 243, 213, 244, 234, 245, 45, 245, 142, 242, 219, 244, 185, 238, 219, 240, 44, 241, 84, 240, 81, 243, 87, 241, 134, 242, 245, 244, 173, 242, 92, 243, 230, 240, 142, 244, 249, 241, 254, 237, 190, 239, 177, 240, 2, 241, 75, 244, 43, 242, 205, 242, 252, 242, 104, 244, 88, 241, 153, 243, 242, 239, 177, 240, 180, 244, 236, 241, 90, 243, 161, 242, 31, 243, 157, 238, 182, 241, 70, 242, 71, 243, 181, 241, 162, 250, 112, 242, 178, 243, 163, 245, 177, 242, 199, 241, 4, 240, 44, 243, 106, 241, 92, 242, 245, 243, 154, 241, 150, 242, 137, 240, 55, 236, 205, 233, 116, 234, 122, 236, 186, 235, 135, 234, 254, 232, 88, 233, 118, 234, 32, 234, 145, 232, 120, 233, 67, 237, 174, 237, 150, 236, 11, 237, 191, 234, 230, 235, 52, 235, 65, 235, 221, 234, 35, 235, 128, 241, 228, 243, 195, 241, 28, 244, 112, 242, 50, 245, 118, 242, 163, 238, 92, 240, 133, 238, 235, 240, 15, 240, 24, 239, 51, 239, 156, 239, 64, 240, 16, 236, 233, 236, 57, 241, 171, 240, 151, 237, 188, 240, 152, 238, 70, 240, 105, 240, 141, 241, 172, 250, 44, 241, 160, 237, 178, 241, 79, 237, 33, 238, 88, 238, 254, 236, 159, 236, 122, 236, 251, 235, 171, 235, 109, 236, 18, 236, 245, 239, 207, 241, 42, 240, 65, 240, 65, 246, 101, 242, 98, 237, 8, 239, 111, 238, 133, 236, 182, 239, 36, 239, 166, 235, 167, 236, 13, 238, 251, 235, 137, 234, 74, 239, 224, 235, 107, 237, 117, 239, 83, 237, 74, 236, 137, 234, 167, 235, 44, 235, 83, 235, 236, 236, 109, 237, 96, 234, 181, 236, 143, 235, 37, 236, 1, 237, 119, 235, 105, 235, 60, 234, 104, 234, 7, 237, 101, 234, 43, 236, 64, 235, 133, 235, 83, 235, 250, 235, 43, 235, 98, 235, 177, 234, 130, 234, 21, 236, 173, 233, 239, 235, 61, 241, 142, 241, 174, 236, 248, 239, 234, 238, 31, 239, 48, 239, 188, 234, 16, 236, 220, 234, 73, 235, 183, 235, 248, 233, 56, 235, 81, 239, 162, 236, 3, 235, 116, 233, 149, 237, 10, 236, 44, 235, 36, 235, 148, 235, 37, 237, 8, 238, 86, 238, 228, 236, 105, 238, 156, 237, 142, 237, 210, 236, 245, 236, 119, 236, 29, 235, 44, 235, 36, 234, 213, 234, 64, 235, 205, 235, 158, 236, 159, 234, 4, 235, 145, 234, 229, 235, 147, 234, 64, 235, 40, 234, 135, 233, 17, 234, 223, 236, 161, 234, 237, 235, 34, 234, 250, 234, 233, 234, 64, 233, 219, 234, 212, 233, 222, 233, 15, 234, 239, 233, 228, 233, 225, 234, 57, 234, 108, 237, 128, 234, 244, 233, 197, 233, 0, 235, 161, 233, 75, 236, 4, 236, 10, 236, 111, 236, 224, 235, 35, 240, 204, 237, 205, 235, 223, 237, 254, 235, 255, 236, 66, 236, 78, 238, 138, 240, 153, 236, 157, 236, 140, 238, 69, 238, 12, 237, 78, 236, 4, 236, 68, 236, 189, 239, 216, 243, 37, 237, 3, 238, 190, 236, 37, 242, 105, 242, 107, 237, 151, 236, 60, 234, 6, 238, 102, 236, 13, 238, 32, 237, 122, 237, 50, 237, 10, 252, 11, 245, 112, 244, 108, 247, 223, 237, 40, 242, 190, 238, 141, 237, 216, 238, 56, 239, 188, 242, 191, 241, 252, 243, 169, 241, 89, 241, 104, 241, 220, 241, 177, 239, 219, 241, 226, 245, 237, 241, 190, 241, 194, 242, 107, 243, 236, 243, 241, 240, 197, 241, 25, 242, 44, 241, 203, 238, 136, 245, 64, 242, 17, 246, 143, 243, 116, 243, 29, 243, 240, 237, 173, 237, 50, 237, 156, 235, 73, 237, 41, 240, 16, 241, 176, 242, 246, 237, 155, 236, 152, 240, 108, 241, 231, 239, 194, 239, 214, 239, 31, 238, 98, 240, 203, 235, 124, 240, 9, 241, 190, 241, 105, 243, 108, 243, 152, 237, 136, 234, 165, 243, 184, 237, 166, 238, 81, 236, 131, 235, 253, 238, 0, 239, 211, 240, 11, 241, 118, 241, 177, 242, 87, 241, 70, 241, 155, 243, 60, 241, 244, 240, 144, 240, 31, 240, 112, 239, 132, 237, 128, 243, 72, 240, 10, 237, 221, 236, 187, 239, 59, 239, 142, 239, 27, 236, 53, 236, 101, 238, 67, 237, 31, 236, 170, 236, 130, 236, 55, 239, 222, 238, 245, 238, 196, 237, 34, 237, 220, 236, 202, 236, 130, 236, 221, 240, 195, 242, 27, 238, 101, 240, 43, 238, 50, 245, 39, 241, 178, 238, 64, 248, 139, 236, 50, 237, 175, 238, 117, 236, 143, 236, 165, 236, 62, 236, 108, 236, 237, 235, 91, 238, 239, 237, 49, 238, 133, 240, 240, 233, 133, 237, 55, 237, 72, 240, 216, 237, 76, 238, 153, 240, 35, 240, 228, 237, 232, 236, 117, 234, 149, 236, 110, 237, 125, 0, 197, 0, 21, 0, 74, 0, 26, 0, 166, 0, 67, 0, 69, 0, 67, 0, 60, 0, 64, 0, 60, 0, 47, 0, 29, 0, 51, 0, 61, 0, 65, 0, 39, 0, 38, 0, 46, 0, 49, 0, 59, 0, 32, 0, 48, 0, 55, 0, 65, 0, 201, 0, 187, 0, 114, 0, 117, 0, 150, 0, 156, 0, 125, 0, 131, 0, 135, 0, 122, 0, 95, 0, 146, 0, 125, 0, 95, 0, 159, 0, 82, 0, 89, 0, 89, 0, 92, 0, 118, 0, 52, 0, 72, 0, 108, 0, 107, 0, 114, 0, 132, 0, 178, 0, 151, 0, 156, 0, 21, 1, 146, 0, 203, 0, 162, 0, 163, 0, 148, 0, 117, 0, 97, 0, 131, 0, 100, 0, 96, 0, 85, 0, 205, 0, 169, 0, 230, 0, 153, 0, 153, 0, 163, 0, 139, 0, 180, 0, 150, 0, 114, 0, 133, 0, 111, 0, 163, 0, 93, 0, 191, 0, 52, 0, 81, 0, 65, 0, 48, 0, 72, 0, 135, 0, 92, 0, 109, 0, 120, 0, 97, 0, 50, 0, 52, 0, 70, 0, 83, 0, 53, 0, 86, 0, 86, 0, 58, 0, 172, 255, 233, 250, 159, 244, 98, 244, 235, 243, 69, 250, 119, 248, 20, 240, 78, 240, 166, 239, 10, 243, 69, 243, 146, 240, 177, 241, 147, 241, 198, 242, 156, 248, 174, 250, 188, 246, 49, 247, 63, 244, 91, 247, 51, 244, 88, 243, 70, 243, 138, 245, 85, 238, 64, 237, 94, 237, 9, 236, 26, 237, 220, 236, 88, 237, 237, 237, 156, 238, 46, 10, 154, 2, 95, 11, 21, 246, 162, 255, 87, 255, 48, 255, 127, 255, 215, 244, 225, 238, 11, 239, 202, 239, 44, 238, 144, 238, 25, 238, 202, 238, 25, 239, 110, 238, 140, 235, 0, 236, 191, 238, 199, 0, 192, 0, 181, 1, 60, 1, 187, 0, 203, 0, 15, 1, 137, 246, 22, 0, 67, 15, 4, 0, 31, 0, 93, 0, 30, 15, 6, 5, 118, 3, 115, 9, 181, 0, 144, 0, 132, 0, 75, 6, 14, 1, 244, 5, 133, 3, 85, 3, 251, 0, 252, 239, 51, 235, 186, 239, 150, 240, 77, 241, 183, 9, 235, 3, 107, 6, 33, 0, 235, 252, 175, 246, 190, 241, 159, 244, 106, 251, 230, 0, 217, 250, 125, 0, 2, 236, 246, 11, 152, 18, 36, 16, 143, 17, 12, 17, 42, 13, 124, 241, 176, 3, 148, 251, 86, 18, 108, 16, 133, 14, 41, 3, 140, 10, 194, 5, 128, 15, 65, 15, 130, 18, 87, 239, 35, 242, 114, 241, 134, 235, 136, 239, 77, 243, 30, 237, 84, 240, 171, 243, 213, 10, 98, 9, 103, 255, 163, 0, 187, 0, 198, 0, 86, 6, 209, 0, 224, 0, 211, 8, 232, 0, 72, 8, 43, 17, 122, 15, 155, 19, 8, 16, 57, 17, 129, 14, 124, 11, 210, 15, 242, 9, 131, 13, 112, 15, 214, 15, 72, 14, 132, 15, 119, 14, 87, 14, 94, 14, 100, 14, 104, 15, 137, 14, 87, 16, 143, 237, 14, 242, 234, 237, 17, 239, 5, 244, 17, 242, 149, 243, 140, 245, 0, 243, 174, 235, 141, 236, 70, 237, 190, 237, 141, 236, 42, 237, 46, 239, 134, 236, 15, 238, 111, 17, 246, 2, 131, 6, 242, 232, 175, 247, 103, 2, 216, 231, 7, 236, 199, 239, 238, 238, 22, 238, 205, 239, 18, 19, 160, 8, 48, 15, 201, 10, 98, 3, 49, 3, 12, 236, 155, 248, 0, 0, 195, 4, 146, 237, 153, 228, 45, 239, 10, 238, 32, 239, 95, 251, 177, 229, 242, 243, 178, 0, 128, 0, 145, 0, 132, 0, 124, 0, 212, 3, 174, 2, 215, 0, 166, 0, 252, 0, 172, 0, 115, 0, 187, 0, 187, 0, 137, 0, 149, 0, 180, 0, 216, 0, 191, 0, 107, 0, 169, 0, 155, 0, 196, 238, 163, 246, 154, 238, 30, 237, 107, 247, 63, 17, 138, 16, 239, 15, 178, 14, 245, 2, 187, 14, 60, 1, 203, 15, 203, 5, 178, 255, 205, 9, 242, 4, 61, 15, 186, 15, 209, 255, 32, 17, 144, 255, 154, 0, 178, 0, 146, 0, 158, 0, 176, 0, 223, 0, 230, 0, 30, 1, 30, 1, 16, 1, 176, 0, 157, 0, 203, 17, 12, 17, 12, 6, 69, 10, 26, 1, 160, 1, 241, 0, 170, 0, 189, 0, 194, 0, 254, 0, 80, 3, 186, 1, 152, 0, 14, 1, 47, 14, 201, 1, 204, 5, 232, 3, 79, 3, 248, 0, 24, 1, 16, 1, 19, 1, 85, 1, 28, 1, 210, 1, 15, 1, 126, 238, 76, 239, 41, 239, 39, 239, 5, 239, 197, 239, 190, 239, 41, 239, 179, 239, 231, 238, 150, 239, 111, 240, 166, 239, 178, 239, 125, 239, 110, 239, 213, 239, 138, 239, 183, 239, 162, 239, 104, 239, 185, 239, 81, 239, 127, 239, 55, 239, 175, 238, 14, 243, 74, 242, 175, 242, 236, 241, 67, 242, 111, 244, 17, 242, 79, 242, 182, 241, 77, 242, 125, 242, 114, 242, 26, 241, 162, 241, 122, 240, 81, 242, 30, 242, 72, 243, 30, 239, 21, 239, 88, 239, 79, 240, 139, 239, 162, 239, 88, 239, 40, 239, 224, 239, 178, 241, 172, 239, 168, 240, 38, 241, 95, 241, 24, 241, 96, 241, 240, 240, 16, 241, 224, 240, 181, 239, 15, 240, 54, 240, 28, 240, 184, 239, 118, 240, 220, 239, 189, 241, 228, 241, 189, 241, 130, 242, 135, 242, 89, 243, 160, 239, 119, 241, 161, 240, 113, 240, 120, 240, 228, 240, 172, 239, 33, 239, 150, 239, 85, 240, 84, 239, 41, 241, 248, 239, 43, 240, 0, 240, 237, 239, 26, 239, 17, 239, 81, 239, 96, 239, 156, 239, 147, 239, 89, 239, 47, 239, 9, 244, 255, 243, 7, 244, 27, 242, 174, 243, 84, 245, 74, 245, 129, 244, 172, 244, 182, 240, 18, 241, 12, 241, 150, 241, 17, 241, 11, 241, 81, 242, 180, 241, 216, 241, 37, 242, 5, 244, 230, 243, 92, 244, 168, 242, 73, 244, 252, 241, 166, 243, 211, 242, 210, 242, 188, 241, 8, 244, 61, 241, 137, 241, 211, 240, 83, 241, 232, 241, 78, 239, 250, 239, 75, 240, 236, 239, 241, 240, 19, 241, 147, 241, 42, 240, 250, 240, 152, 240, 110, 240, 91, 242, 73, 239, 1, 241, 88, 241, 54, 241, 239, 239, 96, 240, 52, 240, 79, 240, 146, 240, 119, 240, 114, 240, 74, 240, 22, 240, 176, 242, 26, 243, 107, 242, 172, 243, 5, 243, 58, 247, 199, 243, 105, 243, 251, 243, 6, 243, 168, 243, 219, 244, 247, 242, 27, 243, 71, 242, 160, 243, 141, 243, 45, 244, 199, 241, 161, 241, 152, 241, 36, 243, 248, 241, 238, 242, 105, 242, 23, 242, 166, 242, 142, 245, 64, 243, 226, 243, 196, 240, 140, 240, 175, 240, 93, 241, 111, 241, 234, 240, 22, 242, 155, 241, 188, 241, 144, 240, 107, 242, 84, 241, 188, 241, 193, 242, 137, 242, 26, 241, 182, 241, 134, 241, 93, 248, 146, 255, 170, 242, 251, 242, 79, 242, 12, 243, 139, 241, 29, 243, 79, 243, 32, 242, 181, 242, 10, 242, 202, 242, 241, 242, 187, 240, 185, 240, 149, 240, 252, 241, 253, 240, 188, 240, 101, 241, 212, 240, 63, 242, 76, 243, 178, 242, 93, 242, 198, 241, 26, 242, 75, 242, 144, 242, 241, 241, 203, 242, 113, 244, 47, 240, 55, 241, 138, 241, 116, 242, 193, 241, 116, 241, 115, 242, 128, 242, 74, 243, 15, 243, 9, 243, 241, 242, 72, 243, 127, 242, 197, 242, 101, 242, 67, 243, 43, 243, 125, 243, 241, 241, 25, 240, 36, 242, 223, 240, 23, 240, 242, 240, 117, 239, 234, 239, 214, 238, 207, 240, 116, 239, 54, 240, 3, 240, 85, 240, 32, 241, 201, 240, 191, 240, 192, 240, 205, 239, 185, 239, 164, 242, 98, 239, 188, 237, 212, 238, 157, 239, 125, 240, 145, 239, 118, 239, 96, 239, 187, 239, 184, 242, 34, 242, 71, 242, 59, 242, 213, 241, 67, 242, 155, 240, 74, 241, 224, 240, 134, 241, 47, 241, 51, 241, 217, 240, 223, 240, 205, 241, 90, 242, 10, 241, 162, 240, 190, 243, 56, 244, 179, 244, 103, 243, 42, 243, 206, 243, 100, 242, 195, 243, 178, 243, 73, 243, 140, 243, 161, 243, 192, 243, 158, 241, 70, 243, 0, 243, 162, 243, 148, 243, 245, 243, 119, 244, 27, 244, 164, 243, 21, 241, 145, 238, 155, 239, 182, 238, 162, 239, 42, 240, 121, 239, 148, 240, 251, 238, 226, 240, 120, 238, 9, 240, 102, 241, 83, 242, 96, 240, 151, 241, 160, 241, 72, 241, 117, 240, 243, 238, 28, 239, 217, 239, 83, 241, 74, 242, 88, 241, 81, 241, 64, 243, 118, 242, 43, 243, 193, 243, 127, 243, 185, 243, 135, 243, 208, 242, 159, 241, 254, 240, 254, 242, 234, 240, 239, 242, 206, 241, 247, 243, 195, 243, 218, 244, 200, 243, 49, 242, 133, 241, 32, 242, 133, 242, 87, 243, 9, 242, 225, 242, 24, 241, 36, 241, 234, 241, 199, 242, 117, 243, 189, 243, 184, 243, 219, 243, 219, 241, 221, 240, 12, 242, 215, 235, 46, 236, 127, 239, 251, 236, 3, 237, 35, 235, 92, 235, 105, 235, 191, 236, 72, 238, 140, 237, 189, 234, 198, 236, 46, 237, 29, 237, 43, 236, 57, 236, 23, 236, 38, 238, 191, 237, 116, 237, 32, 237, 161, 235, 175, 235, 230, 236, 91, 236, 181, 236, 202, 237, 187, 236, 46, 238, 69, 245, 209, 243, 79, 245, 234, 240, 61, 242, 231, 244, 79, 241, 156, 238, 133, 243, 142, 240, 173, 240, 205, 241, 237, 239, 92, 239, 67, 239, 130, 241, 148, 240, 31, 241, 195, 239, 33, 239, 189, 238, 6, 240, 199, 239, 107, 240, 191, 238, 19, 239, 74, 239, 130, 241, 52, 240, 213, 239, 116, 241, 10, 240, 10, 241, 62, 239, 26, 240, 146, 240, 77, 239, 131, 240, 43, 239, 104, 238, 159, 239, 162, 239, 254, 237, 214, 237, 98, 237, 196, 238, 140, 239, 59, 239, 136, 239, 130, 239, 185, 240, 80, 239, 242, 239, 252, 238, 94, 236, 57, 239, 252, 237, 250, 238, 22, 238, 239, 237, 8, 239, 50, 239, 24, 238, 48, 238, 180, 237, 0, 240, 158, 238, 140, 240, 116, 239, 188, 237, 215, 236, 48, 237, 80, 236, 29, 237, 117, 237, 12, 239, 195, 238, 89, 237, 10, 11, 73, 6, 248, 8, 36, 240, 241, 243, 219, 237, 214, 11, 252, 2, 108, 255, 111, 240, 201, 239, 162, 239, 211, 238, 216, 239, 18, 242, 134, 238, 229, 238, 93, 241, 116, 0, 1, 255, 55, 255, 207, 254, 35, 253, 136, 1, 107, 239, 77, 237, 29, 240, 225, 239, 207, 239, 98, 236, 241, 241, 81, 241, 124, 241, 70, 240, 127, 241, 118, 241, 39, 240, 51, 241, 124, 240, 220, 241, 162, 240, 62, 239, 81, 241, 111, 240, 116, 240, 242, 239, 18, 240, 248, 239, 99, 240, 98, 240, 154, 240, 18, 240, 188, 240, 244, 240, 225, 242, 171, 240, 29, 242, 169, 240, 120, 240, 181, 240, 112, 242, 105, 242, 82, 242, 45, 241, 101, 242, 213, 245, 110, 242, 158, 241, 124, 241, 178, 249, 34, 242, 230, 1, 159, 240, 210, 239, 250, 239, 11, 254, 202, 238, 76, 242, 192, 239, 199, 241, 1, 240, 176, 241, 27, 240, 210, 240, 77, 240, 201, 240, 49, 240, 162, 240, 111, 240, 24, 241, 1, 240, 47, 241, 137, 243, 157, 247, 215, 239, 101, 240, 35, 240, 105, 241, 148, 240, 204, 240, 159, 238, 149, 240, 88, 240, 0, 240, 29, 240, 204, 240, 113, 240, 56, 240, 98, 244, 51, 244, 3, 244, 252, 242, 228, 243, 190, 242, 68, 244, 17, 244, 213, 242, 159, 241, 200, 241, 154, 242, 48, 243, 235, 241, 28, 243, 250, 245, 173, 243, 63, 244, 84, 241, 234, 241, 51, 242, 100, 243, 253, 242, 65, 242, 158, 242, 90, 242, 245, 243, 97, 244, 12, 243, 242, 242, 94, 240, 219, 240, 39, 241, 140, 241, 194, 239, 85, 238, 188, 241, 58, 239, 173, 239, 103, 241, 120, 240, 51, 241, 219, 239, 234, 239, 216, 239, 101, 240, 217, 237, 53, 239, 229, 241, 249, 240, 255, 240, 56, 241, 4, 241, 72, 241, 203, 240, 94, 240, 46, 240, 74, 239, 186, 239, 14, 240, 74, 244, 102, 241, 254, 241, 63, 241, 98, 244, 105, 242, 103, 241, 96, 241, 62, 241, 232, 240, 10, 241, 152, 240, 31, 241, 179, 241, 84, 241, 26, 241, 192, 240, 6, 240, 71, 245, 64, 243, 190, 243, 65, 244, 27, 243, 84, 242, 58, 241, 72, 243, 77, 243, 165, 241, 246, 242, 198, 241, 58, 241, 191, 242, 38, 239, 62, 243, 222, 242, 218, 242, 110, 241, 175, 240, 153, 241, 36, 241, 211, 241, 8, 242, 185, 244, 254, 241, 161, 241, 162, 243, 18, 243, 114, 244, 179, 241, 46, 242, 84, 242, 52, 243, 29, 244, 43, 239, 143, 238, 186, 243, 141, 240, 24, 242, 46, 241, 214, 242, 35, 241, 75, 240, 127, 242, 137, 241, 135, 241, 139, 242, 135, 242, 110, 243, 90, 243, 3, 243, 169, 241, 188, 241, 251, 242, 210, 240, 253, 239, 193, 243, 49, 244, 60, 241, 101, 241, 208, 243, 12, 243, 143, 240, 14, 240, 20, 240, 77, 240, 107, 240, 127, 242, 138, 242, 100, 241, 165, 240, 46, 241, 6, 240, 196, 240, 112, 239, 65, 240, 251, 238, 8, 239, 131, 239, 36, 239, 215, 240, 169, 238, 119, 239, 123, 238, 153, 238, 52, 241, 65, 241, 3, 237, 94, 241, 215, 242, 132, 241, 105, 241, 29, 239, 77, 238, 104, 239, 236, 240, 217, 242, 132, 241, 149, 240, 235, 243, 196, 242, 90, 243, 255, 242, 88, 243, 179, 243, 102, 238, 42, 243, 0, 241, 132, 240, 205, 240, 126, 241, 25, 241, 83, 243, 107, 243, 15, 241, 153, 243, 38, 243, 251, 241, 14, 240, 57, 240, 189, 239, 184, 239, 203, 239, 125, 240, 163, 240, 93, 240, 176, 239, 234, 240, 201, 240, 2, 240, 45, 240, 80, 240, 242, 240, 111, 240, 66, 241, 32, 242, 48, 241, 65, 241, 128, 244, 230, 241, 203, 240, 43, 241, 87, 240, 182, 240, 71, 239, 161, 241, 241, 241, 125, 240, 84, 240, 145, 240, 121, 240, 5, 242, 187, 239, 143, 241, 41, 242, 85, 240, 120, 241, 205, 240, 197, 241, 191, 241, 212, 244, 166, 236, 206, 237, 177, 237, 183, 236, 31, 237, 203, 236, 66, 237, 101, 239, 97, 238, 42, 239, 238, 238, 19, 239, 110, 238, 50, 238, 147, 238, 212, 238, 158, 239, 129, 237, 16, 238, 228, 237, 176, 240, 250, 239, 36, 240, 181, 239, 35, 239, 233, 237, 29, 240, 64, 240, 105, 240, 44, 240, 106, 239, 153, 241, 210, 238, 44, 240, 61, 240, 93, 241, 199, 238, 187, 239, 153, 239, 43, 239, 219, 238, 170, 239, 125, 239, 110, 239, 163, 243, 22, 243, 206, 243, 132, 243, 196, 245, 85, 241, 194, 241, 212, 242, 250, 242, 240, 241, 243, 241, 121, 243, 5, 242, 22, 241, 9, 244, 80, 243, 182, 246, 134, 242, 3, 244, 4, 243, 13, 244, 127, 243, 179, 242, 22, 242, 209, 243, 113, 243, 160, 243, 3, 242, 39, 241, 134, 240, 223, 240, 237, 242, 58, 242, 163, 243, 195, 246, 169, 244, 65, 242, 110, 241, 30, 242, 94, 242, 117, 241, 59, 243, 230, 241, 124, 241, 179, 241, 123, 241, 1, 242, 38, 241, 118, 239, 1, 243, 200, 239, 214, 239, 216, 238, 149, 239, 104, 239, 56, 241, 209, 239, 237, 239, 39, 240, 107, 241, 150, 240, 10, 240, 42, 240, 153, 239, 249, 240, 43, 240, 207, 239, 34, 239, 1, 241, 183, 239, 30, 240, 231, 239, 143, 239, 184, 239, 66, 244, 196, 243, 107, 242, 196, 241, 243, 243, 8, 242, 75, 242, 223, 241, 6, 243, 71, 242, 13, 241, 217, 246, 165, 243, 183, 240, 53, 241, 242, 243, 253, 247, 36, 244, 165, 2, 36, 242, 188, 237, 250, 231, 235, 239, 190, 237, 144, 243, 203, 240, 127, 241, 187, 240, 195, 241, 15, 240, 215, 238, 15, 247, 150, 238, 81, 239, 186, 240, 189, 239, 54, 240, 31, 239, 145, 243, 8, 240, 56, 238, 24, 238, 250, 239, 10, 239, 197, 238, 43, 243, 119, 240, 13, 241, 88, 244, 174, 243, 135, 239, 214, 242, 72, 240, 153, 238, 160, 243, 233, 241, 168, 237, 26, 238, 43, 238, 109, 237, 96, 237, 48, 238, 15, 239, 13, 245, 99, 239, 78, 239, 5, 241, 168, 241, 12, 241, 217, 240, 57, 242, 194, 240, 195, 240, 163, 240, 148, 239, 213, 240, 143, 240, 83, 240, 132, 240, 214, 240, 81, 247, 226, 240, 73, 239, 50, 240, 248, 241, 204, 242, 105, 240, 209, 240, 213, 241, 147, 241, 210, 241, 0, 242, 14, 239, 246, 238, 1, 238, 127, 239, 53, 240, 176, 240, 107, 241, 165, 246, 205, 240, 88, 239, 180, 240, 138, 241, 121, 240, 112, 239, 105, 240, 6, 240, 29, 241, 140, 239, 76, 243, 25, 239, 29, 239, 186, 240, 197, 238, 33, 241, 187, 240, 7, 240, 227, 240, 229, 241, 149, 239, 96, 239, 16, 239, 62, 238, 165, 239, 213, 239, 61, 239, 12, 238, 125, 239, 38, 239, 218, 248, 95, 240, 129, 242, 157, 242, 233, 241, 236, 243, 164, 241, 111, 241, 192, 240, 12, 241, 129, 241, 97, 240, 84, 244, 105, 243, 121, 242, 224, 240, 0, 241, 126, 244, 119, 240, 244, 240, 111, 240, 203, 241, 214, 240, 113, 242, 221, 237, 164, 237, 147, 237, 95, 238, 125, 238, 249, 238, 221, 238, 230, 238, 130, 238, 235, 238, 241, 238, 72, 238, 81, 239, 205, 239, 89, 238, 149, 238, 51, 239, 179, 238, 234, 238, 63, 238, 171, 238, 235, 237, 245, 240, 81, 240, 237, 240, 221, 239, 77, 240, 84, 240, 45, 239, 206, 239, 79, 240, 88, 240, 211, 238, 18, 240, 130, 239, 168, 239, 246, 238, 93, 241, 85, 239, 23, 240, 92, 238, 124, 238, 201, 237, 2, 239, 51, 238, 227, 238, 150, 237, 181, 238, 96, 238, 31, 238, 27, 239, 203, 238, 87, 238, 164, 237, 182, 237, 21, 238, 181, 238, 7, 238, 27, 238, 189, 237, 162, 238, 81, 238, 69, 238, 128, 238, 9, 238, 199, 237, 216, 237, 59, 238, 67, 238, 242, 238, 150, 238, 157, 237, 79, 239, 219, 238, 111, 238, 207, 238, 12, 239, 43, 239, 65, 239, 109, 239, 248, 238, 103, 238, 195, 239, 145, 238, 15, 240, 97, 239, 186, 238, 118, 238, 98, 238, 6, 239, 41, 239, 232, 238, 252, 237, 231, 237, 2, 238, 40, 238, 137, 237, 247, 237, 16, 238, 69, 238, 151, 237, 133, 237, 239, 237, 115, 238, 41, 238, 182, 237, 178, 238, 207, 237, 77, 238, 223, 237, 228, 238, 135, 238, 52, 239, 175, 238, 22, 238, 149, 238, 11, 238, 243, 238, 26, 240, 34, 238, 9, 238, 34, 238, 187, 238, 184, 238, 221, 238, 47, 238, 230, 238, 202, 238, 197, 238, 11, 239, 245, 238, 212, 238, 82, 238, 118, 238, 120, 238, 184, 237, 144, 237, 181, 238, 99, 238, 90, 238, 28, 235, 1, 234, 47, 235, 92, 235, 167, 235, 254, 234, 177, 234, 138, 235, 41, 235, 90, 235, 171, 235, 7, 235, 132, 235, 74, 235, 216, 234, 38, 235, 183, 235, 174, 236, 63, 232, 122, 236, 23, 235, 209, 235, 235, 233, 18, 235, 11, 235, 213, 238, 113, 239, 37, 238, 40, 238, 160, 237, 31, 238, 147, 238, 100, 236, 95, 237, 176, 236, 8, 237, 179, 237, 82, 238, 110, 236, 103, 236, 5, 236, 157, 238, 35, 238, 32, 238, 95, 236, 170, 236, 109, 235, 92, 236, 74, 236, 189, 236, 224, 236, 41, 236, 121, 236, 179, 236, 86, 236, 176, 236, 36, 237, 88, 237, 211, 236, 10, 237, 190, 237, 71, 237, 243, 236, 61, 237, 222, 236, 118, 236, 90, 236, 48, 236, 178, 236, 146, 236, 143, 237, 37, 237, 7, 237, 69, 236, 139, 236, 184, 236, 69, 236, 2, 236, 163, 235, 89, 237, 111, 236, 144, 236, 162, 235, 49, 236, 167, 235, 0, 236, 67, 235, 151, 236, 144, 236, 22, 236, 140, 237, 237, 235, 23, 237, 37, 236, 30, 236, 213, 237, 2, 236, 185, 235, 213, 235, 206, 235, 95, 239, 179, 239, 144, 239, 145, 248, 242, 255, 218, 255, 173, 248, 152, 255, 130, 239, 144, 238, 123, 238, 157, 239, 188, 238, 124, 237, 203, 237, 93, 243, 119, 243, 96, 244, 87, 237, 251, 236, 63, 237, 87, 236, 29, 237, 123, 241, 208, 238, 130, 236, 63, 237, 45, 238, 126, 237, 250, 239, 147, 238, 254, 238, 224, 239, 196, 239, 133, 239, 39, 239, 55, 240, 108, 239, 34, 242, 100, 239, 3, 239, 117, 239, 182, 254, 253, 241, 86, 242, 45, 240, 100, 239, 232, 239, 99, 240, 47, 240, 127, 239, 156, 242, 123, 239, 21, 240, 48, 239, 168, 239, 10, 240, 84, 240, 175, 243, 64, 1, 45, 238, 93, 238, 229, 238, 221, 237, 22, 237, 141, 237, 118, 238, 19, 238, 229, 237, 218, 234, 165, 235, 133, 235, 150, 237, 232, 237, 42, 237, 106, 238, 59, 236, 123, 236, 11, 238, 161, 237, 18, 238, 78, 238, 47, 239, 151, 237, 89, 238, 1, 238, 63, 238, 86, 241, 219, 242, 54, 238, 192, 237, 50, 238, 189, 237, 154, 237, 102, 237, 169, 238, 31, 241, 40, 239, 237, 238, 25, 239, 38, 236, 102, 237, 135, 235, 21, 236, 237, 236, 92, 238, 149, 237, 0, 237, 184, 237, 117, 237, 60, 238, 202, 237, 128, 238, 218, 238, 103, 238, 233, 238, 103, 239, 33, 239, 13, 238, 193, 237, 119, 238, 114, 238, 211, 238, 60, 239, 53, 239, 70, 239, 119, 239, 20, 238, 140, 238, 24, 238, 215, 238, 75, 239, 87, 240, 69, 239, 200, 238, 235, 239, 235, 237, 129, 238, 241, 238, 133, 238, 175, 238, 14, 239, 119, 238, 135, 238, 207, 238, 130, 238, 56, 239, 4, 239, 76, 239, 236, 238, 194, 238, 63, 239, 163, 238, 198, 239, 93, 238, 106, 238, 162, 238, 39, 240, 123, 238, 177, 238, 182, 238, 239, 238, 20, 238, 13, 238, 180, 238, 159, 238, 175, 238, 146, 239, 84, 239, 221, 237, 57, 238, 123, 238, 210, 237, 67, 238, 237, 238, 224, 238, 88, 239, 195, 238, 161, 239, 81, 238, 41, 239, 57, 239, 42, 239, 179, 238, 150, 238, 161, 240, 200, 238, 154, 239, 94, 239, 83, 239, 122, 239, 161, 239, 119, 235, 67, 235, 95, 239, 4, 238, 37, 236, 217, 234, 1, 235, 52, 234, 122, 234, 212, 233, 118, 239, 205, 235, 238, 235, 240, 234, 29, 235, 74, 235, 98, 235, 135, 236, 91, 235, 10, 235, 68, 235, 46, 235, 19, 236, 36, 242, 92, 237, 147, 240, 164, 235, 103, 236, 92, 236, 218, 236, 210, 240, 37, 240, 61, 237, 202, 248, 137, 237, 90, 235, 131, 235, 23, 245, 80, 234, 167, 234, 240, 234, 99, 244, 248, 234, 99, 236, 147, 235, 150, 234, 227, 233, 159, 237, 55, 235, 124, 237, 22, 234, 241, 233, 181, 235, 13, 235, 40, 234, 135, 235, 114, 237, 162, 236, 96, 238, 7, 238, 230, 252, 40, 236, 35, 244, 140, 236, 212, 237, 158, 255, 121, 237, 145, 244, 160, 238, 160, 239, 174, 236, 81, 237, 249, 236, 215, 236, 219, 237, 110, 237, 159, 237, 197, 237, 78, 237, 97, 244, 204, 242, 222, 242, 175, 234, 144, 235, 241, 234, 91, 235, 3, 236, 45, 236, 1, 238, 22, 237, 238, 235, 232, 235, 79, 236, 117, 238, 140, 236, 106, 236, 56, 237, 50, 236, 110, 250, 192, 236, 231, 234, 24, 235, 102, 233, 176, 234, 167, 234, 86, 235, 201, 236, 141, 234, 171, 234, 165, 235, 113, 234, 70, 234, 107, 235, 182, 234, 44, 234, 151, 235, 208, 236, 14, 240, 220, 233, 106, 233, 76, 233, 154, 234, 8, 233, 62, 234, 10, 243, 236, 235, 113, 236, 128, 235, 75, 235, 231, 234, 222, 243, 195, 238, 255, 236, 0, 235, 204, 235, 82, 240, 191, 236, 93, 235, 242, 235, 67, 237, 33, 235, 102, 235, 4, 239, 38, 237, 99, 233, 223, 235, 24, 242, 61, 237, 80, 233, 76, 232, 2, 234, 135, 234, 54, 232, 77, 234, 255, 233, 1, 235, 28, 235, 57, 242, 109, 235, 73, 239, 216, 233, 117, 235, 85, 235, 229, 241, 155, 235, 28, 239, 148, 236, 100, 235, 63, 237, 36, 233, 252, 231, 136, 232, 152, 234, 248, 233, 104, 235, 115, 232, 170, 232, 253, 231, 207, 234, 162, 235, 13, 235, 21, 236, 163, 234, 139, 233, 95, 237, 86, 235, 2, 234, 13, 238, 53, 235, 142, 237, 163, 232, 60, 233, 14, 233, 7, 233, 19, 233, 140, 235, 242, 232, 1, 234, 154, 233, 210, 232, 12, 234, 245, 238, 203, 240, 213, 233, 242, 233, 148, 232, 74, 233, 155, 232, 203, 234, 78, 235, 234, 235, 62, 235, 107, 235, 120, 235, 142, 235, 60, 239, 58, 235, 177, 235, 181, 0, 63, 247, 14, 235, 78, 236, 183, 233, 227, 234, 194, 233, 205, 235, 63, 235, 205, 233, 144, 236, 3, 237, 171, 237, 52, 236, 40, 236, 163, 236, 125, 236, 116, 237, 211, 242, 82, 246, 19, 239, 119, 238, 29, 237, 149, 234, 87, 235, 63, 235, 193, 237, 90, 235, 131, 236, 34, 237, 9, 237, 195, 239, 55, 238, 166, 236, 40, 239, 167, 236, 131, 239, 212, 244, 199, 237, 23, 238, 226, 239, 243, 238, 145, 239, 161, 236, 134, 237, 143, 247, 74, 235, 201, 235, 9, 235, 10, 235, 230, 234, 63, 234, 130, 234, 169, 234, 191, 233, 176, 233, 3, 234, 81, 235, 210, 234, 141, 234, 85, 234, 110, 234, 151, 233, 27, 234, 232, 234, 150, 234, 206, 233, 158, 234, 73, 234, 180, 234, 211, 233, 80, 234, 110, 253, 25, 239, 189, 239, 150, 237, 52, 241, 123, 234, 230, 233, 132, 234, 79, 235, 177, 236, 167, 234, 54, 237, 108, 235, 10, 234, 62, 234, 68, 237, 84, 235, 12, 237, 236, 235, 238, 233, 239, 235, 9, 237, 189, 241, 253, 234, 96, 233, 14, 234, 60, 234, 254, 233, 181, 233, 207, 233, 62, 245, 242, 240, 216, 248, 141, 249, 196, 235, 201, 243, 127, 235, 200, 239, 62, 236, 11, 237, 110, 240, 99, 240, 57, 236, 178, 236, 250, 234, 206, 234, 93, 235, 178, 235, 98, 234, 145, 235, 214, 234, 179, 235, 90, 235, 109, 233, 180, 234, 0, 235, 154, 239, 138, 235, 29, 236, 144, 244, 216, 237, 131, 235, 230, 239, 47, 238, 170, 241, 85, 244, 17, 238, 67, 242, 18, 237, 36, 236, 172, 236, 122, 237, 74, 242, 35, 238, 197, 234, 103, 234, 18, 237, 166, 236, 156, 234, 116, 235, 46, 236, 157, 237, 84, 237, 88, 237, 212, 232, 38, 247, 167, 233, 107, 235, 45, 236, 2, 235, 73, 236, 241, 234, 185, 235, 180, 238, 30, 245, 153, 235, 196, 237, 64, 244, 140, 236, 252, 235, 4, 237, 44, 236, 189, 252, 57, 248, 239, 247, 183, 241, 90, 244, 34, 222, 165, 245, 48, 247, 56, 247, 179, 234, 189, 245, 207, 233, 10, 224, 108, 234, 24, 237, 113, 233, 238, 232, 91, 232, 253, 246, 232, 253, 114, 251, 124, 248, 99, 249, 101, 244, 88, 251, 196, 246, 215, 247, 24, 241, 25, 243, 238, 247, 123, 234, 46, 234, 206, 235, 236, 233, 245, 233, 62, 234, 74, 234, 42, 234, 231, 233, 161, 233, 12, 234, 203, 233, 192, 233, 138, 233, 198, 233, 20, 234, 232, 233, 96, 234, 214, 237, 124, 236, 43, 235, 2, 234, 250, 233, 93, 234, 87, 233, 41, 235, 125, 234, 36, 233, 163, 233, 252, 233, 67, 2, 195, 251, 69, 253, 50, 248, 176, 251, 228, 244, 116, 247, 70, 246, 175, 247, 236, 249, 131, 251, 9, 247, 80, 247, 111, 245, 45, 245, 211, 242, 185, 250, 143, 248, 73, 229, 222, 241, 241, 231, 32, 245, 41, 252, 102, 250, 64, 246, 214, 253, 26, 248, 114, 247, 230, 246, 14, 246, 59, 235, 175, 235, 99, 235, 239, 234, 106, 238, 84, 233, 29, 227, 96, 231, 218, 233, 200, 234, 62, 248, 6, 240, 208, 250, 170, 250, 248, 250, 220, 234, 150, 227, 234, 232, 158, 251, 188, 241, 207, 240, 233, 239, 135, 240, 173, 247, 189, 238, 64, 241, 86, 244, 213, 236, 63, 238, 116, 236, 121, 237, 153, 237, 81, 238, 128, 244, 9, 242, 71, 238, 206, 238, 171, 237, 238, 237, 88, 238, 190, 237, 210, 237, 238, 237, 56, 237, 247, 236, 191, 238, 238, 245, 82, 239, 161, 241, 94, 243, 255, 241, 173, 243, 151, 240, 110, 236, 19, 244, 177, 245, 204, 245, 100, 235, 74, 234, 58, 235, 46, 237, 207, 235, 224, 237, 234, 233, 83, 235, 82, 236, 76, 235, 162, 233, 216, 236, 55, 237, 107, 235, 64, 235, 4, 236, 10, 236, 68, 236, 5, 243, 131, 241, 40, 245, 246, 234, 60, 236, 72, 234, 129, 237, 61, 237, 227, 236, 157, 236, 89, 236, 204, 236, 31, 237, 12, 237, 47, 236, 136, 238, 129, 237, 254, 237, 190, 236, 40, 238, 199, 236, 95, 236, 223, 236, 12, 239, 119, 236, 79, 236, 160, 236, 148, 236, 137, 237, 114, 238, 147, 238, 206, 237, 57, 239, 143, 236, 2, 236, 244, 235, 20, 236, 13, 236, 53, 237, 86, 242, 140, 237, 231, 236, 37, 236, 114, 235, 252, 237, 50, 238, 194, 245, 37, 244, 180, 235, 105, 236, 90, 240, 15, 235, 78, 237, 218, 234, 242, 235, 147, 234, 25, 236, 116, 234, 86, 234, 53, 233, 43, 235, 123, 236, 152, 236, 166, 231, 27, 234, 85, 233, 57, 234, 213, 233, 18, 233, 144, 236, 212, 234, 209, 236, 184, 232, 232, 233, 162, 233, 176, 233, 72, 236, 166, 237, 87, 233, 238, 234, 155, 232, 159, 245, 115, 246, 63, 246, 69, 250, 92, 249, 204, 248, 202, 241, 207, 249, 23, 242, 222, 237, 209, 241, 66, 246, 92, 241, 23, 238, 253, 238, 81, 239, 1, 238, 201, 255, 114, 237, 220, 236, 164, 235, 202, 247, 221, 242, 50, 246, 116, 237, 189, 239, 71, 240, 140, 243, 47, 241, 193, 243, 19, 241, 221, 240, 214, 247, 55, 238, 72, 238, 118, 241, 32, 239, 89, 240, 206, 239, 250, 233, 28, 235, 109, 233, 237, 237, 91, 235, 161, 236, 231, 234, 166, 234, 202, 234, 158, 236, 56, 237, 203, 237, 209, 235, 11, 236, 114, 235, 163, 240, 227, 238, 172, 247, 39, 239, 19, 236, 104, 240, 30, 235, 76, 235, 83, 234, 109, 234, 87, 233, 240, 237, 221, 239, 255, 240, 171, 241, 87, 239, 238, 233, 240, 234, 239, 232, 80, 235, 49, 236, 118, 236, 255, 235, 162, 234, 253, 238, 2, 236, 131, 235, 255, 234, 160, 233, 208, 234, 77, 236, 64, 236, 159, 236, 55, 235, 77, 236, 190, 236, 177, 234, 240, 233, 116, 233, 212, 234, 174, 235, 237, 233, 119, 235, 66, 235, 105, 235, 84, 234, 227, 236, 123, 234, 47, 235, 191, 236, 221, 234, 10, 237, 229, 236, 135, 236, 78, 236, 75, 238, 32, 236, 221, 234, 75, 234, 106, 234, 161, 234, 205, 233, 158, 233, 45, 234, 24, 236, 191, 237, 7, 234, 61, 235, 242, 245, 85, 247, 199, 249, 148, 246, 10, 248, 5, 234, 176, 221, 207, 246, 134, 237, 134, 233, 4, 0, 35, 247, 23, 239, 166, 255, 178, 247, 146, 240, 200, 228, 234, 244, 235, 245, 103, 246, 30, 249, 4, 248, 48, 234, 15, 245, 176, 233, 97, 234, 10, 235, 17, 246, 147, 237, 142, 238, 109, 237, 212, 234, 224, 234, 75, 237, 0, 0, 238, 235, 215, 235, 78, 234, 161, 236, 35, 236, 154, 234, 235, 233, 40, 235, 76, 235, 218, 234, 84, 235, 229, 234, 208, 234, 18, 235, 206, 235, 48, 235, 115, 233, 114, 235, 237, 235, 195, 234, 155, 234, 74, 235, 94, 235, 218, 235, 75, 234, 65, 234, 195, 235, 43, 238, 138, 237, 229, 240, 215, 236, 14, 244, 242, 235, 166, 235, 222, 237, 245, 238, 129, 238, 74, 236, 27, 239, 148, 235, 229, 239, 136, 238, 172, 237, 77, 235, 85, 234, 40, 237, 90, 236, 234, 235, 83, 235, 152, 235, 236, 237, 7, 250, 114, 239, 115, 237, 155, 238, 237, 236, 24, 237, 19, 239, 229, 237, 166, 236, 19, 237, 189, 237, 144, 236, 104, 236, 172, 235, 88, 237, 81, 236, 132, 237, 99, 237, 127, 237, 55, 237, 214, 236, 239, 236, 56, 237, 28, 237, 46, 236, 69, 236, 118, 236, 179, 236, 50, 236, 78, 235, 146, 235, 212, 236, 82, 236, 184, 236, 31, 236, 26, 243, 30, 236, 73, 235, 158, 238, 97, 235, 110, 236, 115, 236, 205, 235, 177, 235, 159, 236, 55, 236, 78, 237, 39, 239, 101, 234, 88, 235, 184, 234, 192, 236, 238, 234, 194, 234, 74, 236, 55, 234, 33, 234, 245, 247, 116, 236, 19, 236, 86, 235, 232, 234, 122, 234, 249, 233, 128, 235, 166, 234, 3, 235, 15, 235, 224, 238, 15, 241, 156, 244, 196, 244, 247, 236, 153, 239, 203, 235, 163, 234, 115, 234, 249, 234, 38, 234, 53, 233, 105, 233, 18, 237, 20, 235, 188, 241, 86, 234, 73, 234, 117, 233, 159, 234, 7, 235, 194, 234, 198, 234, 56, 236, 250, 233, 109, 234, 84, 236, 165, 238, 83, 236, 219, 236, 183, 238, 77, 237, 96, 237, 47, 235, 92, 232, 228, 234, 210, 233, 23, 234, 50, 234, 48, 235, 229, 235, 4, 235, 163, 235, 106, 234, 231, 234, 29, 235, 194, 234, 156, 234, 147, 234, 19, 235, 165, 234, 194, 235, 114, 244, 101, 239, 62, 236, 139, 234, 86, 234, 76, 235, 41, 235, 138, 235, 193, 234, 241, 227, 27, 235, 189, 234, 206, 234, 87, 235, 91, 238, 59, 234, 138, 234, 147, 234, 118, 239, 128, 249, 33, 239, 128, 239, 135, 238, 30, 237, 102, 243, 107, 236, 8, 237, 23, 238, 72, 236, 201, 237, 255, 235, 6, 236, 237, 237, 30, 237, 74, 236, 219, 235, 33, 236, 130, 239, 39, 237, 232, 237, 233, 237, 110, 237, 219, 237, 78, 237, 105, 237, 185, 237, 161, 237, 2, 236, 26, 243, 191, 235, 148, 238, 253, 235, 236, 235, 120, 236, 9, 236, 193, 236, 35, 236, 140, 236, 121, 237, 194, 236, 230, 234, 180, 235, 86, 235, 136, 237, 111, 235, 155, 237, 41, 244, 164, 241, 123, 240, 205, 242, 133, 238, 143, 239, 83, 238, 68, 236, 168, 235, 123, 234, 244, 235, 113, 235, 35, 235, 89, 239, 66, 236, 152, 235, 170, 235, 177, 235, 231, 234, 130, 236, 9, 235, 164, 234, 90, 235, 221, 236, 31, 235, 28, 234, 241, 241, 188, 236, 152, 237, 58, 237, 255, 237, 162, 235, 187, 234, 199, 235, 200, 235, 235, 235, 137, 235, 248, 234, 125, 234, 160, 234, 118, 234, 187, 237, 27, 235, 4, 237, 250, 238, 126, 239, 217, 237, 212, 248, 198, 247, 158, 235, 181, 235, 2, 237, 192, 235, 2, 241, 86, 235, 36, 236, 113, 239, 225, 238, 88, 244, 97, 240, 254, 242, 89, 247, 132, 238, 180, 237, 146, 238, 86, 247, 129, 242, 149, 239, 192, 245, 127, 237, 112, 241, 226, 235, 209, 235, 136, 237, 239, 236, 108, 235, 75, 245, 96, 235, 209, 234, 73, 235, 65, 242, 51, 235, 108, 235, 53, 235, 122, 235, 162, 235, 123, 237, 191, 240, 187, 238, 192, 241, 51, 239, 106, 238, 182, 236, 231, 237, 211, 237, 216, 241, 130, 237, 225, 242, 5, 237, 2, 238, 247, 237, 166, 235, 88, 237, 126, 237, 207, 237, 215, 236, 235, 242, 23, 238, 123, 237, 127, 237, 149, 235, 103, 235, 214, 235, 70, 238, 97, 236, 226, 235, 193, 238, 176, 235, 172, 235, 110, 236, 238, 238, 110, 238, 113, 246, 183, 255, 3, 239, 137, 235, 186, 237, 155, 236, 106, 235, 72, 235, 139, 244, 9, 236, 29, 235, 42, 235, 214, 234, 81, 235, 249, 235, 204, 240, 139, 238, 202, 238, 148, 236, 224, 238, 100, 234, 158, 235, 55, 235, 195, 234, 34, 237, 184, 234, 6, 242, 21, 235, 56, 236, 155, 246, 115, 236, 132, 235, 91, 236, 238, 234, 197, 234, 0, 234, 105, 234, 182, 233, 93, 233, 160, 233, 217, 234, 48, 234, 108, 236, 9, 236, 172, 235, 154, 234, 156, 235, 163, 237, 223, 232, 9, 234, 8, 234, 55, 232, 134, 235, 63, 251, 235, 235, 215, 233, 156, 234, 53, 233, 244, 232, 0, 234, 127, 233, 78, 233, 215, 232, 249, 232, 160, 232, 170, 232, 253, 232, 241, 233, 125, 233, 2, 233, 241, 232, 31, 233, 36, 233, 32, 233, 112, 234, 157, 233, 52, 232, 66, 232, 44, 232, 247, 231, 142, 231, 74, 233, 225, 232, 118, 232, 36, 233, 162, 233, 242, 232, 220, 232, 177, 234, 34, 235, 135, 237, 220, 247, 233, 240, 179, 233, 45, 233, 243, 232, 29, 234, 195, 234, 80, 234, 226, 241, 164, 233, 14, 234, 18, 233, 181, 234, 117, 233, 183, 232, 8, 251, 36, 252, 63, 251, 224, 250, 80, 251, 51, 252, 236, 251, 131, 0, 249, 242, 13, 243, 27, 243, 58, 247, 39, 254, 41, 249, 197, 242, 234, 250, 178, 254, 38, 226, 196, 252, 8, 252, 188, 253, 245, 253, 24, 249, 219, 252, 228, 247, 243, 250, 177, 232, 248, 232, 184, 233, 166, 233, 171, 233, 11, 233, 74, 234, 118, 234, 254, 234, 123, 234, 63, 234, 131, 234, 116, 235, 157, 234, 3, 235, 138, 233, 214, 233, 199, 233, 123, 243, 203, 227, 36, 239, 23, 235, 60, 236, 234, 235, 134, 236, 139, 236, 246, 235, 242, 234, 23, 235, 157, 234, 75, 233, 233, 233, 175, 233, 237, 232, 11, 234, 38, 233, 25, 234, 30, 235, 115, 235, 163, 234, 226, 235, 186, 236, 247, 234, 234, 233, 27, 234, 112, 234, 30, 234, 48, 235, 124, 234, 231, 233, 117, 234, 134, 234, 153, 233, 169, 233, 70, 235, 99, 234, 78, 239, 63, 236, 106, 227, 226, 240, 196, 234, 68, 234, 61, 234, 44, 235, 188, 234, 200, 234, 90, 238, 190, 228, 105, 234, 22, 237, 247, 235, 27, 236, 46, 236, 224, 234, 147, 234, 159, 246, 162, 233, 158, 232, 153, 244, 209, 234, 189, 236, 248, 235, 245, 233, 185, 234, 87, 234, 50, 236, 62, 237, 94, 236, 80, 235, 143, 233, 223, 233, 210, 233, 137, 239, 29, 234, 241, 231, 10, 233, 71, 233, 96, 233, 142, 233, 122, 235, 237, 235, 166, 233, 167, 233, 41, 234, 77, 233, 133, 232, 221, 233, 255, 232, 197, 232, 162, 232, 155, 234, 33, 233, 81, 233, 250, 232, 212, 232, 100, 238, 49, 232, 40, 232, 91, 232, 104, 232, 94, 233, 124, 232, 28, 234, 124, 234, 49, 238, 48, 233, 141, 233, 188, 234, 189, 232, 209, 233, 218, 232, 167, 232, 10, 232, 1, 233, 161, 232, 36, 232, 70, 232, 183, 247, 16, 232, 231, 235, 141, 232, 46, 232, 208, 232, 211, 232, 190, 232, 148, 232, 151, 232, 75, 232, 63, 233, 16, 232, 26, 232, 214, 231, 100, 237, 96, 233, 196, 233, 193, 233, 174, 233, 149, 233, 7, 234, 119, 233, 166, 232, 226, 232, 230, 232, 112, 232, 178, 234, 201, 232, 116, 233, 198, 238, 137, 234, 112, 233, 217, 233, 128, 232, 125, 232, 115, 232, 51, 233, 5, 234, 206, 232, 156, 232, 78, 232, 172, 232, 222, 231, 208, 232, 92, 236, 228, 234, 91, 237, 252, 234, 159, 234, 149, 234, 182, 234, 183, 235, 188, 234, 61, 234, 88, 234, 182, 233, 7, 237, 189, 233, 34, 235, 141, 235, 245, 237, 208, 239, 109, 240, 219, 234, 32, 237, 242, 236, 207, 232, 16, 232, 33, 232, 141, 233, 223, 232, 183, 238, 155, 237, 168, 234, 69, 233, 23, 234, 22, 233, 213, 232, 106, 233, 196, 233, 110, 233, 252, 232, 212, 233, 159, 233, 99, 234, 129, 233, 147, 233, 81, 233, 215, 232, 145, 232, 31, 233, 154, 233, 133, 233, 196, 233, 140, 231, 153, 233, 246, 231, 255, 233, 39, 232, 233, 232, 15, 237, 170, 239, 72, 233, 145, 233, 234, 240, 78, 239, 226, 234, 212, 232, 103, 233, 97, 233, 213, 233, 116, 240, 1, 236, 45, 235, 154, 237, 42, 241, 50, 243, 237, 242, 235, 237, 251, 235, 26, 234, 35, 237, 52, 238, 106, 235, 199, 240, 249, 239, 182, 237, 137, 237, 212, 0, 210, 0, 20, 1, 131, 1, 242, 1, 145, 0, 51, 1, 158, 6, 170, 6, 78, 4, 170, 1, 106, 3, 55, 2, 69, 3, 4, 5, 53, 1, 58, 1, 145, 1, 162, 0, 144, 1, 90, 2, 111, 1, 4, 2, 31, 1, 28, 1, 10, 1, 140, 5, 57, 7, 201, 5, 207, 4, 212, 4, 176, 5, 139, 7, 140, 5, 174, 7, 6, 3, 21, 4, 120, 3, 205, 3, 2, 4, 186, 3, 102, 3, 92, 2, 236, 2, 130, 8, 217, 7, 77, 8, 117, 6, 90, 7, 102, 7, 167, 6, 45, 7, 119, 7, 200, 4, 95, 4, 124, 4, 71, 1, 55, 2, 33, 2, 57, 3, 161, 4, 241, 4, 236, 3, 65, 2, 204, 1, 219, 4, 127, 1, 44, 2, 14, 2, 99, 1, 138, 4, 167, 3, 15, 6, 223, 6, 142, 6, 168, 5, 116, 6, 125, 5, 50, 3, 139, 2, 144, 4, 167, 1, 204, 6, 39, 2, 83, 3, 63, 2, 32, 2, 113, 251, 199, 2, 95, 3, 36, 4, 176, 2, 249, 1, 228, 1, 234, 1, 36, 2, 47, 3, 78, 3, 203, 1, 55, 2, 87, 0, 117, 1, 41, 2, 245, 0, 108, 0, 172, 0, 122, 3, 28, 1, 13, 4, 22, 0, 41, 0, 148, 0, 165, 3, 108, 0, 66, 5, 56, 0, 62, 0, 149, 0, 52, 5, 154, 4, 57, 6, 75, 1, 252, 3, 191, 1, 47, 5, 224, 2, 18, 2, 85, 1, 173, 4, 106, 3, 158, 0, 90, 0, 55, 1, 67, 1, 252, 0, 197, 0, 5, 0, 49, 0, 29, 0, 51, 4, 194, 4, 3, 4, 28, 4, 130, 5, 113, 5, 163, 3, 32, 4, 38, 2, 2, 0, 234, 255, 8, 0, 51, 0, 5, 0, 232, 255, 26, 0, 9, 0, 244, 2, 255, 1, 31, 4, 152, 1, 164, 8, 196, 5, 93, 4, 236, 3, 162, 5, 63, 4, 249, 3, 243, 5, 233, 3, 86, 5, 14, 5, 95, 5, 16, 6, 189, 4, 211, 4, 6, 4, 110, 5, 111, 7, 33, 5, 183, 3, 5, 4, 65, 3, 158, 3, 98, 3, 179, 5, 225, 3, 120, 5, 122, 5, 253, 5, 9, 4, 16, 0, 62, 5, 14, 0, 60, 0, 96, 4, 137, 4, 110, 5, 168, 5, 204, 5, 137, 4, 181, 4, 41, 6, 39, 4, 159, 4, 68, 4, 123, 3, 251, 5, 136, 3, 131, 249, 78, 249, 138, 255, 52, 255, 248, 255, 190, 255, 9, 0, 127, 2, 68, 0, 236, 255, 221, 255, 56, 0, 147, 255, 94, 255, 47, 0, 16, 1, 57, 3, 4, 0, 191, 0, 133, 0, 41, 1, 23, 1, 163, 0, 202, 255, 177, 0, 58, 0, 185, 1, 140, 3, 204, 4, 124, 2, 148, 3, 39, 3, 69, 4, 126, 1, 39, 1, 64, 3, 3, 2, 204, 2, 131, 2, 183, 2, 153, 2, 20, 3, 76, 3, 35, 2, 40, 5, 9, 3, 8, 5, 111, 2, 206, 4, 52, 3, 205, 2, 205, 4, 38, 1, 167, 0, 190, 0, 160, 2, 146, 0, 212, 2, 142, 0, 130, 0, 159, 0, 221, 0, 95, 0, 36, 0, 240, 0, 222, 1, 210, 1, 67, 0, 91, 0, 107, 0, 55, 2, 125, 1, 12, 2, 24, 1, 31, 1, 245, 0, 166, 0, 95, 1, 164, 0, 11, 1, 158, 1, 172, 1, 31, 5, 14, 2, 60, 4, 177, 0, 68, 3, 18, 1, 10, 1, 17, 1, 59, 1, 191, 1, 71, 6, 231, 3, 125, 3, 117, 1, 197, 2, 69, 2, 63, 1, 171, 2, 125, 5, 138, 4, 36, 5, 177, 5, 209, 5, 165, 4, 69, 3, 188, 3, 45, 4, 234, 3, 9, 4, 218, 3, 156, 3, 67, 3, 104, 8, 139, 4, 84, 4, 239, 6, 112, 4, 8, 5, 145, 4, 186, 5, 161, 0, 137, 0, 127, 0, 152, 0, 78, 1, 70, 3, 128, 2, 10, 4, 188, 3, 9, 3, 47, 2, 166, 0, 58, 3, 190, 4, 70, 3, 121, 3, 173, 2, 123, 3, 142, 3, 136, 1, 222, 3, 23, 3, 123, 4, 53, 8, 204, 2, 29, 3, 202, 2, 47, 4, 40, 4, 130, 4, 161, 3, 170, 3, 1, 3, 9, 3, 253, 2, 16, 3, 127, 2, 29, 2, 100, 2, 18, 2, 112, 2, 50, 3, 125, 3, 197, 3, 28, 3, 93, 2, 142, 2, 102, 3, 227, 2, 71, 3, 219, 3, 170, 2, 106, 2, 102, 2, 203, 2, 39, 3, 56, 3, 137, 3, 151, 2, 53, 3, 235, 2, 171, 2, 226, 0, 49, 245, 89, 0, 20, 237, 167, 234, 216, 235, 41, 236, 195, 234, 5, 237, 138, 248, 195, 243, 143, 243, 71, 236, 208, 237, 172, 243, 250, 251, 8, 251, 120, 239, 90, 242, 236, 255, 22, 239, 110, 237, 194, 243, 28, 244, 233, 241, 73, 246, 227, 237, 57, 236, 188, 236, 149, 236, 105, 238, 180, 236, 15, 239, 138, 233, 129, 231, 172, 232, 68, 239, 20, 234, 76, 239, 55, 238, 150, 232, 130, 232, 231, 232, 7, 233, 82, 231, 201, 233, 31, 234, 145, 233, 252, 235, 81, 236, 224, 231, 239, 234, 160, 233, 47, 234, 99, 222, 9, 235, 88, 234, 236, 232, 198, 232, 133, 233, 106, 239, 69, 240, 76, 239, 253, 248, 238, 243, 26, 242, 91, 254, 198, 238, 210, 249, 191, 240, 225, 254, 189, 247, 211, 251, 238, 250, 116, 237, 70, 255, 213, 255, 190, 255, 200, 255, 70, 0, 253, 255, 202, 254, 240, 255, 169, 253, 167, 2, 12, 0, 240, 2, 0, 0, 0, 0, 97, 253, 34, 243, 189, 2, 152, 250, 17, 0, 45, 0, 145, 255, 31, 253, 0, 0, 254, 255, 225, 2, 21, 239, 65, 238, 104, 0, 107, 240, 59, 247, 26, 3, 115, 252, 200, 3, 127, 245, 84, 243, 38, 238, 39, 241, 0, 242, 102, 242, 179, 249, 220, 242, 214, 242, 196, 236, 176, 238, 66, 238, 182, 237, 212, 237, 253, 236, 71, 246, 21, 240, 135, 243, 163, 239, 216, 238, 94, 237, 65, 243, 17, 243, 181, 240, 18, 237, 97, 238, 121, 237, 171, 247, 37, 240, 249, 238, 143, 242, 52, 244, 129, 243, 175, 234, 88, 233, 21, 233, 160, 236, 18, 239, 27, 240, 132, 233, 242, 232, 90, 232, 128, 233, 247, 232, 13, 234, 159, 232, 90, 232, 110, 232, 123, 237, 192, 238, 1, 239, 117, 237, 160, 237, 32, 236, 5, 239, 49, 241, 211, 235, 7, 234, 67, 234, 140, 235, 151, 239, 119, 238, 79, 239, 47, 235, 211, 233, 162, 235, 237, 234, 33, 241, 32, 242, 160, 236, 32, 236, 98, 237, 108, 237, 68, 238, 111, 235, 175, 238, 57, 236, 166, 236, 254, 231, 236, 236, 244, 233, 166, 236, 17, 241, 58, 236, 209, 236, 23, 236, 211, 234, 128, 236, 228, 235, 231, 236, 100, 238, 235, 236, 207, 235, 55, 238, 27, 238, 211, 235, 55, 235, 217, 236, 176, 235, 207, 236, 208, 237, 142, 237, 142, 238, 4, 238, 28, 237, 94, 238, 148, 236, 100, 237, 118, 0, 26, 0, 39, 0, 74, 0, 43, 0, 191, 0, 196, 0, 118, 0, 68, 0, 224, 1, 1, 1, 87, 0, 20, 2, 167, 1, 144, 1, 32, 1, 245, 3, 38, 5, 115, 1, 113, 1, 127, 2, 31, 0, 114, 3, 114, 0, 72, 2, 17, 1, 237, 1, 174, 1, 72, 1, 217, 0, 188, 239, 127, 240, 208, 239, 40, 240, 1, 241, 220, 240, 253, 240, 150, 240, 86, 241, 99, 244, 58, 243, 184, 244, 38, 245, 194, 240, 99, 242, 229, 2, 167, 245, 160, 241, 199, 255, 143, 255, 218, 255, 92, 248, 178, 253, 156, 249, 149, 254, 204, 254, 132, 250, 83, 241, 56, 244, 206, 241, 56, 233, 36, 232, 11, 241, 172, 253, 78, 247, 223, 254, 66, 234, 179, 230, 62, 229, 201, 255, 151, 255, 174, 255, 198, 249, 213, 254, 190, 0, 145, 255, 97, 255, 96, 250, 157, 233, 108, 235, 94, 235, 104, 233, 56, 234, 72, 234, 108, 234, 91, 231, 77, 240, 217, 253, 23, 0, 114, 248, 35, 0, 197, 255, 209, 255, 159, 0, 81, 0, 116, 243, 204, 2, 116, 240, 106, 255, 25, 248, 212, 255, 220, 0, 4, 0, 178, 255, 147, 5, 230, 255, 235, 255, 196, 255, 7, 233, 139, 232, 165, 232, 62, 233, 121, 234, 48, 233, 36, 236, 192, 234, 128, 234, 50, 235, 105, 233, 147, 233, 160, 235, 180, 235, 208, 233, 247, 233, 12, 235, 60, 234, 192, 233, 27, 233, 51, 233, 20, 233, 210, 239, 188, 235, 68, 236, 172, 234, 134, 233, 253, 233, 98, 232, 56, 234, 207, 233, 228, 235, 147, 235, 254, 234, 56, 232, 169, 233, 207, 233, 28, 233, 241, 233, 47, 233, 145, 234, 114, 239, 148, 234, 252, 233, 116, 244, 4, 0, 143, 247, 230, 249, 218, 255, 216, 224, 30, 0, 181, 239, 158, 253, 198, 236, 0, 0, 171, 255, 223, 238, 98, 235, 193, 4, 19, 1, 85, 243, 131, 244, 75, 241, 189, 244, 246, 237, 38, 3, 235, 234, 215, 239, 65, 234, 219, 235, 105, 234, 2, 234, 229, 242, 150, 236, 147, 234, 72, 234, 248, 234, 254, 234, 104, 235, 244, 235, 8, 241, 234, 233, 134, 238, 134, 235, 82, 250, 18, 0, 90, 252, 34, 251, 93, 252, 159, 3, 237, 2, 79, 0, 179, 255, 153, 252, 123, 2, 193, 255, 26, 243, 116, 243, 80, 252, 63, 245, 108, 255, 224, 247, 203, 255, 255, 0, 221, 255, 37, 255, 109, 2, 150, 2, 8, 0, 220, 2, 75, 1, 65, 1, 109, 1, 213, 241, 42, 242, 149, 243, 119, 0, 35, 242, 251, 242, 124, 242, 161, 241, 42, 0, 109, 0, 103, 0, 169, 0, 7, 1, 117, 4, 159, 0, 40, 2, 173, 1, 164, 0, 64, 0, 232, 233, 29, 234, 92, 235, 225, 234, 193, 232, 68, 235, 81, 230, 120, 0, 171, 249, 74, 251, 243, 249, 23, 2, 150, 231, 87, 235, 190, 250, 62, 2, 14, 243, 146, 248, 58, 3, 96, 255, 235, 253, 15, 254, 141, 253, 55, 235, 79, 236, 58, 227, 166, 3, 121, 249, 124, 2, 88, 255, 136, 253, 217, 241, 245, 255, 124, 0, 63, 242, 69, 249, 34, 245, 216, 255, 168, 253, 60, 255, 128, 1, 119, 252, 133, 255, 137, 255, 29, 0, 82, 0, 27, 0, 78, 0, 53, 0, 116, 2, 102, 1, 14, 0, 139, 0, 7, 0, 251, 0, 182, 0, 91, 0, 244, 0, 35, 0, 39, 0, 15, 0, 24, 0, 46, 0, 46, 3, 27, 0, 53, 0, 66, 236, 152, 243, 113, 251, 111, 253, 89, 255, 230, 254, 138, 249, 169, 255, 111, 255, 85, 255, 188, 255, 151, 255, 189, 255, 231, 252, 110, 255, 177, 252, 194, 255, 16, 0, 207, 255, 154, 255, 196, 255, 194, 255, 198, 255, 241, 254, 168, 255, 133, 255, 15, 2, 227, 1, 83, 0, 224, 0, 27, 3, 149, 2, 84, 0, 32, 0, 244, 255, 231, 255, 116, 0, 222, 255, 219, 255, 29, 0, 166, 0, 12, 0, 87, 0, 129, 0, 6, 0, 235, 0, 182, 255, 199, 255, 178, 255, 204, 255, 186, 255, 0, 0, 5, 0, 223, 255, 246, 255, 4, 0, 4, 0, 182, 255, 178, 255, 167, 255, 170, 255, 199, 255, 29, 0, 2, 0, 0, 0, 226, 255, 208, 255, 222, 255, 218, 255, 248, 255, 19, 237, 239, 232, 91, 232, 99, 244, 163, 245, 31, 235, 145, 243, 125, 233, 166, 233, 234, 235, 34, 233, 6, 233, 13, 247, 204, 244, 91, 246, 255, 241, 4, 242, 143, 244, 3, 237, 184, 229, 47, 229, 209, 239, 89, 233, 161, 232, 219, 233, 15, 234, 172, 235, 177, 232, 145, 232, 189, 249, 91, 242, 108, 252, 201, 234, 127, 222, 166, 225, 90, 227, 8, 223, 95, 234, 254, 231, 157, 233, 29, 232, 163, 231, 208, 232, 192, 232, 208, 232, 49, 234, 160, 232, 19, 232, 80, 250, 232, 247, 119, 235, 110, 235, 57, 237, 143, 235, 190, 237, 80, 237, 235, 239, 26, 237, 84, 236, 77, 238, 157, 238, 220, 236, 18, 240, 133, 239, 196, 245, 202, 235, 250, 237, 252, 236, 174, 243, 246, 238, 38, 239, 52, 243, 66, 236, 240, 234, 216, 234, 23, 229, 210, 234, 64, 244, 179, 246, 73, 242, 24, 245, 117, 242, 53, 240, 149, 244, 203, 240, 63, 242, 126, 247, 245, 244, 131, 244, 86, 246, 251, 241, 230, 245, 254, 3, 19, 253, 96, 6, 211, 5, 220, 243, 122, 255, 235, 1, 250, 250, 137, 247, 185, 248, 226, 3, 113, 253, 41, 250, 206, 245, 104, 243, 248, 242, 62, 251, 190, 248, 58, 245, 120, 247, 53, 244, 242, 243, 91, 237, 114, 241, 9, 242, 200, 240, 114, 243, 202, 239, 211, 238, 79, 237, 158, 239, 75, 237, 86, 239, 233, 236, 87, 0, 166, 255, 104, 255, 29, 0, 35, 1, 241, 1, 133, 248, 65, 240, 134, 237, 162, 244, 140, 233, 37, 230, 165, 238, 230, 233, 83, 234, 195, 246, 21, 255, 26, 0, 61, 3, 53, 3, 81, 1, 91, 254, 112, 253, 51, 246, 206, 227, 111, 244, 165, 246, 92, 251, 168, 255, 28, 244, 3, 0, 2, 228, 133, 255, 106, 3, 71, 1, 80, 255, 169, 255, 70, 240, 14, 0, 89, 248, 38, 243, 94, 251, 255, 247, 176, 247, 176, 244, 211, 0, 129, 4, 225, 255, 239, 1, 24, 255, 4, 238, 172, 237, 77, 238, 121, 237, 59, 238, 119, 237, 252, 244, 146, 238, 78, 244, 25, 241, 92, 247, 104, 238, 72, 239, 223, 239, 47, 241, 183, 237, 74, 238, 23, 237, 231, 250, 222, 251, 130, 251, 173, 249, 109, 250, 25, 248, 46, 248, 147, 249, 48, 248, 173, 237, 187, 238, 189, 238, 18, 242, 84, 243, 132, 242, 10, 245, 161, 244, 253, 250, 43, 243, 130, 243, 24, 243, 93, 249, 241, 252, 81, 253, 184, 253, 12, 254, 0, 255, 201, 250, 202, 253, 133, 245, 99, 240, 110, 241, 215, 241, 47, 242, 231, 241, 82, 241, 176, 251, 67, 242, 51, 243, 204, 244, 228, 243, 10, 243, 108, 237, 249, 236, 230, 236, 73, 237, 243, 238, 58, 238, 177, 238, 179, 240, 254, 241, 86, 248, 106, 239, 72, 243, 240, 250, 92, 241, 149, 245, 198, 238, 163, 238, 60, 238, 202, 238, 212, 239, 129, 241, 213, 245, 246, 238, 116, 244, 125, 241, 0, 240, 63, 240, 247, 238, 233, 247, 137, 248, 47, 247, 239, 251, 156, 249, 214, 241, 44, 247, 102, 250, 91, 246, 93, 245, 42, 255, 58, 252, 241, 245, 127, 245, 70, 247, 84, 243, 68, 245, 216, 250, 83, 247, 236, 249, 156, 238, 67, 238, 245, 237, 219, 237, 98, 238, 186, 238, 143, 239, 141, 238, 139, 238, 0, 238, 93, 238, 186, 238, 252, 238, 238, 238, 30, 239, 249, 237, 139, 238, 231, 237, 84, 238, 173, 237, 120, 238, 127, 238, 236, 238, 118, 239, 38, 240, 34, 239, 109, 238, 20, 238, 125, 239, 209, 238, 49, 239, 79, 238, 32, 239, 168, 236, 112, 237, 41, 238, 46, 237, 87, 237, 63, 236, 255, 237, 233, 236, 57, 237, 122, 235, 182, 235, 67, 237, 11, 237, 50, 236, 112, 236, 221, 235, 60, 235, 22, 236, 115, 235, 121, 234, 74, 235, 131, 236, 175, 235, 125, 235, 85, 237, 19, 236, 39, 239, 90, 243, 26, 243, 41, 242, 94, 241, 81, 242, 217, 242, 69, 242, 54, 242, 132, 241, 41, 239, 12, 240, 68, 239, 253, 239, 152, 239, 145, 239, 222, 241, 36, 240, 225, 239, 184, 239, 205, 239, 170, 238, 178, 240, 95, 240, 218, 240, 159, 239, 152, 239, 69, 240, 19, 242, 22, 240, 33, 241, 144, 236, 190, 236, 104, 238, 1, 238, 4, 239, 0, 238, 153, 239, 225, 239, 10, 239, 74, 238, 58, 239, 75, 239, 100, 239, 133, 239, 42, 241, 105, 238, 152, 239, 231, 238, 203, 234, 170, 235, 227, 234, 79, 240, 237, 236, 234, 234, 156, 238, 128, 237, 132, 239, 166, 236, 175, 236, 178, 235, 156, 242, 108, 240, 90, 241, 104, 236, 57, 238, 11, 243, 226, 239, 56, 242, 65, 240, 241, 242, 234, 243, 111, 242, 52, 245, 139, 245, 3, 245, 79, 244, 224, 244, 106, 244, 157, 236, 12, 236, 75, 236, 44, 238, 35, 237, 205, 237, 156, 235, 167, 235, 137, 235, 163, 238, 66, 238, 161, 238, 38, 239, 45, 238, 111, 250, 235, 235, 120, 237, 26, 240, 235, 234, 17, 235, 201, 235, 68, 235, 169, 234, 222, 234, 159, 235, 66, 234, 20, 235, 28, 235, 241, 234, 102, 235, 60, 242, 226, 242, 124, 241, 245, 248, 35, 246, 246, 255, 175, 240, 29, 242, 96, 241, 177, 239, 112, 239, 186, 239, 66, 239, 130, 239, 168, 236, 56, 242, 202, 240, 140, 240, 117, 239, 177, 238, 14, 251, 88, 240, 234, 238, 123, 239, 254, 237, 101, 237, 249, 238, 48, 241, 165, 239, 168, 240, 170, 236, 98, 236, 130, 237, 182, 238, 240, 240, 158, 238, 47, 238, 23, 237, 218, 238, 230, 237, 162, 239, 186, 243, 238, 241, 74, 239, 58, 238, 106, 244, 158, 238, 195, 241, 120, 241, 145, 242, 202, 242, 22, 243, 109, 247, 251, 240, 63, 247, 46, 255, 67, 253, 232, 253, 111, 243, 68, 242, 23, 253, 56, 245, 66, 248, 66, 254, 70, 255, 161, 1, 192, 255, 23, 250, 115, 255, 113, 254, 102, 239, 123, 239, 201, 239, 170, 238, 40, 238, 80, 238, 186, 238, 196, 238, 187, 238, 0, 239, 226, 238, 239, 238, 104, 237, 14, 238, 182, 237, 159, 237, 13, 240, 157, 237, 192, 238, 163, 238, 238, 238, 97, 238, 1, 237, 224, 236, 215, 236, 165, 236, 44, 237, 110, 239, 232, 237, 219, 237, 136, 238, 111, 238, 189, 237, 27, 240, 17, 238, 134, 237, 59, 238, 63, 236, 230, 237, 139, 236, 108, 239, 120, 237, 179, 237, 140, 237, 61, 242, 180, 243, 161, 241, 192, 247, 216, 251, 78, 237, 43, 238, 222, 238, 197, 238, 113, 244, 120, 247, 151, 249, 2, 247, 24, 244, 205, 239, 242, 248, 87, 239, 38, 248, 18, 238, 113, 238, 33, 238, 48, 239, 186, 238, 86, 238, 78, 239, 198, 238, 182, 239, 21, 240, 18, 248, 216, 239, 198, 255, 215, 255, 176, 246, 105, 240, 40, 251, 22, 244, 98, 240, 51, 241, 202, 242, 210, 239, 8, 240, 154, 240, 172, 250, 154, 248, 254, 251, 44, 242, 85, 247, 31, 240, 78, 244, 103, 238, 16, 239, 114, 235, 201, 238, 102, 239, 10, 240, 135, 238, 22, 238, 64, 237, 214, 237, 227, 237, 94, 240, 153, 239, 79, 239, 127, 239, 242, 238, 138, 254, 52, 236, 74, 237, 150, 239, 246, 243, 157, 237, 32, 242, 231, 244, 69, 238, 255, 238, 56, 246, 171, 246, 97, 240, 65, 243, 133, 244, 76, 241, 180, 254, 160, 245, 36, 245, 180, 240, 28, 255, 72, 240, 249, 249, 193, 255, 170, 245, 57, 243, 47, 248, 165, 243, 113, 255, 191, 255, 21, 255, 233, 237, 55, 239, 98, 239, 166, 239, 84, 239, 214, 238, 121, 254, 77, 239, 226, 239, 120, 243, 143, 242, 138, 240, 110, 252, 131, 240, 222, 240, 154, 243, 76, 242, 4, 239, 114, 244, 72, 240, 171, 239, 24, 240, 173, 249, 77, 245, 53, 244, 113, 243, 199, 241, 136, 242, 116, 242, 220, 241, 38, 5, 50, 2, 192, 3, 5, 0, 70, 0, 42, 0, 19, 2, 18, 1, 79, 0, 157, 244, 33, 245, 10, 245, 215, 247, 192, 246, 243, 245, 196, 248, 144, 247, 37, 254, 183, 1, 40, 2, 226, 1, 124, 1, 14, 2, 175, 2, 8, 0, 241, 0, 239, 255, 253, 255, 232, 255, 76, 0, 17, 241, 74, 249, 192, 239, 189, 1, 6, 0, 124, 245, 104, 4, 57, 3, 28, 3, 49, 3, 232, 4, 157, 3, 31, 1, 56, 2, 188, 0, 138, 2, 54, 6, 29, 6, 137, 244, 131, 244, 63, 243, 81, 2, 73, 0, 185, 0, 115, 248, 227, 251, 11, 0, 251, 2, 246, 1, 221, 1, 59, 241, 66, 242, 4, 241, 151, 246, 124, 243, 77, 243, 162, 243, 222, 242, 0, 0, 252, 0, 255, 255, 118, 1, 228, 242, 230, 247, 23, 245, 178, 246, 212, 245, 175, 243, 44, 1, 0, 0, 235, 0, 96, 242, 110, 244, 188, 246, 231, 255, 216, 244, 210, 242, 80, 242, 61, 242, 75, 242, 34, 246, 203, 247, 182, 244, 63, 245, 46, 246, 184, 1, 216, 249, 8, 0, 96, 1, 93, 252, 181, 0, 10, 248, 242, 255, 192, 248, 243, 244, 134, 247, 189, 247, 127, 245, 0, 239, 227, 238, 37, 239, 100, 241, 145, 240, 9, 245, 41, 238, 3, 237, 140, 241, 149, 240, 79, 240, 237, 239, 101, 238, 10, 239, 151, 239, 156, 240, 111, 240, 112, 238, 192, 237, 128, 237, 218, 236, 132, 240, 143, 239, 174, 242, 78, 236, 193, 240, 166, 237, 60, 240, 8, 242, 54, 240, 16, 243, 16, 241, 208, 241, 86, 239, 53, 244, 204, 241, 64, 242, 61, 242, 110, 240, 59, 246, 176, 237, 222, 252, 197, 240, 201, 238, 144, 239, 24, 245, 21, 244, 188, 242, 70, 241, 123, 243, 103, 240, 61, 250, 245, 243, 101, 244, 42, 241, 34, 242, 250, 240, 72, 244, 210, 239, 146, 242, 40, 236, 146, 236, 152, 236, 82, 236, 41, 236, 180, 234, 94, 236, 88, 236, 200, 237, 186, 235, 162, 235, 148, 234, 151, 236, 190, 235, 198, 235, 213, 235, 108, 235, 51, 236, 51, 250, 208, 241, 142, 239, 58, 239, 199, 238, 70, 239, 86, 237, 249, 238, 176, 237, 219, 236, 44, 237, 251, 238, 128, 240, 19, 240, 50, 240, 115, 238, 204, 238, 112, 237, 100, 237, 92, 238, 39, 239, 149, 239, 235, 233, 74, 238, 45, 236, 243, 235, 154, 236, 207, 238, 110, 237, 66, 237, 137, 240, 90, 242, 191, 241, 110, 240, 135, 244, 22, 2, 81, 0, 29, 5, 76, 4, 230, 1, 251, 255, 71, 247, 70, 238, 208, 237, 170, 242, 144, 239, 68, 239, 47, 239, 220, 243, 242, 255, 61, 2, 38, 1, 147, 237, 99, 235, 195, 235, 107, 238, 228, 238, 119, 242, 95, 239, 189, 236, 225, 236, 17, 237, 133, 239, 13, 236, 19, 1, 240, 2, 186, 242, 169, 255, 239, 237, 64, 242, 26, 237, 166, 236, 185, 236, 40, 237, 141, 254, 136, 240, 185, 255, 228, 253, 231, 255, 171, 238, 149, 238, 170, 239, 116, 239, 191, 238, 252, 238, 43, 242, 180, 242, 189, 238, 189, 248, 49, 240, 117, 238, 140, 239, 166, 238, 194, 241, 41, 240, 139, 244, 153, 0, 71, 237, 240, 240, 186, 255, 133, 241, 132, 238, 86, 237, 117, 237, 220, 236, 253, 236, 26, 246, 149, 239, 185, 237, 167, 238, 109, 238, 179, 236, 101, 239, 4, 237, 115, 238, 8, 241, 15, 239, 106, 236, 219, 247, 171, 236, 117, 249, 244, 236, 213, 237, 42, 237, 216, 235, 131, 236, 36, 235, 111, 235, 180, 235, 96, 235, 143, 235, 10, 236, 3, 236, 198, 235, 61, 236, 153, 236, 144, 235, 83, 236, 21, 237, 170, 236, 163, 235, 178, 236, 226, 235, 140, 236, 63, 237, 20, 235, 57, 237, 84, 237, 121, 238, 125, 238, 179, 238, 87, 237, 74, 238, 115, 237, 2, 237, 31, 237, 223, 235, 60, 236, 163, 236, 6, 237, 182, 236, 92, 239, 116, 235, 127, 235, 48, 236, 66, 236, 225, 234, 195, 235, 199, 235, 48, 236, 101, 236, 170, 236, 115, 235, 112, 237, 51, 2, 58, 1, 174, 5, 198, 246, 57, 254, 186, 252, 94, 255, 81, 255, 45, 255, 141, 236, 28, 237, 194, 236, 1, 240, 87, 239, 159, 237, 15, 239, 131, 239, 124, 241, 123, 240, 66, 241, 131, 238, 14, 249, 73, 246, 134, 253, 206, 239, 9, 242, 192, 241, 178, 244, 93, 243, 7, 249, 30, 237, 115, 236, 250, 235, 48, 236, 98, 237, 190, 237, 132, 237, 154, 237, 198, 236, 137, 236, 155, 236, 121, 236, 247, 236, 179, 236, 240, 236, 92, 236, 107, 236, 49, 236, 197, 233, 51, 237, 217, 235, 133, 238, 144, 237, 182, 237, 156, 244, 43, 237, 167, 243, 142, 234, 83, 237, 90, 238, 177, 235, 229, 236, 199, 234, 191, 239, 87, 239, 92, 237, 210, 238, 208, 238, 22, 239, 156, 239, 130, 238, 149, 241, 19, 235, 42, 237, 191, 235, 230, 238, 8, 236, 15, 236, 100, 238, 33, 239, 241, 239, 207, 239, 171, 239, 109, 242, 13, 241, 143, 238, 177, 236, 51, 240, 64, 244, 4, 240, 34, 243, 139, 244, 11, 240, 55, 245, 100, 246, 4, 244, 247, 234, 133, 235, 234, 235, 151, 237, 253, 234, 229, 236, 162, 234, 231, 235, 243, 238, 213, 240, 215, 240, 92, 238, 181, 236, 105, 237, 216, 237, 90, 238, 217, 237, 231, 237, 186, 236, 254, 236, 121, 237, 105, 239, 147, 236, 67, 238, 168, 237, 20, 237, 45, 237, 13, 237, 145, 234, 159, 236, 192, 235, 185, 236, 56, 237, 42, 237, 231, 235, 107, 236, 167, 237, 111, 236, 67, 237, 227, 235, 42, 238, 63, 238, 155, 234, 59, 235, 49, 234, 118, 233, 87, 234, 77, 244, 222, 236, 240, 237, 153, 237, 134, 235, 201, 237, 191, 235, 228, 237, 149, 235, 91, 236, 17, 235, 149, 235, 3, 233, 83, 5, 75, 5, 176, 3, 87, 4, 35, 4, 26, 5, 111, 1, 182, 2, 205, 1, 40, 4, 153, 4, 4, 4, 66, 3, 224, 3, 123, 3, 171, 4, 193, 3, 207, 3, 82, 1, 13, 5, 184, 5, 217, 1, 182, 1, 93, 1, 233, 3, 191, 4, 106, 4, 120, 2, 62, 3, 120, 2, 151, 3, 26, 4, 27, 4, 64, 3, 239, 3, 136, 3, 120, 4, 241, 3, 250, 3, 159, 4, 209, 4, 67, 4, 85, 4, 156, 5, 159, 5, 114, 3, 50, 4, 141, 3, 236, 3, 95, 4, 228, 3, 76, 4, 75, 4, 181, 4, 52, 4, 28, 4, 29, 4, 109, 3, 192, 3, 210, 3, 220, 239, 182, 239, 129, 238, 159, 242, 45, 241, 146, 241, 14, 241, 40, 241, 169, 246, 110, 4, 64, 5, 217, 0, 229, 7, 14, 6, 202, 6, 203, 244, 124, 2, 125, 246, 30, 7, 75, 6, 66, 5, 195, 2, 171, 4, 199, 1, 92, 6, 153, 5, 146, 6, 133, 0, 161, 4, 100, 2, 74, 4, 185, 4, 74, 5, 186, 3, 32, 4, 219, 4, 149, 5, 238, 4, 183, 4, 76, 5, 102, 6, 185, 5, 66, 6, 119, 6, 23, 6, 191, 5, 73, 5, 12, 6, 187, 236, 101, 237, 6, 236, 34, 238, 62, 242, 236, 234, 231, 234, 176, 236, 179, 235, 233, 237, 170, 236, 102, 237, 172, 237, 98, 238, 131, 237, 31, 237, 17, 239, 151, 238, 156, 237, 144, 236, 175, 236, 164, 236, 171, 237, 2, 240, 31, 239, 109, 237, 11, 240, 147, 4, 232, 1, 92, 249, 120, 0, 149, 255, 49, 0, 140, 255, 70, 237, 147, 235, 5, 245, 25, 241, 26, 236, 213, 237, 223, 236, 9, 239, 121, 237, 167, 243, 36, 3, 182, 255, 66, 3, 76, 3, 46, 3, 137, 240, 169, 247, 188, 0, 1, 255, 151, 0, 147, 254, 30, 255, 16, 5, 70, 5, 174, 3, 202, 3, 235, 5, 80, 4, 135, 2, 162, 1, 213, 0, 156, 3, 28, 236, 199, 253, 240, 240, 44, 238, 221, 247, 140, 3, 219, 2, 14, 2, 164, 1, 138, 255, 132, 244, 2, 246, 140, 244, 45, 254, 192, 0, 131, 255, 170, 255, 83, 255, 33, 239, 215, 236, 173, 237, 70, 237, 138, 237, 134, 239, 94, 234, 123, 235, 11, 241, 89, 240, 128, 238, 213, 234, 246, 237, 172, 237, 67, 236, 72, 238, 107, 237, 135, 236, 251, 237, 156, 237, 223, 236, 239, 237, 233, 235, 92, 235, 96, 236, 91, 235, 87, 237, 84, 235, 230, 234, 137, 239, 119, 238, 1, 239, 95, 239, 127, 240, 192, 238, 199, 236, 22, 237, 173, 236, 74, 235, 30, 236, 12, 236, 132, 236, 223, 238, 149, 237, 155, 238, 52, 239, 22, 238, 123, 236, 111, 238, 223, 238, 225, 236, 159, 237, 42, 241, 40, 239, 122, 238, 44, 236, 173, 235, 72, 236, 254, 235, 40, 237, 191, 235, 193, 235, 69, 241, 71, 251, 62, 240, 254, 241, 53, 244, 130, 242, 185, 238, 155, 240, 77, 239, 32, 236, 162, 237, 143, 238, 215, 235, 155, 239, 138, 240, 13, 240, 143, 242, 177, 243, 212, 240, 125, 244, 54, 241, 179, 238, 241, 236, 99, 237, 129, 234, 249, 236, 233, 238, 8, 234, 33, 242, 179, 237, 218, 6, 161, 0, 32, 1, 145, 0, 255, 255, 11, 0, 16, 0, 67, 0, 65, 0, 173, 255, 56, 0, 111, 0, 101, 243, 226, 243, 105, 251, 167, 244, 89, 244, 67, 244, 204, 252, 125, 0, 120, 0, 49, 0, 137, 240, 90, 246, 81, 250, 100, 246, 142, 245, 236, 242, 67, 242, 163, 236, 134, 236, 151, 236, 56, 247, 85, 236, 165, 236, 73, 236, 79, 236, 204, 243, 163, 249, 187, 252, 228, 243, 143, 248, 241, 246, 211, 246, 55, 248, 7, 247, 95, 248, 6, 244, 203, 247, 179, 237, 247, 0, 242, 0, 98, 251, 17, 248, 33, 250, 57, 243, 54, 241, 248, 239, 199, 240, 111, 240, 52, 243, 128, 0, 89, 239, 146, 237, 49, 237, 53, 244, 106, 238, 99, 247, 74, 238, 106, 238, 25, 239, 85, 244, 195, 239, 58, 244, 207, 251, 156, 248, 42, 250, 194, 252, 209, 248, 222, 236, 241, 237, 164, 237, 9, 237, 163, 238, 254, 242, 142, 243, 157, 243, 227, 241, 189, 239, 230, 238, 202, 237, 240, 245, 124, 235, 161, 236, 180, 238, 20, 236, 88, 238, 141, 241, 215, 238, 43, 239, 138, 238, 2, 240, 184, 239, 33, 239, 47, 248, 16, 237, 233, 237, 18, 239, 38, 244, 5, 242, 0, 239, 251, 237, 7, 238, 108, 236, 215, 243, 115, 243, 91, 245, 178, 245, 45, 244, 163, 244, 1, 246, 147, 245, 96, 248, 174, 247, 55, 248, 35, 244, 190, 244, 235, 242, 51, 242, 35, 244, 16, 242, 202, 239, 178, 244, 242, 245, 19, 247, 242, 247, 245, 249, 83, 246, 40, 249, 95, 246, 229, 238, 91, 240, 55, 240, 48, 239, 164, 235, 102, 239, 26, 235, 149, 242, 202, 236, 247, 237, 248, 239, 11, 243, 136, 237, 228, 235, 95, 241, 235, 239, 167, 245, 3, 235, 126, 237, 199, 234, 214, 243, 250, 240, 21, 240, 93, 236, 199, 237, 100, 235, 154, 240, 221, 251, 203, 243, 49, 241, 185, 242, 81, 247, 83, 245, 216, 246, 45, 249, 179, 245, 202, 242, 42, 252, 17, 245, 139, 248, 218, 245, 101, 247, 133, 249, 213, 246, 188, 238, 168, 243, 98, 246, 193, 244, 31, 241, 253, 240, 255, 248, 1, 248, 222, 246, 166, 249, 211, 246, 90, 244, 195, 239, 205, 240, 163, 237, 170, 238, 3, 242, 191, 241, 99, 242, 170, 245, 176, 246, 68, 240, 15, 242, 169, 234, 29, 235, 114, 243, 219, 235, 44, 242, 29, 239, 226, 236, 146, 237, 196, 236, 156, 237, 159, 236, 12, 236, 245, 236, 243, 235, 174, 235, 201, 236, 167, 236, 34, 235, 114, 235, 185, 233, 12, 235, 39, 241, 86, 243, 88, 241, 217, 241, 203, 241, 249, 241, 197, 240, 56, 247, 218, 244, 40, 241, 221, 245, 111, 242, 187, 247, 108, 244, 121, 244, 102, 245, 37, 243, 22, 242, 187, 247, 228, 242, 94, 246, 216, 241, 7, 240, 155, 240, 108, 239, 184, 252, 53, 252, 5, 245, 195, 240, 98, 243, 124, 241, 205, 238, 9, 242, 124, 246, 120, 240, 213, 240, 198, 238, 129, 244, 180, 242, 46, 249, 109, 238, 168, 238, 164, 248, 74, 239, 6, 240, 66, 239, 195, 240, 113, 243, 75, 244, 172, 247, 14, 246, 8, 245, 134, 248, 70, 249, 116, 245, 148, 242, 230, 245, 159, 241, 104, 241, 98, 241, 206, 241, 230, 241, 53, 246, 52, 247, 73, 245, 187, 241, 154, 237, 11, 238, 75, 239, 238, 238, 17, 239, 111, 238, 120, 238, 148, 248, 196, 245, 166, 246, 218, 241, 38, 244, 206, 242, 142, 241, 187, 243, 195, 240, 249, 239, 202, 242, 13, 239, 30, 239, 180, 240, 19, 240, 98, 240, 56, 239, 10, 240, 41, 239, 75, 13, 92, 12, 211, 12, 85, 10, 127, 11, 120, 11, 147, 10, 80, 11, 227, 9, 60, 0, 40, 4, 46, 4, 5, 3, 74, 4, 6, 0, 246, 8, 200, 6, 213, 8, 248, 253, 114, 253, 168, 253, 194, 6, 94, 254, 102, 5, 226, 254, 189, 253, 28, 2, 238, 8, 168, 6, 54, 8, 163, 240, 116, 241, 241, 240, 16, 241, 166, 241, 123, 250, 227, 246, 23, 247, 114, 244, 141, 242, 48, 247, 101, 241, 47, 243, 67, 253, 243, 254, 129, 242, 253, 242, 71, 242, 170, 234, 250, 234, 212, 234, 144, 234, 125, 234, 183, 235, 24, 235, 212, 235, 139, 235, 250, 235, 102, 235, 47, 235, 110, 235, 18, 235, 99, 235, 43, 235, 242, 235, 55, 235, 106, 235, 43, 235, 56, 235, 51, 235, 34, 235, 213, 234, 16, 235, 0, 235, 92, 6, 189, 3, 249, 3, 236, 254, 107, 0, 232, 1, 253, 254, 163, 0, 12, 253, 201, 245, 241, 246, 213, 253, 185, 238, 138, 242, 4, 239, 251, 4, 64, 255, 81, 254, 121, 236, 3, 243, 111, 236, 217, 249, 164, 249, 33, 240, 243, 236, 21, 238, 90, 237, 225, 243, 63, 238, 5, 243, 63, 236, 188, 236, 137, 235, 201, 235, 195, 236, 27, 236, 30, 236, 208, 234, 216, 234, 119, 235, 64, 235, 122, 235, 217, 234, 84, 235, 94, 248, 71, 241, 35, 246, 183, 236, 209, 237, 238, 238, 53, 239, 62, 237, 122, 236, 126, 235, 164, 235, 210, 235, 0, 236, 217, 236, 121, 236, 189, 235, 115, 235, 110, 243, 106, 237, 161, 238, 227, 238, 227, 237, 241, 234, 99, 235, 60, 235, 66, 235, 211, 235, 173, 236, 51, 236, 234, 235, 181, 11, 227, 11, 246, 10, 138, 12, 6, 12, 19, 12, 63, 11, 234, 11, 82, 12, 176, 14, 91, 14, 242, 13, 84, 14, 157, 14, 27, 15, 245, 12, 199, 13, 30, 13, 185, 11, 168, 12, 65, 13, 134, 12, 156, 12, 100, 11, 50, 14, 87, 13, 215, 13, 42, 13, 118, 13, 1, 13, 52, 13, 108, 13, 234, 13, 81, 11, 137, 12, 122, 11, 86, 14, 134, 13, 177, 13, 123, 10, 97, 9, 15, 8, 145, 12, 53, 11, 159, 12, 24, 8, 64, 9, 6, 10, 185, 14, 99, 15, 62, 15, 30, 14, 211, 14, 176, 14, 51, 15, 127, 15, 35, 14, 85, 11, 32, 12, 184, 12, 58, 10, 173, 11, 139, 9, 37, 14, 10, 13, 167, 13, 90, 12, 252, 12, 141, 13, 168, 13, 241, 13, 86, 13, 100, 14, 103, 14, 112, 14, 49, 14, 77, 14, 164, 14, 57, 11, 149, 12, 145, 11, 177, 13, 104, 13, 43, 13, 122, 13, 98, 13, 246, 13, 142, 14, 112, 14, 42, 14, 171, 15, 225, 14, 132, 15, 146, 15, 32, 15, 215, 11, 194, 13, 241, 12, 116, 12, 200, 13, 9, 14, 162, 14, 101, 14, 146, 14, 90, 14, 116, 14, 66, 14, 213, 14, 89, 237, 89, 237, 168, 237, 10, 238, 207, 238, 223, 2, 31, 255, 193, 255, 79, 1, 121, 0, 128, 247, 168, 238, 9, 247, 79, 254, 124, 242, 160, 243, 143, 254, 113, 248, 226, 247, 71, 240, 116, 242, 113, 239, 128, 9, 140, 11, 109, 10, 104, 7, 7, 7, 4, 10, 165, 11, 169, 11, 21, 12, 209, 11, 147, 12, 68, 12, 209, 3, 151, 2, 33, 8, 149, 7, 116, 9, 162, 7, 22, 10, 199, 10, 156, 10, 64, 9, 65, 12, 253, 8, 30, 11, 91, 11, 144, 9, 253, 2, 61, 0, 86, 0, 73, 0, 73, 3, 137, 1, 38, 6, 191, 5, 71, 8, 23, 7, 23, 5, 252, 5, 82, 2, 145, 0, 27, 6, 201, 2, 104, 6, 206, 5, 215, 10, 184, 9, 149, 6, 32, 7, 68, 9, 163, 8, 144, 8, 221, 10, 158, 11, 192, 4, 85, 6, 245, 5, 228, 6, 161, 8, 26, 11, 97, 10, 135, 9, 211, 244, 150, 238, 9, 238, 45, 239, 118, 240, 80, 239, 64, 237, 245, 239, 37, 250, 77, 240, 106, 236, 43, 240, 105, 237, 62, 240, 50, 239, 52, 238, 65, 236, 146, 236, 122, 236, 153, 235, 71, 235, 246, 235, 116, 236, 49, 238, 42, 237, 37, 237, 2, 242, 4, 240, 170, 240, 223, 239, 239, 240, 232, 240, 154, 241, 133, 240, 167, 241, 135, 239, 201, 238, 131, 239, 17, 241, 78, 238, 14, 240, 86, 240, 61, 240, 4, 241, 134, 241, 199, 254, 141, 240, 77, 243, 19, 242, 143, 242, 22, 238, 105, 240, 142, 238, 11, 240, 6, 239, 68, 241, 22, 239, 227, 237, 159, 237, 207, 239, 64, 238, 146, 239, 133, 243, 31, 236, 25, 235, 237, 236, 124, 235, 128, 236, 87, 235, 44, 237, 143, 238, 95, 238, 144, 238, 78, 238, 165, 239, 70, 241, 112, 249, 162, 238, 110, 237, 21, 237, 236, 236, 60, 237, 87, 240, 80, 237, 234, 237, 121, 235, 24, 237, 150, 238, 111, 239, 19, 249, 119, 243, 8, 241, 60, 236, 76, 236, 34, 236, 167, 236, 250, 236, 52, 236, 47, 238, 23, 237, 80, 235, 93, 236, 129, 241, 49, 238, 183, 234, 87, 224, 161, 237, 225, 237, 213, 238, 72, 238, 161, 237, 110, 238, 155, 238, 12, 238, 88, 238, 185, 239, 173, 237, 209, 240, 80, 239, 94, 238, 19, 239, 239, 237, 163, 238, 152, 246, 112, 239, 208, 238, 214, 238, 87, 238, 51, 241, 122, 238, 65, 240, 212, 241, 130, 239, 164, 246, 209, 241, 132, 234, 129, 242, 199, 245, 206, 244, 109, 245, 72, 244, 161, 245, 110, 243, 213, 242, 60, 242, 28, 246, 21, 245, 86, 243, 13, 238, 131, 238, 5, 238, 131, 239, 26, 243, 238, 241, 71, 239, 75, 237, 232, 239, 169, 241, 104, 241, 226, 240, 114, 245, 30, 245, 104, 242, 135, 243, 218, 247, 138, 245, 217, 243, 35, 244, 155, 243, 11, 239, 179, 238, 127, 238, 105, 241, 45, 239, 163, 238, 229, 241, 58, 241, 30, 241, 156, 244, 1, 243, 118, 242, 64, 244, 217, 243, 76, 246, 20, 241, 242, 241, 30, 242, 167, 241, 200, 241, 1, 244, 208, 238, 104, 240, 5, 240, 234, 239, 34, 239, 121, 242, 207, 241, 214, 241, 4, 242, 191, 241, 7, 239, 73, 239, 32, 239, 252, 239, 195, 239, 92, 240, 102, 240, 199, 239, 113, 237, 92, 238, 50, 245, 167, 236, 199, 237, 191, 235, 170, 238, 112, 238, 120, 239, 106, 240, 134, 243, 22, 243, 193, 239, 76, 239, 118, 237, 160, 240, 162, 236, 173, 241, 142, 240, 124, 244, 195, 240, 55, 238, 227, 241, 141, 249, 103, 242, 212, 242, 0, 237, 217, 237, 169, 238, 198, 237, 202, 237, 22, 238, 204, 236, 55, 240, 71, 240, 74, 239, 234, 241, 242, 239, 15, 241, 251, 242, 88, 241, 36, 240, 13, 239, 182, 237, 188, 239, 122, 237, 24, 240, 228, 237, 186, 239, 45, 238, 174, 238, 241, 238, 163, 237, 226, 238, 197, 239, 96, 236, 10, 238, 68, 236, 4, 242, 36, 240, 196, 243, 202, 235, 99, 236, 243, 236, 202, 237, 206, 235, 193, 237, 22, 236, 74, 234, 100, 235, 215, 241, 194, 245, 119, 241, 12, 247, 23, 242, 199, 245, 50, 241, 240, 237, 16, 242, 159, 240, 105, 239, 180, 239, 176, 240, 93, 242, 42, 241, 179, 242, 9, 240, 152, 242, 59, 241, 30, 245, 98, 242, 113, 245, 234, 236, 168, 243, 69, 239, 107, 238, 131, 239, 80, 241, 182, 242, 115, 242, 93, 243, 41, 247, 210, 244, 155, 241, 228, 241, 251, 246, 32, 245, 253, 239, 134, 241, 141, 240, 243, 244, 19, 244, 235, 239, 6, 243, 132, 241, 93, 240, 39, 240, 51, 240, 172, 241, 133, 248, 63, 242, 194, 242, 225, 240, 55, 244, 73, 242, 136, 242, 227, 246, 25, 241, 55, 242, 214, 244, 49, 245, 9, 243, 181, 242, 24, 249, 250, 242, 191, 248, 92, 249, 143, 249, 106, 245, 85, 246, 104, 245, 166, 245, 167, 245, 61, 247, 171, 237, 4, 239, 126, 238, 249, 237, 45, 240, 134, 239, 85, 237, 154, 238, 87, 238, 166, 238, 108, 238, 65, 238, 162, 252, 173, 239, 171, 242, 125, 243, 151, 242, 128, 241, 128, 239, 87, 245, 217, 238, 249, 246, 233, 245, 69, 247, 69, 245, 66, 243, 171, 240, 2, 242, 90, 240, 132, 241, 141, 243, 200, 242, 0, 240, 175, 240, 195, 240, 230, 240, 141, 240, 193, 241, 186, 240, 157, 240, 29, 236, 42, 236, 9, 236, 25, 237, 133, 239, 223, 236, 24, 236, 139, 235, 250, 235, 52, 238, 158, 237, 67, 239, 112, 237, 152, 237, 217, 237, 95, 237, 91, 237, 37, 237, 4, 237, 169, 236, 133, 237, 134, 236, 125, 236, 108, 236, 107, 237, 32, 237, 96, 237, 145, 237, 16, 237, 191, 236, 72, 1, 234, 254, 89, 0, 23, 254, 57, 254, 87, 254, 176, 253, 155, 253, 103, 253, 108, 254, 111, 254, 45, 255, 129, 240, 51, 242, 241, 241, 180, 253, 36, 254, 98, 254, 238, 238, 110, 239, 153, 238, 120, 245, 74, 241, 110, 241, 41, 239, 204, 239, 152, 240, 189, 253, 77, 244, 106, 249, 122, 240, 145, 241, 36, 241, 159, 246, 128, 241, 92, 244, 110, 254, 78, 242, 245, 242, 179, 238, 128, 239, 210, 238, 63, 240, 111, 239, 208, 239, 126, 241, 166, 240, 157, 239, 145, 254, 149, 254, 203, 253, 43, 248, 64, 254, 4, 254, 180, 241, 152, 244, 203, 241, 41, 241, 226, 240, 219, 242, 135, 238, 60, 239, 199, 238, 35, 238, 203, 238, 204, 241, 145, 240, 149, 241, 93, 243, 251, 239, 28, 238, 189, 238, 136, 237, 228, 238, 176, 240, 21, 240, 172, 240, 129, 239, 81, 10, 46, 10, 163, 10, 153, 7, 209, 8, 149, 8, 147, 8, 79, 9, 109, 6, 212, 2, 16, 5, 118, 5, 60, 5, 10, 3, 154, 1, 85, 7, 218, 5, 200, 6, 137, 6, 208, 4, 156, 4, 226, 4, 63, 5, 246, 7, 30, 1, 153, 3, 170, 1, 98, 6, 197, 3, 170, 5, 9, 242, 8, 245, 25, 243, 183, 254, 235, 251, 205, 249, 63, 253, 250, 253, 100, 253, 52, 0, 126, 253, 224, 253, 252, 254, 152, 254, 55, 0, 37, 254, 33, 254, 159, 254, 134, 0, 114, 0, 98, 0, 111, 252, 79, 0, 8, 4, 166, 2, 85, 0, 254, 255, 173, 254, 101, 254, 164, 253, 219, 3, 201, 4, 45, 5, 70, 3, 42, 4, 80, 5, 111, 2, 152, 3, 24, 1, 78, 4, 68, 5, 39, 7, 118, 0, 208, 1, 127, 0, 201, 7, 49, 5, 212, 8, 55, 0, 67, 0, 61, 0, 85, 2, 196, 2, 151, 4, 65, 0, 81, 0, 85, 0, 133, 0, 56, 1, 127, 0, 115, 0, 45, 0, 163, 2, 123, 0, 129, 0, 56, 0, 63, 0, 55, 0, 55, 0, 64, 0, 96, 1, 121, 0, 92, 1, 138, 0, 118, 0, 81, 0, 64, 0, 110, 0, 90, 236, 104, 243, 228, 241, 101, 241, 15, 242, 243, 248, 170, 241, 96, 244, 118, 241, 57, 245, 19, 243, 83, 242, 237, 244, 173, 243, 218, 250, 32, 243, 251, 244, 70, 243, 17, 239, 217, 246, 209, 237, 239, 242, 140, 244, 70, 247, 78, 252, 52, 242, 184, 245, 104, 245, 10, 247, 230, 245, 156, 240, 123, 241, 124, 242, 225, 252, 131, 255, 168, 253, 179, 241, 68, 245, 189, 242, 47, 240, 46, 242, 252, 242, 237, 242, 23, 243, 154, 244, 153, 251, 37, 247, 171, 248, 107, 243, 162, 247, 0, 245, 236, 240, 218, 241, 37, 243, 24, 255, 171, 250, 142, 245, 16, 245, 155, 243, 28, 251, 57, 239, 53, 239, 215, 240, 119, 238, 195, 238, 59, 238, 233, 239, 96, 239, 62, 239, 93, 239, 214, 237, 64, 237, 235, 237, 71, 237, 168, 237, 139, 237, 81, 237, 218, 237, 120, 240, 147, 239, 117, 239, 89, 239, 127, 239, 169, 239, 7, 238, 210, 238, 16, 238, 84, 238, 44, 238, 210, 238, 101, 240, 60, 254, 97, 248, 25, 244, 70, 241, 190, 238, 168, 237, 206, 237, 206, 238, 165, 247, 100, 236, 27, 251, 66, 240, 188, 237, 16, 238, 29, 248, 122, 237, 125, 242, 8, 1, 90, 3, 201, 3, 255, 255, 116, 253, 0, 0, 207, 4, 49, 0, 114, 5, 203, 7, 61, 7, 9, 5, 87, 4, 92, 255, 192, 255, 13, 0, 96, 4, 235, 0, 133, 2, 36, 0, 46, 0, 56, 254, 179, 241, 58, 241, 187, 240, 234, 243, 151, 249, 232, 241, 56, 242, 224, 243, 234, 241, 29, 243, 203, 240, 245, 240, 111, 254, 18, 254, 45, 254, 105, 254, 170, 252, 63, 254, 162, 247, 237, 242, 125, 245, 46, 248, 32, 248, 94, 253, 61, 1, 121, 248, 85, 255, 123, 0, 118, 3, 68, 254, 50, 0, 36, 0, 244, 1, 150, 254, 13, 247, 159, 243, 168, 254, 74, 251, 153, 252, 208, 253, 132, 254, 54, 1, 25, 254, 249, 1, 158, 253, 51, 252, 109, 254, 13, 0, 213, 4, 150, 243, 253, 253, 161, 248, 217, 244, 180, 247, 217, 4, 137, 5, 22, 7, 38, 0, 0, 0, 99, 253, 197, 253, 88, 255, 128, 234, 251, 238, 11, 235, 188, 234, 204, 234, 163, 235, 225, 235, 45, 235, 137, 235, 82, 235, 20, 237, 191, 237, 118, 235, 189, 235, 212, 234, 190, 235, 178, 235, 112, 235, 60, 235, 208, 234, 174, 235, 229, 234, 13, 238, 95, 236, 109, 235, 101, 235, 241, 234, 110, 235, 177, 236, 251, 238, 16, 235, 14, 237, 5, 236, 86, 235, 224, 235, 57, 235, 174, 236, 10, 235, 36, 234, 207, 234, 33, 236, 3, 234, 98, 236, 131, 235, 193, 235, 74, 235, 15, 236, 137, 235, 41, 0, 165, 3, 162, 242, 232, 247, 112, 252, 238, 247, 103, 243, 4, 236, 99, 236, 42, 237, 160, 236, 124, 236, 127, 237, 65, 239, 108, 243, 28, 239, 158, 243, 54, 241, 107, 238, 175, 240, 217, 236, 59, 238, 228, 237, 238, 239, 62, 238, 156, 239, 235, 235, 96, 237, 54, 237, 174, 235, 62, 235, 21, 238, 235, 236, 24, 236, 23, 236, 146, 236, 233, 235, 205, 235, 211, 235, 13, 236, 130, 236, 68, 235, 33, 236, 3, 235, 123, 243, 141, 241, 190, 242, 196, 247, 233, 242, 135, 238, 97, 239, 180, 244, 252, 248, 221, 239, 199, 244, 230, 244, 113, 239, 22, 240, 28, 227, 130, 239, 137, 238, 238, 240, 97, 229, 67, 243, 150, 248, 206, 246, 27, 240, 117, 238, 78, 237, 253, 237, 150, 238, 0, 238, 199, 237, 86, 236, 25, 237, 144, 236, 172, 236, 139, 236, 129, 236, 83, 237, 239, 236, 22, 237, 7, 237, 165, 236, 102, 237, 1, 237, 168, 236, 202, 236, 203, 236, 59, 237, 4, 237, 122, 237, 143, 237, 199, 238, 190, 238, 73, 238, 140, 235, 223, 235, 49, 236, 148, 241, 51, 241, 158, 236, 131, 237, 89, 240, 121, 241, 46, 241, 83, 236, 12, 236, 69, 236, 153, 235, 11, 236, 218, 235, 105, 235, 98, 235, 206, 235, 148, 234, 113, 236, 214, 237, 18, 238, 96, 236, 86, 238, 140, 239, 123, 238, 105, 236, 80, 237, 107, 236, 114, 236, 139, 236, 79, 239, 11, 246, 46, 246, 193, 240, 51, 237, 93, 236, 95, 236, 128, 236, 75, 10, 163, 10, 142, 10, 186, 9, 116, 9, 135, 11, 123, 10, 165, 9, 252, 9, 150, 9, 112, 10, 113, 10, 108, 6, 183, 4, 197, 8, 121, 7, 214, 7, 150, 7, 190, 8, 66, 10, 190, 9, 208, 9, 162, 8, 178, 11, 131, 13, 49, 13, 36, 12, 97, 13, 51, 14, 128, 11, 95, 12, 165, 11, 150, 12, 133, 12, 182, 11, 30, 13, 27, 13, 142, 13, 24, 13, 156, 12, 20, 14, 143, 13, 19, 12, 218, 12, 189, 12, 201, 13, 72, 13, 226, 13, 57, 245, 110, 240, 60, 254, 38, 254, 44, 255, 41, 0, 54, 0, 180, 4, 132, 3, 190, 6, 39, 5, 157, 5, 76, 3, 2, 5, 253, 10, 244, 9, 153, 10, 216, 2, 127, 8, 186, 2, 111, 8, 207, 8, 189, 7, 253, 4, 167, 6, 235, 1, 94, 11, 36, 11, 88, 11, 38, 10, 49, 9, 126, 10, 209, 8, 123, 9, 148, 10, 173, 10, 111, 5, 210, 7, 37, 7, 111, 6, 106, 7, 233, 9, 226, 8, 249, 8, 14, 235, 36, 235, 84, 235, 35, 235, 254, 234, 153, 236, 82, 236, 102, 236, 119, 236, 93, 238, 217, 235, 131, 235, 160, 238, 105, 239, 75, 237, 147, 240, 42, 243, 117, 241, 120, 244, 153, 235, 186, 236, 33, 235, 35, 240, 3, 0, 107, 240, 45, 239, 139, 238, 153, 9, 102, 7, 3, 1, 224, 4, 133, 0, 235, 3, 70, 0, 15, 237, 205, 236, 17, 237, 74, 237, 137, 241, 41, 239, 178, 246, 212, 254, 46, 249, 227, 238, 91, 4, 60, 0, 90, 2, 228, 6, 159, 10, 13, 241, 17, 246, 49, 0, 98, 251, 16, 246, 226, 245, 165, 255, 215, 11, 240, 9, 89, 12, 70, 12, 96, 4, 88, 10, 62, 4, 250, 1, 156, 2, 69, 7, 182, 236, 138, 248, 1, 239, 136, 237, 213, 237, 207, 5, 62, 0, 207, 2, 176, 0, 1, 0, 241, 239, 89, 238, 52, 240, 50, 241, 173, 246, 47, 245, 88, 245, 41, 239, 176, 238, 81, 238, 226, 239, 74, 239, 235, 238, 162, 238, 146, 238, 79, 254, 13, 245, 114, 246, 177, 244, 225, 245, 246, 242, 39, 240, 160, 237, 254, 237, 207, 238, 140, 238, 136, 238, 165, 238, 185, 238, 28, 239, 29, 240, 189, 239, 216, 240, 80, 239, 197, 13, 28, 13, 90, 11, 101, 12, 78, 12, 31, 12, 89, 11, 198, 5, 152, 8, 24, 8, 151, 7, 109, 8, 62, 6, 130, 10, 163, 9, 28, 10, 21, 6, 62, 255, 2, 10, 65, 8, 235, 4, 240, 6, 53, 8, 32, 10, 58, 9, 185, 10, 240, 238, 65, 239, 54, 239, 39, 239, 217, 238, 123, 238, 88, 241, 136, 239, 52, 241, 70, 239, 253, 238, 180, 238, 177, 241, 127, 239, 208, 240, 81, 239, 57, 239, 199, 239, 236, 3, 83, 254, 86, 252, 249, 244, 70, 248, 40, 249, 187, 244, 171, 245, 177, 242, 219, 239, 253, 240, 108, 241, 60, 253, 64, 0, 35, 0, 241, 255, 59, 254, 28, 2, 7, 250, 64, 253, 248, 3, 169, 3, 105, 239, 139, 251, 100, 240, 210, 240, 0, 241, 217, 254, 168, 250, 42, 255, 195, 11, 233, 11, 94, 11, 201, 11, 92, 11, 29, 12, 30, 12, 252, 8, 142, 9, 158, 8, 39, 11, 130, 10, 188, 10, 17, 10, 67, 10, 213, 10, 39, 13, 165, 13, 106, 12, 214, 12, 253, 11, 119, 12, 237, 11, 124, 11, 141, 11, 251, 11, 20, 9, 148, 9, 11, 9, 189, 10, 45, 10, 136, 10, 162, 9, 235, 9, 235, 9, 135, 12, 102, 12, 173, 12, 3, 11, 195, 11, 187, 11, 172, 11, 182, 11, 76, 11, 150, 8, 77, 9, 209, 8, 219, 9, 165, 9, 162, 9, 53, 10, 201, 9, 83, 10, 204, 10, 151, 10, 82, 10, 130, 14, 48, 14, 187, 14, 164, 14, 148, 13, 54, 14, 210, 13, 38, 14, 86, 14, 168, 13, 23, 14, 76, 13, 174, 14, 206, 14, 109, 12, 200, 12, 164, 12, 131, 13, 14, 13, 193, 12, 244, 12, 49, 13, 128, 13, 107, 14, 226, 13, 197, 13, 132, 9, 23, 11, 80, 10, 80, 10, 254, 10, 99, 12, 159, 12, 126, 12, 18, 12, 181, 11, 52, 13, 235, 11, 142, 12, 26, 13, 220, 12, 125, 11, 51, 12, 197, 11, 26, 243, 245, 246, 197, 240, 23, 243, 163, 244, 183, 244, 60, 245, 154, 242, 48, 243, 55, 238, 104, 240, 197, 238, 200, 238, 87, 240, 133, 238, 201, 241, 79, 239, 236, 241, 254, 239, 201, 240, 47, 240, 108, 242, 122, 241, 36, 242, 147, 239, 212, 239, 157, 239, 131, 242, 26, 241, 144, 241, 33, 239, 228, 238, 177, 238, 115, 239, 86, 239, 178, 239, 67, 238, 135, 238, 1, 238, 145, 253, 7, 250, 118, 253, 194, 238, 53, 240, 250, 238, 92, 241, 142, 240, 144, 239, 182, 238, 30, 238, 68, 238, 10, 238, 192, 237, 178, 237, 141, 238, 70, 238, 96, 238, 13, 239, 120, 238, 148, 238, 58, 7, 252, 6, 65, 8, 241, 2, 218, 4, 34, 2, 19, 9, 14, 7, 176, 7, 7, 241, 150, 242, 165, 241, 248, 250, 187, 244, 221, 242, 242, 254, 181, 247, 0, 0, 245, 5, 148, 4, 0, 0, 209, 7, 239, 6, 74, 9, 173, 251, 53, 1, 85, 255, 34, 2, 136, 255, 38, 5, 156, 238, 129, 239, 205, 238, 116, 238, 61, 239, 13, 255, 67, 242, 239, 244, 70, 242, 252, 239, 68, 240, 41, 239, 30, 240, 218, 240, 169, 240, 131, 239, 53, 241, 190, 239, 174, 13, 171, 12, 64, 13, 233, 12, 239, 11, 86, 12, 41, 12, 70, 11, 218, 11, 81, 11, 27, 12, 70, 12, 52, 9, 6, 7, 66, 11, 69, 10, 155, 9, 45, 10, 165, 10, 194, 11, 12, 11, 79, 11, 9, 9, 26, 10, 79, 9, 234, 9, 171, 10, 17, 5, 193, 7, 164, 10, 90, 9, 179, 9, 194, 9, 184, 9, 119, 12, 141, 12, 179, 11, 35, 12, 244, 11, 74, 12, 214, 11, 83, 10, 82, 11, 53, 11, 142, 239, 160, 242, 43, 240, 60, 240, 73, 241, 232, 2, 194, 0, 187, 253, 144, 254, 30, 2, 74, 253, 22, 246, 66, 253, 51, 252, 74, 243, 89, 245, 167, 2, 203, 255, 130, 254, 249, 243, 115, 245, 75, 243, 53, 12, 14, 11, 175, 11, 104, 11, 150, 10, 146, 5, 219, 6, 244, 6, 143, 8, 35, 10, 2, 6, 131, 9, 8, 8, 255, 5, 39, 6, 227, 9, 88, 8, 147, 9, 131, 236, 130, 237, 142, 237, 129, 236, 91, 237, 43, 237, 252, 236, 138, 236, 117, 235, 63, 237, 85, 236, 195, 235, 118, 236, 231, 236, 128, 235, 69, 236, 116, 237, 35, 236, 151, 237, 173, 237, 202, 236, 17, 237, 107, 236, 213, 236, 58, 236, 38, 237, 224, 236, 237, 235, 3, 237, 248, 235, 205, 236, 163, 236, 172, 235, 173, 235, 9, 236, 139, 237, 2, 237, 144, 237, 14, 236, 108, 236, 172, 236, 178, 236, 29, 236, 142, 235, 36, 237, 11, 237, 232, 235, 228, 235, 232, 235, 224, 235, 245, 235, 196, 235, 230, 235, 198, 235, 196, 235, 213, 235, 109, 254, 201, 3, 203, 244, 202, 254, 15, 0, 217, 254, 187, 251, 118, 237, 49, 238, 105, 238, 129, 238, 185, 237, 205, 238, 200, 240, 106, 239, 88, 239, 12, 238, 185, 240, 96, 240, 122, 241, 203, 237, 191, 238, 81, 238, 69, 239, 51, 238, 166, 239, 12, 236, 28, 236, 12, 236, 125, 236, 57, 236, 138, 237, 65, 237, 18, 237, 40, 237, 164, 236, 110, 237, 137, 236, 232, 236, 104, 237, 108, 237, 174, 236, 25, 237, 193, 236, 47, 242, 10, 244, 227, 241, 17, 245, 205, 244, 113, 245, 187, 242, 204, 245, 141, 243, 183, 241, 255, 241, 248, 241, 16, 242, 68, 242, 15, 241, 150, 244, 203, 242, 206, 243, 20, 243, 49, 241, 121, 241, 164, 241, 26, 242, 180, 243, 238, 240, 136, 241, 87, 242, 41, 243, 184, 242, 75, 243, 61, 239, 34, 239, 73, 239, 7, 239, 220, 238, 2, 239, 89, 239, 253, 238, 192, 239, 245, 237, 182, 237, 22, 238, 109, 240, 4, 240, 210, 239, 142, 238, 233, 238, 195, 238, 122, 239, 213, 239, 202, 240, 50, 241, 172, 239, 169, 240, 21, 241, 163, 241, 148, 240, 141, 239, 234, 239, 42, 239, 97, 238, 156, 237, 27, 238, 100, 238, 145, 238, 21, 239, 137, 235, 201, 235, 205, 237, 34, 242, 67, 241, 173, 242, 76, 238, 205, 239, 220, 238, 151, 241, 27, 239, 230, 239, 125, 237, 127, 237, 187, 237, 136, 237, 63, 237, 174, 236, 50, 237, 19, 237, 103, 236, 137, 239, 12, 238, 100, 238, 1, 241, 134, 239, 141, 241, 18, 240, 236, 239, 122, 238, 175, 240, 8, 237, 90, 238, 147, 238, 113, 240, 253, 241, 62, 240, 178, 239, 107, 238, 92, 238, 253, 237, 142, 239, 80, 11, 116, 11, 60, 10, 48, 10, 17, 7, 242, 9, 108, 10, 207, 7, 179, 7, 15, 5, 28, 7, 110, 5, 49, 8, 129, 8, 49, 1, 153, 1, 99, 1, 145, 1, 143, 1, 148, 0, 246, 2, 202, 1, 233, 2, 71, 9, 81, 4, 102, 4, 113, 3, 225, 2, 148, 3, 247, 2, 60, 0, 132, 4, 245, 5, 138, 6, 0, 5, 109, 4, 140, 5, 6, 5, 8, 6, 216, 0, 38, 4, 205, 3, 165, 8, 81, 8, 127, 6, 153, 7, 166, 7, 235, 7, 213, 6, 13, 5, 124, 5, 214, 5, 176, 239, 71, 240, 162, 239, 156, 1, 225, 247, 226, 249, 31, 243, 56, 242, 118, 253, 66, 1, 136, 2, 86, 0, 147, 5, 44, 3, 181, 3, 69, 1, 181, 3, 24, 2, 105, 2, 130, 7, 179, 7, 84, 2, 210, 4, 138, 255, 100, 7, 175, 8, 176, 7, 44, 6, 64, 7, 31, 5, 96, 8, 211, 6, 124, 7, 7, 7, 233, 4, 228, 7, 43, 6, 15, 7, 237, 6, 253, 6, 213, 1, 181, 3, 237, 2, 83, 3, 234, 4, 63, 6, 158, 5, 76, 5, 116, 237, 78, 236, 188, 236, 92, 236, 95, 236, 48, 238, 180, 237, 202, 237, 185, 237, 198, 238, 224, 236, 116, 236, 77, 237, 225, 238, 135, 236, 254, 236, 183, 238, 121, 237, 154, 237, 180, 236, 191, 236, 125, 236, 63, 239, 162, 241, 189, 239, 88, 239, 57, 239, 52, 0, 52, 0, 249, 242, 17, 246, 69, 244, 4, 254, 159, 245, 17, 239, 46, 239, 164, 238, 48, 239, 157, 241, 90, 241, 173, 240, 74, 241, 213, 240, 69, 239, 44, 2, 239, 255, 44, 0, 104, 1, 111, 254, 72, 240, 165, 240, 68, 254, 101, 245, 12, 244, 40, 241, 229, 253, 61, 0, 74, 0, 0, 0, 49, 2, 28, 254, 242, 252, 42, 254, 211, 253, 95, 253, 66, 253, 81, 239, 190, 242, 24, 241, 243, 239, 79, 238, 72, 254, 89, 247, 189, 252, 20, 247, 65, 245, 44, 239, 207, 239, 43, 240, 85, 241, 80, 243, 146, 242, 25, 245, 159, 248, 83, 244, 182, 243, 39, 252, 22, 247, 184, 243, 125, 245, 3, 229, 239, 241, 54, 229, 7, 1, 0, 255, 107, 0, 3, 250, 122, 250, 185, 255, 94, 251, 239, 245, 148, 246, 149, 234, 148, 235, 28, 237, 115, 232, 172, 234, 39, 234, 20, 242, 5, 241, 22, 241, 196, 245, 91, 245, 73, 235, 255, 0, 139, 255, 106, 251, 128, 0, 225, 2, 202, 255, 73, 252, 119, 255, 230, 255, 52, 254, 253, 253, 9, 250, 156, 245, 198, 254, 4, 246, 40, 253, 158, 254, 231, 253, 109, 255, 225, 255, 79, 1, 59, 2, 191, 255, 119, 254, 209, 0, 146, 255, 10, 1, 150, 254, 172, 251, 207, 5, 83, 237, 110, 240, 22, 236, 238, 243, 130, 247, 236, 238, 113, 238, 237, 245, 214, 247, 29, 236, 145, 236, 6, 236, 143, 243, 183, 240, 10, 239, 50, 238, 7, 238, 181, 239, 95, 250, 218, 254, 192, 254, 122, 252, 123, 255, 31, 249, 74, 247, 170, 253, 8, 245, 142, 245, 186, 244, 210, 249, 237, 2, 30, 248, 133, 0, 255, 0, 55, 245, 201, 253, 249, 245, 181, 245, 97, 246, 12, 244, 209, 239, 80, 242, 194, 240, 164, 240, 54, 242, 203, 243, 24, 245, 203, 242, 60, 241, 35, 240, 201, 239, 46, 239, 15, 240, 214, 240, 182, 241, 170, 239, 212, 239, 133, 235, 33, 241, 177, 241, 142, 237, 197, 238, 13, 240, 215, 240, 102, 240, 61, 240, 189, 239, 24, 239, 199, 237, 0, 239, 14, 239, 86, 239, 57, 242, 212, 238, 236, 237, 151, 240, 202, 239, 161, 239, 211, 236, 50, 236, 197, 235, 220, 235, 40, 236, 224, 235, 41, 235, 75, 235, 157, 234, 192, 253, 157, 253, 27, 253, 41, 251, 207, 252, 163, 253, 36, 236, 54, 241, 71, 235, 235, 235, 85, 235, 61, 239, 128, 234, 209, 234, 250, 235, 76, 251, 146, 238, 202, 243, 159, 234, 215, 235, 240, 234, 49, 239, 35, 1, 195, 3, 247, 236, 167, 249, 229, 238, 224, 255, 165, 255, 154, 255, 233, 238, 28, 239, 125, 237, 208, 242, 241, 239, 122, 249, 12, 238, 21, 243, 92, 239, 21, 254, 152, 253, 228, 253, 126, 253, 48, 253, 202, 251, 85, 254, 217, 253, 102, 255, 117, 249, 42, 246, 101, 255, 161, 236, 153, 251, 106, 247, 58, 237, 191, 239, 25, 255, 145, 253, 127, 253, 215, 254, 77, 252, 245, 240, 51, 243, 157, 251, 254, 242, 220, 244, 183, 251, 220, 238, 61, 238, 53, 239, 111, 237, 78, 241, 44, 238, 158, 237, 72, 239, 141, 242, 0, 241, 138, 241, 16, 236, 136, 236, 198, 235, 129, 239, 73, 239, 18, 238, 131, 238, 118, 237, 130, 236, 159, 239, 165, 239, 82, 239, 157, 240, 249, 239, 130, 240, 25, 239, 53, 239, 8, 238, 97, 239, 201, 239, 241, 240, 125, 235, 166, 234, 192, 234, 71, 235, 198, 234, 219, 234, 20, 235, 218, 234, 121, 236, 75, 236, 215, 235, 153, 235, 148, 235, 164, 235, 152, 235, 148, 235, 150, 235, 103, 235, 245, 234, 117, 237, 236, 235, 110, 237, 118, 237, 47, 236, 65, 236, 57, 236, 114, 235, 36, 236, 159, 235, 175, 236, 212, 237, 116, 236, 95, 236, 94, 238, 216, 236, 7, 236, 0, 236, 94, 235, 55, 236, 178, 238, 109, 237, 251, 237, 186, 236, 99, 237, 233, 237, 142, 237, 130, 237, 182, 237, 107, 235, 244, 234, 102, 235, 158, 235, 167, 235, 3, 235, 255, 235, 134, 235, 180, 236, 167, 236, 34, 237, 151, 236, 70, 238, 198, 236, 46, 237, 22, 237, 64, 238, 23, 236, 236, 236, 48, 235, 103, 235, 166, 235, 248, 236, 108, 236, 174, 239, 241, 236, 240, 236, 18, 238, 7, 236, 218, 236, 166, 4, 171, 251, 202, 1, 249, 255, 75, 250, 194, 253, 19, 254, 92, 251, 76, 253, 132, 252, 72, 253, 166, 250, 31, 246, 46, 246, 229, 250, 126, 250, 75, 251, 247, 247, 96, 250, 121, 250, 178, 250, 164, 249, 0, 237, 92, 235, 178, 235, 134, 235, 0, 236, 226, 234, 151, 234, 243, 235, 177, 234, 192, 236, 138, 234, 178, 234, 10, 239, 11, 253, 46, 236, 139, 236, 165, 236, 174, 236, 153, 236, 250, 234, 251, 235, 198, 235, 100, 235, 140, 237, 37, 236, 119, 235, 152, 235, 48, 245, 170, 239, 206, 235, 30, 238, 253, 237, 34, 240, 216, 237, 205, 234, 203, 234, 3, 236, 20, 235, 33, 236, 59, 235, 176, 235, 45, 237, 103, 235, 226, 235, 31, 250, 41, 238, 44, 241, 119, 250, 79, 251, 60, 237, 189, 237, 115, 250, 83, 241, 125, 238, 107, 242, 8, 253, 252, 251, 97, 246, 129, 237, 13, 242, 52, 246, 189, 253, 48, 12, 229, 8, 78, 10, 191, 11, 95, 10, 64, 0, 78, 0, 70, 0, 66, 0, 55, 0, 114, 0, 101, 0, 73, 6, 152, 6, 141, 9, 183, 8, 52, 0, 81, 6, 56, 0, 50, 9, 61, 0, 214, 10, 3, 240, 242, 239, 64, 241, 173, 240, 88, 240, 62, 240, 243, 244, 240, 253, 122, 249, 166, 247, 97, 254, 206, 253, 37, 254, 7, 242, 197, 245, 163, 241, 84, 0, 89, 0, 166, 251, 246, 1, 45, 0, 58, 0, 171, 253, 167, 242, 34, 254, 14, 250, 69, 9, 160, 8, 15, 9, 248, 8, 153, 8, 51, 8, 46, 6, 3, 5, 78, 8, 109, 6, 34, 5, 70, 0, 202, 8, 110, 9, 65, 254, 248, 253, 71, 254, 29, 254, 98, 254, 157, 253, 18, 253, 95, 253, 185, 253, 65, 8, 148, 3, 154, 5, 70, 0, 53, 0, 64, 0, 51, 0, 51, 0, 184, 254, 47, 0, 128, 253, 145, 253, 206, 254, 63, 0, 54, 0, 51, 0, 48, 0, 54, 0, 50, 0, 50, 0, 51, 0, 199, 241, 157, 242, 79, 242, 28, 242, 85, 244, 48, 239, 223, 240, 177, 241, 101, 241, 36, 241, 200, 240, 95, 241, 89, 243, 10, 243, 120, 245, 115, 244, 233, 244, 26, 245, 225, 243, 102, 242, 37, 243, 212, 243, 0, 239, 187, 237, 23, 242, 11, 240, 220, 241, 169, 235, 171, 236, 6, 245, 147, 245, 242, 244, 164, 242, 71, 245, 36, 245, 70, 242, 39, 244, 234, 241, 168, 237, 230, 238, 115, 237, 134, 239, 132, 240, 50, 239, 106, 238, 115, 242, 109, 241, 201, 238, 4, 239, 65, 239, 209, 238, 216, 238, 23, 240, 33, 239, 55, 239, 236, 242, 138, 240, 128, 238, 163, 241, 40, 242, 144, 239, 17, 240, 72, 242, 91, 241, 11, 243, 246, 239, 129, 240, 246, 241, 15, 242, 138, 241, 135, 241, 247, 240, 202, 241, 129, 239, 215, 238, 84, 241, 180, 240, 99, 241, 193, 241, 27, 244, 106, 242, 188, 242, 114, 245, 221, 244, 173, 243, 21, 244, 67, 246, 227, 243, 182, 243, 19, 244, 91, 245, 220, 244, 84, 241, 235, 243, 224, 242, 186, 242, 51, 242, 207, 241, 42, 242, 247, 244, 193, 246, 243, 242, 22, 245, 87, 245, 209, 239, 223, 239, 87, 241, 233, 240, 146, 245, 185, 238, 234, 243, 241, 244, 253, 242, 2, 242, 144, 7, 231, 5, 215, 255, 73, 4, 90, 5, 35, 3, 148, 254, 22, 244, 90, 247, 219, 245, 109, 244, 4, 245, 221, 243, 225, 246, 177, 245, 127, 248, 196, 242, 182, 241, 119, 252, 227, 247, 48, 243, 136, 243, 51, 244, 43, 254, 146, 246, 171, 252, 51, 237, 161, 238, 23, 236, 78, 236, 83, 237, 215, 236, 219, 237, 64, 235, 218, 236, 188, 237, 22, 238, 24, 244, 15, 236, 42, 236, 142, 244, 151, 243, 37, 243, 7, 241, 175, 247, 24, 240, 58, 247, 132, 247, 202, 242, 15, 237, 46, 239, 232, 237, 43, 243, 249, 245, 133, 244, 68, 243, 92, 245, 61, 243, 125, 247, 164, 244, 150, 244, 17, 245, 48, 241, 251, 244, 219, 241, 82, 242, 234, 244, 139, 246, 27, 246, 145, 246, 37, 239, 15, 240, 12, 239, 56, 239, 186, 239, 105, 242, 141, 242, 32, 240, 124, 240, 155, 239, 210, 240, 170, 242, 223, 243, 111, 253, 228, 239, 101, 240, 250, 241, 47, 241, 41, 240, 5, 240, 45, 240, 178, 239, 46, 239, 70, 240, 210, 239, 173, 240, 71, 238, 202, 243, 199, 242, 70, 244, 218, 244, 41, 241, 0, 246, 210, 239, 253, 245, 218, 243, 63, 243, 82, 244, 196, 242, 195, 244, 11, 243, 55, 243, 112, 244, 137, 242, 44, 8, 161, 6, 239, 8, 253, 7, 111, 2, 107, 254, 235, 254, 253, 253, 20, 254, 126, 247, 172, 254, 3, 10, 192, 249, 115, 245, 110, 251, 53, 246, 73, 244, 36, 245, 246, 245, 31, 6, 209, 1, 126, 0, 17, 242, 146, 241, 178, 240, 163, 239, 152, 240, 196, 242, 53, 242, 1, 248, 79, 242, 20, 242, 196, 249, 245, 240, 87, 251, 91, 247, 12, 244, 109, 246, 208, 241, 240, 242, 162, 240, 99, 239, 72, 239, 16, 240, 143, 239, 220, 239, 18, 239, 9, 239, 175, 239, 199, 240, 216, 239, 172, 239, 64, 239, 104, 239, 115, 240, 136, 240, 41, 241, 35, 240, 244, 240, 219, 238, 22, 242, 71, 240, 216, 244, 241, 240, 171, 239, 223, 238, 232, 237, 147, 238, 62, 238, 181, 238, 176, 238, 254, 237, 31, 238, 167, 241, 209, 241, 65, 241, 179, 239, 54, 241, 143, 241, 3, 239, 68, 239, 27, 238, 80, 239, 82, 238, 131, 238, 123, 238, 211, 238, 234, 238, 79, 239, 165, 238, 244, 238, 21, 238, 21, 242, 189, 242, 248, 241, 228, 243, 204, 243, 139, 244, 242, 242, 158, 243, 62, 244, 196, 241, 107, 242, 40, 242, 147, 240, 36, 242, 152, 242, 82, 243, 187, 242, 80, 243, 91, 243, 91, 242, 115, 242, 226, 242, 193, 243, 168, 242, 188, 241, 157, 241, 98, 242, 225, 242, 81, 243, 216, 243, 128, 238, 123, 240, 100, 239, 144, 239, 212, 240, 179, 241, 242, 240, 155, 241, 152, 241, 103, 240, 191, 241, 49, 240, 201, 241, 36, 242, 114, 240, 17, 240, 157, 240, 219, 240, 133, 240, 109, 245, 46, 244, 203, 244, 132, 244, 179, 245, 136, 244, 150, 244, 209, 244, 70, 244, 234, 242, 173, 243, 2, 242, 100, 242, 215, 244, 130, 245, 251, 238, 227, 240, 85, 240, 231, 240, 18, 241, 234, 240, 78, 241, 58, 243, 216, 242, 179, 243, 121, 239, 196, 239, 85, 238, 124, 240, 65, 240, 107, 238, 10, 238, 251, 237, 70, 239, 18, 239, 59, 239, 70, 239, 96, 242, 126, 242, 144, 242, 14, 241, 170, 241, 74, 240, 39, 242, 22, 242, 34, 243, 27, 240, 105, 240, 176, 239, 191, 242, 224, 241, 217, 241, 218, 240, 212, 240, 149, 239, 103, 238, 55, 238, 181, 237, 18, 238, 169, 237, 196, 237, 137, 237, 237, 238, 230, 237, 117, 238, 47, 238, 50, 239, 200, 237, 199, 237, 56, 239, 213, 237, 148, 238, 175, 237, 203, 237, 111, 238, 127, 239, 167, 237, 221, 238, 73, 238, 173, 237, 179, 237, 208, 243, 112, 242, 81, 243, 188, 242, 110, 242, 193, 240, 221, 239, 87, 240, 144, 241, 51, 243, 21, 240, 121, 243, 206, 239, 86, 239, 218, 239, 193, 241, 126, 240, 66, 242, 47, 235, 38, 236, 252, 235, 213, 245, 72, 237, 104, 237, 66, 239, 239, 237, 182, 241, 156, 235, 255, 237, 148, 233, 57, 234, 207, 237, 30, 234, 69, 235, 200, 234, 143, 245, 170, 238, 55, 235, 194, 235, 107, 249, 184, 246, 212, 255, 127, 235, 91, 235, 209, 233, 3, 247, 134, 235, 10, 245, 189, 241, 182, 240, 64, 242, 101, 240, 120, 240, 62, 240, 29, 241, 11, 240, 88, 239, 60, 239, 48, 239, 199, 239, 22, 239, 103, 239, 162, 238, 123, 240, 120, 240, 130, 239, 112, 237, 59, 238, 106, 238, 2, 239, 118, 238, 108, 238, 37, 238, 156, 238, 98, 238, 186, 239, 74, 239, 234, 239, 235, 237, 201, 237, 11, 238, 81, 238, 116, 237, 253, 236, 61, 238, 182, 237, 129, 237, 225, 234, 178, 235, 120, 236, 200, 237, 185, 236, 170, 236, 8, 236, 239, 235, 103, 236, 128, 239, 184, 238, 21, 239, 129, 238, 195, 239, 118, 238, 52, 238, 155, 238, 136, 238, 232, 236, 188, 236, 39, 238, 99, 239, 177, 238, 14, 238, 22, 238, 59, 238, 213, 238, 233, 237, 138, 238, 167, 238, 131, 238, 19, 238, 217, 238, 15, 237, 34, 237, 46, 237, 205, 238, 169, 237, 146, 238, 216, 237, 249, 237, 189, 238, 72, 238, 118, 238, 225, 240, 229, 239, 60, 240, 82, 240, 79, 241, 170, 239, 86, 239, 175, 241, 50, 242, 97, 238, 120, 240, 127, 242, 174, 240, 35, 239, 255, 238, 209, 239, 48, 239, 5, 238, 238, 239, 174, 237, 118, 238, 8, 238, 173, 239, 138, 239, 187, 239, 165, 240, 40, 241, 188, 239, 191, 239, 99, 241, 63, 240, 187, 239, 43, 239, 202, 241, 143, 239, 221, 240, 73, 239, 197, 238, 105, 237, 214, 240, 145, 241, 162, 241, 149, 240, 118, 241, 160, 240, 220, 242, 63, 241, 170, 243, 221, 242, 180, 243, 25, 244, 81, 240, 22, 240, 201, 240, 122, 240, 96, 240, 179, 239, 231, 240, 196, 243, 93, 241, 176, 242, 155, 240, 124, 241, 128, 241, 4, 242, 254, 241, 122, 240, 151, 241, 225, 240, 148, 240, 30, 241, 184, 242, 243, 240, 243, 242, 12, 243, 223, 241, 165, 238, 93, 241, 30, 242, 64, 244, 232, 242, 114, 240, 174, 240, 104, 239, 8, 244, 251, 244, 201, 248, 157, 252, 245, 244, 59, 247, 129, 249, 119, 248, 139, 240, 167, 248, 78, 242, 57, 0, 160, 251, 144, 247, 88, 253, 12, 0, 111, 255, 226, 247, 110, 240, 177, 241, 84, 242, 94, 250, 205, 243, 38, 246, 172, 242, 18, 243, 254, 247, 53, 242, 137, 242, 91, 242, 34, 244, 189, 243, 70, 244, 119, 249, 189, 251, 93, 255, 128, 247, 76, 243, 80, 243, 160, 246, 92, 246, 79, 246, 92, 250, 114, 244, 57, 242, 168, 239, 187, 242, 60, 248, 138, 246, 246, 244, 29, 243, 213, 247, 245, 243, 137, 252, 57, 252, 33, 241, 38, 251, 149, 252, 26, 250, 233, 250, 251, 251, 100, 250, 66, 248, 149, 252, 214, 252, 75, 252, 43, 251, 173, 249, 141, 250, 88, 249, 67, 247, 89, 246, 68, 251, 90, 251, 182, 253, 39, 254, 178, 253, 125, 244, 159, 240, 173, 241, 54, 242, 196, 244, 23, 245, 184, 248, 109, 248, 162, 249, 80, 248, 150, 249, 144, 254, 12, 251, 10, 249, 228, 248, 114, 248, 252, 246, 95, 248, 221, 255, 209, 255, 160, 251, 196, 0, 243, 255, 137, 1, 123, 254, 245, 255, 254, 255, 143, 1, 16, 2, 133, 2, 145, 0, 183, 0, 38, 1, 201, 0, 86, 1, 104, 0, 66, 245, 149, 254, 28, 248, 223, 255, 107, 255, 156, 254, 128, 254, 234, 254, 234, 255, 6, 0, 228, 255, 190, 255, 141, 3, 42, 3, 88, 1, 220, 0, 230, 3, 115, 255, 69, 1, 151, 2, 123, 1, 166, 237, 48, 238, 113, 239, 95, 4, 170, 255, 42, 0, 47, 237, 89, 253, 32, 0, 204, 0, 174, 0, 93, 1, 124, 1, 168, 0, 135, 0, 108, 1, 9, 1, 134, 2, 169, 2, 110, 3, 144, 1, 106, 251, 91, 250, 226, 250, 38, 251, 0, 249, 58, 249, 224, 247, 92, 249, 103, 243, 75, 252, 157, 247, 107, 248, 2, 238, 62, 246, 11, 238, 35, 246, 67, 246, 236, 245, 223, 242, 196, 238, 61, 238, 140, 242, 136, 243, 213, 244, 69, 237, 88, 239, 23, 238, 51, 244, 223, 242, 52, 242, 36, 1, 101, 2, 101, 1, 103, 1, 104, 1, 152, 237, 82, 237, 76, 238, 20, 245, 23, 1, 241, 241, 242, 255, 208, 241, 206, 239, 197, 239, 10, 0, 208, 244, 25, 0, 91, 238, 60, 241, 47, 239, 78, 240, 129, 238, 214, 240, 68, 241, 135, 238, 162, 237, 103, 237, 39, 237, 252, 236, 88, 238, 186, 238, 150, 241, 245, 244, 186, 239, 141, 245, 161, 249, 76, 247, 43, 237, 182, 239, 197, 237, 247, 238, 135, 239, 217, 246, 249, 238, 152, 237, 105, 237, 193, 237, 49, 242, 29, 237, 228, 237, 190, 238, 119, 237, 11, 237, 100, 235, 249, 237, 8, 238, 226, 236, 164, 236, 172, 236, 101, 236, 190, 237, 19, 237, 128, 236, 216, 237, 53, 236, 40, 236, 132, 235, 189, 236, 233, 236, 241, 2, 79, 0, 63, 4, 78, 244, 17, 246, 209, 255, 50, 238, 98, 239, 66, 237, 49, 244, 52, 244, 30, 243, 254, 237, 201, 239, 17, 239, 221, 0, 7, 242, 250, 239, 113, 238, 105, 238, 15, 238, 40, 237, 169, 243, 22, 238, 6, 238, 151, 237, 0, 237, 149, 238, 152, 237, 207, 237, 65, 238, 179, 235, 170, 237, 66, 237, 229, 238, 85, 238, 153, 237, 106, 238, 178, 237, 50, 237, 191, 240, 139, 239, 186, 237, 204, 238, 232, 237, 180, 236, 210, 236, 92, 238, 81, 250, 171, 249, 197, 249, 82, 250, 46, 251, 5, 243, 122, 241, 87, 250, 57, 248, 92, 240, 86, 246, 28, 247, 23, 252, 42, 251, 32, 251, 172, 250, 193, 250, 199, 252, 121, 250, 10, 251, 183, 250, 20, 251, 133, 255, 6, 237, 132, 237, 124, 241, 17, 237, 157, 237, 74, 237, 82, 237, 170, 238, 50, 238, 109, 238, 54, 238, 223, 236, 13, 237, 57, 236, 7, 237, 86, 237, 209, 236, 138, 238, 93, 237, 46, 237, 190, 236, 221, 238, 47, 245, 69, 238, 223, 239, 82, 237, 211, 249, 34, 249, 117, 237, 169, 246, 45, 245, 151, 250, 195, 247, 220, 236, 243, 236, 65, 237, 162, 236, 225, 237, 180, 236, 60, 237, 62, 243, 228, 236, 246, 237, 113, 243, 184, 237, 145, 237, 174, 244, 38, 244, 231, 235, 205, 236, 107, 236, 75, 237, 236, 237, 137, 250, 56, 247, 189, 246, 197, 243, 202, 238, 123, 236, 71, 236, 141, 237, 246, 255, 14, 0, 228, 252, 249, 3, 45, 0, 208, 255, 217, 255, 168, 255, 178, 238, 123, 250, 228, 247, 160, 252, 9, 0, 35, 247, 105, 248, 36, 1, 134, 249, 184, 253, 95, 248, 96, 245, 122, 241, 178, 235, 104, 236, 119, 239, 57, 245, 213, 236, 55, 252, 113, 0, 192, 255, 151, 242, 89, 233, 192, 233, 178, 233, 184, 247, 32, 235, 250, 245, 137, 234, 91, 234, 191, 236, 11, 255, 157, 255, 176, 255, 56, 252, 10, 252, 5, 0, 47, 254, 40, 253, 33, 248, 158, 3, 86, 252, 175, 248, 162, 237, 178, 250, 153, 240, 196, 244, 188, 255, 214, 251, 194, 241, 8, 249, 25, 239, 107, 255, 14, 255, 136, 255, 255, 255, 37, 254, 99, 251, 179, 255, 119, 255, 30, 255, 231, 242, 26, 237, 193, 238, 233, 251, 136, 248, 199, 255, 121, 229, 193, 255, 85, 249, 164, 255, 169, 255, 159, 255, 163, 255, 109, 255, 205, 255, 248, 246, 29, 255, 80, 245, 222, 251, 183, 249, 116, 253, 41, 237, 82, 243, 115, 252, 92, 249, 113, 241, 20, 253, 118, 4, 162, 249, 224, 255, 21, 253, 56, 240, 139, 240, 10, 241, 148, 238, 110, 0, 109, 244, 212, 2, 168, 240, 77, 236, 54, 244, 185, 233, 21, 1, 217, 255, 214, 255, 242, 251, 239, 253, 169, 255, 2, 2, 25, 2, 229, 1, 106, 1, 237, 1, 250, 1, 101, 1, 194, 1, 106, 1, 206, 255, 106, 0, 148, 0, 0, 0, 31, 0, 164, 255, 88, 1, 160, 0, 72, 1, 252, 0, 36, 1, 143, 0, 255, 1, 109, 2, 170, 2, 139, 1, 21, 2, 171, 1, 217, 1, 7, 2, 239, 1, 58, 1, 54, 1, 67, 1, 123, 1, 84, 1, 112, 1, 92, 1, 96, 1, 132, 1, 28, 2, 45, 2, 2, 2, 189, 1, 226, 1, 177, 1, 35, 2, 203, 1, 156, 1, 146, 1, 164, 1, 226, 1, 224, 234, 112, 237, 94, 233, 125, 252, 84, 247, 118, 250, 213, 253, 241, 248, 250, 254, 41, 0, 248, 255, 195, 255, 44, 0, 83, 0, 91, 1, 53, 251, 217, 255, 142, 255, 138, 0, 64, 0, 196, 0, 145, 255, 215, 255, 186, 255, 197, 0, 104, 0, 65, 0, 132, 255, 215, 255, 160, 255, 45, 2, 37, 2, 67, 2, 83, 2, 248, 1, 255, 0, 157, 1, 174, 1, 193, 1, 1, 2, 192, 0, 231, 1, 165, 1, 58, 2, 202, 2, 85, 2, 171, 2, 223, 1, 180, 250, 231, 255, 195, 255, 92, 2, 44, 4, 226, 255, 240, 1, 60, 2, 54, 2, 235, 255, 15, 0, 47, 0, 33, 0, 19, 0, 232, 255, 107, 0, 77, 0, 171, 0, 162, 1, 131, 0, 203, 1, 95, 1, 144, 0, 216, 0, 49, 0, 66, 0, 26, 0, 211, 0, 124, 0, 244, 0, 192, 255, 198, 255, 172, 255, 49, 0, 254, 255, 77, 0, 204, 255, 214, 255, 219, 255, 3, 1, 190, 0, 217, 0, 232, 255, 56, 0, 75, 0, 10, 1, 115, 0, 74, 0, 188, 255, 188, 255, 174, 255, 200, 255, 194, 255, 168, 255, 201, 255, 194, 255, 211, 255, 89, 0, 10, 0, 237, 255, 253, 1, 248, 2, 156, 2, 140, 2, 122, 2, 33, 2, 142, 2, 49, 2, 85, 2, 225, 0, 17, 1, 198, 0, 7, 1, 254, 0, 246, 0, 48, 1, 17, 1, 229, 1, 224, 0, 232, 0, 197, 0, 171, 1, 38, 1, 89, 1, 227, 0, 70, 1, 27, 1, 235, 1, 197, 1, 209, 1, 203, 255, 233, 255, 213, 255, 222, 255, 245, 255, 239, 0, 231, 0, 217, 0, 190, 0, 53, 0, 45, 1, 35, 0, 2, 1, 249, 0, 4, 1, 205, 0, 235, 0, 64, 0, 180, 237, 63, 254, 205, 249, 156, 248, 75, 252, 191, 0, 219, 0, 251, 255, 64, 0, 36, 0, 238, 255, 166, 255, 176, 255, 190, 255, 180, 254, 241, 254, 110, 0, 184, 255, 210, 255, 195, 255, 218, 255, 201, 255, 38, 2, 216, 1, 239, 1, 161, 1, 140, 1, 194, 0, 20, 1, 253, 1, 171, 1, 126, 1, 44, 1, 130, 1, 60, 1, 218, 0, 168, 1, 93, 1, 95, 1, 65, 1, 109, 1, 101, 1, 116, 1, 93, 1, 194, 255, 44, 0, 237, 255, 24, 0, 23, 0, 172, 255, 152, 255, 240, 255, 171, 255, 214, 255, 173, 255, 223, 255, 200, 0, 175, 0, 90, 1, 171, 0, 17, 0, 32, 1, 8, 1, 3, 0, 49, 0, 21, 0, 124, 0, 117, 1, 175, 0, 184, 0, 113, 1, 210, 0, 79, 0, 145, 0, 150, 1, 222, 0, 249, 255, 86, 1, 78, 1, 249, 0, 100, 0, 237, 1, 59, 1, 16, 2, 49, 239, 14, 238, 205, 238, 179, 242, 217, 241, 21, 244, 72, 249, 65, 239, 45, 242, 27, 238, 67, 247, 85, 240, 221, 243, 166, 242, 251, 241, 214, 240, 39, 239, 79, 241, 21, 240, 105, 241, 16, 239, 101, 240, 230, 2, 75, 1, 184, 255, 98, 0, 133, 0, 217, 255, 189, 255, 98, 236, 56, 236, 183, 235, 21, 241, 163, 236, 197, 236, 244, 254, 247, 240, 141, 255, 200, 0, 69, 247, 64, 0, 47, 2, 184, 239, 151, 0, 165, 243, 200, 255, 165, 255, 219, 255, 242, 236, 169, 235, 99, 238, 229, 237, 8, 236, 118, 236, 198, 236, 42, 242, 241, 239, 110, 238, 55, 239, 120, 239, 43, 240, 175, 238, 101, 236, 143, 236, 222, 235, 112, 236, 66, 236, 251, 235, 251, 237, 109, 237, 153, 237, 89, 238, 28, 238, 156, 237, 124, 243, 86, 237, 247, 237, 87, 237, 70, 238, 172, 236, 184, 238, 71, 238, 84, 238, 153, 237, 82, 241, 56, 239, 73, 240, 24, 240, 207, 239, 253, 237, 126, 237, 23, 239, 14, 0, 53, 2, 84, 1, 21, 1, 208, 0, 188, 0, 238, 0, 194, 0, 246, 0, 252, 0, 228, 0, 27, 1, 15, 2, 204, 1, 107, 1, 145, 1, 87, 1, 109, 1, 1, 1, 34, 1, 229, 0, 62, 1, 111, 2, 235, 1, 197, 0, 141, 1, 58, 1, 133, 1, 5, 1, 128, 0, 246, 255, 104, 0, 14, 0, 6, 0, 61, 0, 116, 0, 1, 0, 129, 0, 151, 0, 150, 0, 218, 0, 158, 0, 94, 0, 79, 0, 40, 0, 98, 0, 65, 0, 140, 0, 222, 0, 225, 0, 191, 0, 187, 0, 82, 0, 141, 0, 93, 0, 243, 0, 149, 0, 138, 0, 139, 0, 150, 0, 122, 0, 149, 0, 97, 0, 127, 0, 33, 0, 76, 0, 162, 0, 55, 0, 131, 0, 182, 0, 191, 0, 242, 0, 93, 0, 164, 0, 136, 0, 73, 0, 95, 0, 198, 0, 169, 0, 26, 0, 106, 0, 127, 0, 44, 0, 26, 0, 7, 1, 9, 1, 42, 1, 216, 0, 142, 0, 111, 0, 153, 0, 175, 0, 121, 236, 42, 253, 165, 237, 196, 246, 13, 1, 80, 240, 91, 0, 51, 1, 70, 1, 113, 1, 11, 1, 230, 255, 179, 1, 176, 1, 21, 1, 112, 1, 129, 1, 161, 1, 156, 1, 25, 0, 46, 1, 1, 1, 121, 237, 239, 236, 76, 236, 14, 236, 159, 235, 175, 236, 175, 236, 210, 238, 78, 234, 252, 235, 115, 234, 17, 235, 248, 236, 64, 233, 16, 234, 76, 236, 210, 241, 233, 235, 138, 236, 25, 236, 191, 235, 92, 233, 90, 234, 111, 236, 95, 234, 252, 236, 242, 1, 126, 2, 206, 1, 168, 1, 139, 1, 91, 1, 6, 1, 222, 1, 13, 2, 206, 0, 189, 1, 98, 1, 127, 1, 131, 1, 134, 255, 226, 255, 228, 252, 203, 0, 146, 0, 145, 0, 114, 0, 126, 0, 186, 0, 130, 1, 215, 0, 226, 0, 123, 238, 154, 241, 219, 238, 184, 255, 67, 1, 69, 252, 149, 0, 204, 255, 204, 251, 167, 254, 104, 1, 53, 1, 196, 1, 100, 1, 22, 1, 73, 0, 8, 1, 252, 0, 127, 0, 61, 0, 86, 0, 141, 0, 19, 2, 88, 2, 22, 1, 73, 0, 35, 0, 41, 0, 77, 0, 52, 0, 175, 236, 127, 235, 222, 0, 209, 255, 197, 255, 128, 255, 227, 255, 71, 0, 122, 0, 101, 0, 247, 1, 229, 0, 108, 1, 118, 1, 226, 0, 45, 250, 172, 255, 228, 255, 186, 255, 161, 255, 211, 255, 129, 0, 112, 0, 93, 0, 145, 0, 198, 0, 102, 0, 139, 0, 86, 0, 222, 0, 181, 0, 178, 0, 32, 236, 47, 235, 206, 236, 224, 235, 18, 236, 83, 235, 48, 234, 25, 234, 15, 234, 162, 234, 183, 235, 74, 235, 49, 234, 54, 238, 72, 235, 100, 234, 12, 234, 50, 234, 37, 234, 23, 235, 2, 234, 68, 235, 81, 0, 2, 0, 255, 0, 246, 255, 254, 255, 204, 249, 138, 236, 235, 247, 188, 252, 170, 255, 121, 234, 105, 255, 147, 236, 39, 234, 44, 235, 169, 255, 204, 245, 139, 255, 255, 239, 149, 239, 187, 239, 132, 238, 183, 238, 73, 241, 175, 240, 22, 239, 210, 239, 105, 240, 77, 240, 63, 239, 247, 238, 84, 239, 185, 237, 71, 237, 234, 239, 241, 238, 31, 239, 52, 238, 117, 239, 172, 238, 179, 242, 20, 243, 240, 243, 97, 243, 99, 243, 162, 243, 169, 244, 91, 241, 51, 243, 227, 242, 23, 243, 109, 242, 1, 243, 248, 243, 241, 242, 186, 243, 129, 242, 203, 241, 32, 244, 67, 243, 106, 242, 35, 242, 222, 243, 139, 244, 62, 244, 222, 245, 248, 242, 245, 242, 50, 243, 101, 242, 202, 241, 107, 242, 165, 241, 125, 239, 12, 240, 189, 240, 23, 240, 211, 239, 76, 241, 92, 242, 22, 242, 34, 242, 35, 242, 212, 241, 55, 241, 43, 241, 7, 241, 35, 242, 111, 241, 77, 242, 25, 241, 212, 241, 178, 241, 253, 242, 250, 241, 157, 242, 215, 240, 222, 241, 59, 241, 5, 241, 162, 242, 194, 241, 18, 239, 41, 240, 217, 239, 173, 239, 25, 240, 66, 241, 92, 240, 110, 239, 159, 234, 182, 235, 167, 235, 68, 235, 136, 235, 24, 235, 7, 235, 170, 248, 182, 235, 102, 238, 189, 234, 7, 235, 142, 236, 111, 236, 64, 235, 128, 236, 124, 236, 238, 234, 252, 235, 206, 234, 175, 237, 125, 233, 152, 233, 248, 235, 158, 234, 118, 237, 238, 239, 62, 239, 197, 238, 25, 239, 217, 238, 113, 239, 18, 241, 141, 238, 38, 239, 12, 240, 219, 238, 124, 239, 6, 238, 101, 238, 135, 238, 50, 240, 170, 239, 38, 240, 194, 247, 218, 246, 160, 249, 40, 243, 75, 250, 139, 246, 222, 237, 71, 239, 18, 239, 49, 239, 253, 238, 53, 239, 127, 241, 185, 241, 236, 239, 50, 240, 37, 241, 154, 239, 61, 240, 192, 236, 159, 237, 17, 238, 46, 238, 30, 237, 98, 238, 4, 239, 94, 240, 188, 239, 162, 239, 8, 240, 248, 239, 175, 240, 159, 238, 53, 239, 156, 239, 197, 238, 195, 238, 92, 238, 70, 242, 49, 238, 154, 238, 108, 239, 50, 234, 163, 238, 197, 237, 239, 238, 177, 238, 34, 238, 233, 237, 44, 233, 56, 237, 230, 236, 153, 236, 46, 239, 15, 237, 138, 237, 164, 239, 57, 240, 161, 240, 211, 239, 60, 241, 125, 240, 5, 240, 175, 240, 217, 238, 214, 241, 121, 240, 0, 241, 153, 239, 170, 239, 83, 243, 180, 244, 157, 243, 93, 241, 155, 244, 64, 244, 136, 244, 89, 243, 5, 243, 203, 239, 207, 239, 47, 242, 244, 242, 248, 243, 67, 245, 86, 244, 225, 244, 59, 243, 122, 243, 54, 242, 121, 242, 132, 242, 229, 248, 179, 242, 209, 241, 128, 244, 133, 243, 74, 244, 52, 239, 27, 240, 129, 241, 13, 242, 166, 243, 36, 243, 115, 254, 169, 245, 134, 247, 212, 245, 126, 244, 251, 245, 128, 241, 104, 241, 0, 244, 215, 239, 192, 240, 130, 245, 109, 243, 98, 241, 216, 240, 111, 239, 81, 242, 230, 241, 151, 242, 125, 241, 32, 244, 18, 254, 228, 240, 131, 240, 155, 241, 8, 241, 41, 240, 248, 239, 56, 241, 225, 240, 2, 242, 71, 242, 110, 242, 3, 241, 49, 241, 230, 244, 223, 242, 248, 242, 1, 243, 238, 241, 254, 245, 117, 241, 93, 242, 139, 248, 114, 242, 61, 244, 8, 244, 135, 243, 5, 243, 204, 245, 13, 244, 131, 244, 122, 241, 198, 241, 250, 240, 68, 242, 132, 242, 221, 240, 50, 241, 156, 242, 88, 241, 98, 242, 201, 240, 109, 241, 88, 244, 238, 244, 179, 243, 185, 244, 64, 244, 176, 244, 222, 243, 193, 241, 5, 243, 122, 242, 101, 240, 14, 240, 130, 240, 6, 240, 143, 240, 250, 241, 100, 241, 106, 241, 220, 241, 249, 241, 153, 240, 24, 240, 146, 240, 191, 241, 172, 240, 55, 240, 41, 241, 63, 240, 223, 240, 245, 240, 108, 241, 132, 240, 27, 243, 176, 242, 184, 242, 23, 243, 224, 244, 153, 243, 188, 242, 186, 244, 35, 243, 60, 244, 145, 242, 123, 242, 4, 243, 41, 242, 240, 244, 201, 243, 123, 245, 60, 243, 253, 244, 35, 243, 181, 242, 54, 245, 13, 242, 243, 242, 58, 242, 112, 242, 84, 243, 7, 242, 1, 245, 172, 244, 0, 242, 230, 240, 198, 243, 222, 243, 133, 245, 195, 244, 77, 240, 154, 243, 40, 244, 2, 244, 34, 251, 7, 0, 20, 247, 85, 254, 140, 246, 255, 4, 93, 8, 133, 0, 89, 0, 31, 1, 223, 255, 14, 0, 182, 0, 4, 0, 217, 1, 252, 255, 96, 252, 255, 254, 3, 0, 237, 255, 88, 255, 124, 248, 205, 255, 141, 247, 230, 255, 198, 0, 225, 255, 212, 255, 212, 255, 215, 255, 219, 255, 35, 0, 228, 255, 237, 255, 251, 255, 255, 255, 251, 255, 238, 255, 220, 255, 199, 255, 192, 255, 215, 255, 190, 255, 213, 255, 171, 0, 137, 0, 184, 0, 39, 0, 141, 0, 20, 0, 20, 0, 50, 0, 16, 0, 228, 255, 14, 0, 23, 0, 103, 233, 189, 233, 41, 230, 215, 235, 198, 234, 192, 234, 99, 233, 161, 252, 201, 254, 38, 252, 250, 255, 77, 253, 94, 248, 237, 238, 166, 254, 195, 254, 48, 0, 159, 244, 107, 243, 241, 249, 171, 255, 8, 1, 198, 255, 3, 239, 154, 242, 104, 243, 21, 0, 248, 255, 8, 0, 8, 0, 4, 0, 203, 255, 175, 255, 203, 255, 192, 255, 200, 255, 196, 254, 208, 255, 112, 254, 211, 254, 0, 0, 227, 255, 217, 255, 235, 255, 182, 240, 84, 238, 45, 238, 95, 237, 150, 237, 57, 237, 94, 238, 5, 238, 5, 238, 2, 236, 64, 236, 219, 235, 194, 236, 143, 236, 142, 236, 192, 236, 164, 236, 250, 238, 52, 235, 127, 239, 137, 234, 224, 237, 165, 238, 68, 238, 121, 237, 110, 238, 97, 237, 96, 237, 135, 237, 149, 237, 246, 234, 130, 234, 141, 235, 199, 237, 27, 233, 51, 238, 192, 235, 192, 235, 29, 241, 216, 235, 185, 234, 95, 235, 42, 234, 248, 233, 28, 235, 251, 235, 118, 235, 39, 236, 105, 236, 246, 234, 42, 235, 13, 236, 124, 237, 112, 237, 213, 234, 135, 236, 135, 235, 233, 236, 134, 234, 103, 235, 248, 255, 236, 255, 228, 255, 150, 0, 6, 0, 32, 0, 5, 0, 24, 0, 17, 0, 134, 254, 139, 249, 233, 255, 76, 251, 102, 249, 43, 248, 125, 1, 88, 3, 112, 0, 65, 247, 62, 255, 59, 237, 36, 1, 38, 253, 199, 2, 252, 243, 40, 248, 103, 252, 206, 0, 102, 1, 63, 0, 140, 235, 53, 235, 98, 236, 78, 236, 31, 235, 91, 234, 240, 233, 219, 233, 245, 235, 45, 236, 118, 234, 99, 236, 162, 241, 217, 233, 159, 235, 46, 235, 224, 236, 36, 236, 121, 234, 183, 234, 25, 247, 248, 237, 232, 234, 125, 233, 14, 233, 164, 250, 80, 252, 239, 236, 115, 241, 229, 235, 114, 253, 189, 252, 245, 233, 72, 236, 75, 235, 221, 236, 103, 244, 213, 233, 253, 239, 207, 242, 206, 243, 174, 243, 42, 239, 184, 240, 172, 233, 156, 233, 71, 245, 233, 235, 143, 235, 91, 249, 148, 249, 137, 234, 166, 233, 131, 236, 139, 236, 160, 234, 1, 236, 42, 234, 98, 234, 133, 237, 176, 251, 168, 250, 61, 250, 166, 251, 90, 248, 108, 251, 182, 244, 182, 243, 210, 237, 162, 248, 51, 232, 93, 232, 10, 233, 238, 232, 204, 232, 56, 233, 204, 232, 72, 232, 97, 232, 86, 239, 124, 237, 222, 247, 245, 233, 80, 234, 99, 234, 171, 233, 129, 234, 74, 234, 219, 233, 221, 232, 212, 233, 32, 233, 249, 232, 50, 232, 120, 233, 238, 233, 106, 233, 168, 233, 36, 233, 156, 233, 168, 237, 175, 243, 206, 244, 118, 236, 80, 236, 228, 234, 36, 234, 115, 234, 178, 233, 141, 238, 23, 236, 196, 240, 238, 240, 120, 235, 228, 234, 37, 236, 92, 236, 80, 236, 34, 0, 4, 0, 7, 0, 0, 0, 232, 255, 16, 237, 16, 249, 46, 2, 203, 255, 96, 245, 123, 0, 35, 0, 209, 255, 37, 1, 191, 255, 199, 255, 159, 1, 8, 0, 18, 1, 247, 255, 233, 255, 229, 255, 199, 235, 228, 234, 90, 235, 200, 237, 153, 246, 72, 234, 162, 233, 176, 239, 157, 232, 128, 234, 193, 233, 218, 232, 88, 234, 81, 234, 219, 235, 101, 235, 142, 238, 71, 235, 120, 244, 54, 234, 29, 239, 220, 237, 15, 234, 144, 236, 239, 234, 52, 236, 249, 239, 46, 254, 147, 244, 81, 237, 173, 233, 91, 230, 141, 241, 197, 241, 169, 233, 151, 242, 194, 234, 177, 233, 229, 238, 29, 235, 109, 242, 160, 242, 137, 245, 75, 235, 250, 232, 15, 238, 162, 235, 202, 237, 209, 246, 131, 242, 51, 236, 124, 235, 188, 236, 29, 233, 160, 248, 111, 242, 79, 242, 137, 247, 101, 231, 5, 231, 95, 233, 176, 231, 57, 238, 152, 237, 91, 239, 154, 238, 184, 239, 67, 238, 219, 237, 93, 240, 50, 241, 25, 240, 247, 240, 247, 239, 179, 240, 84, 242, 57, 241, 106, 238, 221, 240, 188, 238, 181, 237, 164, 238, 102, 240, 40, 240, 226, 238, 2, 239, 220, 237, 84, 237, 36, 242, 140, 243, 178, 239, 179, 240, 66, 240, 154, 240, 35, 245, 181, 246, 152, 240, 117, 243, 84, 239, 220, 239, 205, 242, 153, 245, 231, 243, 27, 240, 142, 245, 139, 240, 72, 248, 130, 245, 34, 240, 78, 241, 161, 240, 214, 239, 71, 240, 74, 242, 53, 249, 81, 240, 144, 246, 199, 241, 68, 239, 230, 240, 158, 239, 207, 239, 17, 241, 230, 240, 123, 241, 131, 245, 100, 242, 102, 247, 101, 242, 141, 240, 124, 241, 33, 242, 215, 240, 249, 244, 230, 240, 7, 241, 2, 241, 55, 239, 237, 243, 113, 245, 69, 246, 111, 239, 215, 243, 3, 240, 92, 240, 4, 239, 223, 239, 166, 239, 6, 239, 100, 242, 47, 242, 114, 242, 110, 243, 184, 239, 212, 239, 247, 239, 58, 241, 158, 242, 233, 240, 145, 238, 193, 241, 235, 239, 161, 238, 88, 239, 35, 246, 188, 241, 89, 242, 73, 242, 31, 242, 86, 240, 189, 240, 41, 240, 185, 241, 53, 242, 33, 241, 83, 242, 246, 241, 135, 243, 223, 239, 209, 242, 164, 241, 116, 240, 236, 241, 208, 241, 166, 243, 228, 244, 226, 246, 4, 244, 59, 236, 72, 237, 200, 236, 182, 236, 241, 236, 11, 236, 114, 238, 154, 237, 178, 235, 123, 240, 10, 236, 171, 235, 70, 237, 20, 238, 173, 239, 136, 235, 85, 237, 2, 237, 28, 239, 128, 238, 36, 240, 135, 237, 243, 237, 115, 238, 13, 236, 101, 237, 234, 239, 143, 236, 65, 239, 195, 236, 66, 243, 142, 241, 102, 245, 65, 242, 122, 245, 231, 243, 161, 244, 249, 242, 209, 241, 156, 242, 222, 242, 188, 244, 161, 243, 200, 246, 87, 239, 88, 238, 28, 238, 40, 242, 156, 241, 92, 240, 187, 240, 185, 240, 141, 243, 125, 244, 128, 243, 132, 243, 173, 240, 5, 240, 43, 238, 46, 239, 225, 241, 246, 237, 138, 241, 143, 241, 36, 240, 114, 240, 79, 244, 235, 241, 254, 242, 106, 244, 151, 243, 196, 239, 243, 243, 49, 243, 200, 238, 21, 238, 203, 245, 244, 237, 202, 237, 45, 238, 203, 236, 2, 239, 145, 237, 230, 237, 217, 237, 117, 238, 44, 237, 113, 237, 154, 241, 63, 238, 156, 237, 153, 237, 215, 235, 150, 236, 47, 239, 178, 237, 151, 236, 60, 236, 145, 236, 123, 236, 157, 237, 156, 237, 46, 237, 73, 237, 34, 244, 183, 237, 104, 239, 165, 236, 54, 238, 195, 236, 99, 237, 223, 236, 41, 237, 153, 235, 241, 235, 122, 235, 163, 236, 222, 236, 194, 235, 114, 235, 228, 236, 142, 236, 251, 237, 215, 238, 121, 237, 64, 237, 104, 237, 109, 237, 201, 236, 184, 236, 90, 236, 102, 236, 124, 236, 190, 236, 114, 236, 242, 237, 198, 236, 112, 235, 162, 236, 37, 236, 117, 235, 120, 237, 141, 235, 210, 236, 97, 237, 20, 237, 234, 236, 31, 236, 184, 235, 57, 236, 236, 235, 255, 235, 191, 234, 218, 234, 126, 235, 7, 235, 104, 235, 43, 235, 215, 234, 96, 235, 114, 236, 162, 236, 126, 236, 95, 235, 192, 237, 97, 236, 192, 236, 46, 237, 240, 242, 237, 235, 232, 235, 9, 236, 186, 235, 255, 235, 182, 235, 38, 238, 12, 236, 89, 236, 23, 237, 253, 235, 174, 235, 83, 236, 215, 242, 92, 243, 27, 244, 254, 243, 96, 244, 254, 236, 125, 240, 235, 240, 17, 242, 214, 241, 208, 240, 109, 243, 182, 239, 241, 240, 38, 242, 101, 240, 39, 242, 29, 241, 249, 239, 57, 241, 142, 240, 130, 242, 130, 235, 0, 235, 201, 235, 82, 235, 119, 235, 37, 235, 99, 235, 94, 235, 254, 234, 43, 235, 251, 234, 12, 235, 219, 235, 64, 237, 205, 235, 220, 235, 75, 236, 68, 236, 217, 235, 237, 234, 194, 235, 232, 234, 103, 244, 158, 243, 82, 243, 56, 239, 110, 237, 133, 241, 57, 243, 12, 250, 165, 255, 254, 249, 91, 246, 18, 243, 89, 235, 115, 235, 89, 236, 39, 235, 196, 236, 135, 235, 116, 235, 204, 246, 97, 244, 190, 236, 53, 239, 186, 237, 156, 234, 179, 237, 201, 242, 24, 236, 236, 240, 98, 236, 29, 236, 11, 236, 72, 248, 159, 244, 149, 245, 170, 246, 58, 244, 18, 236, 178, 241, 205, 240, 246, 234, 115, 234, 168, 235, 206, 235, 204, 235, 73, 233, 85, 233, 215, 235, 43, 237, 155, 235, 212, 237, 13, 235, 190, 237, 173, 239, 1, 235, 102, 236, 163, 236, 77, 236, 146, 237, 206, 234, 85, 237, 204, 236, 216, 231, 88, 236, 104, 232, 3, 234, 41, 234, 67, 233, 231, 232, 116, 234, 155, 234, 128, 236, 111, 233, 7, 233, 161, 233, 50, 235, 149, 233, 26, 233, 201, 243, 60, 235, 29, 234, 120, 234, 158, 236, 26, 231, 180, 232, 27, 233, 210, 231, 56, 231, 234, 248, 143, 245, 195, 249, 228, 248, 104, 239, 48, 244, 166, 242, 96, 243, 245, 245, 140, 239, 226, 242, 169, 250, 228, 243, 172, 245, 17, 235, 102, 235, 183, 235, 193, 238, 159, 237, 99, 237, 163, 236, 80, 236, 181, 237, 85, 245, 104, 243, 57, 244, 137, 234, 24, 234, 16, 237, 251, 234, 225, 235, 109, 235, 223, 235, 224, 234, 12, 234, 218, 233, 171, 239, 51, 237, 232, 236, 140, 239, 72, 242, 197, 235, 217, 240, 66, 238, 122, 237, 158, 244, 89, 243, 98, 239, 24, 237, 40, 235, 19, 236, 174, 243, 126, 236, 82, 243, 224, 235, 71, 236, 215, 237, 171, 235, 185, 236, 212, 235, 170, 235, 246, 235, 159, 238, 197, 240, 126, 241, 111, 237, 47, 238, 54, 237, 88, 237, 0, 240, 236, 237, 30, 238, 176, 237, 15, 234, 234, 247, 179, 240, 255, 236, 92, 238, 103, 241, 147, 243, 26, 248, 42, 244, 35, 237, 246, 234, 149, 238, 54, 236, 96, 236, 225, 236, 217, 235, 7, 236, 187, 236, 162, 236, 233, 235, 198, 235, 19, 239, 184, 236, 200, 233, 176, 236, 243, 235, 104, 238, 14, 234, 175, 234, 201, 233, 169, 236, 142, 236, 132, 237, 144, 235, 231, 234, 217, 236, 53, 234, 163, 235, 122, 235, 62, 233, 142, 236, 81, 232, 154, 248, 178, 235, 127, 234, 93, 236, 199, 238, 17, 236, 115, 237, 226, 239, 219, 234, 228, 237, 144, 237, 6, 235, 231, 248, 95, 234, 3, 236, 36, 235, 132, 234, 146, 235, 224, 237, 85, 236, 43, 235, 64, 239, 45, 243, 201, 239, 108, 242, 49, 244, 78, 242, 113, 242, 137, 240, 156, 241, 115, 242, 157, 244, 194, 245, 251, 240, 243, 239, 241, 243, 128, 241, 117, 239, 197, 241, 68, 241, 55, 241, 251, 241, 90, 246, 177, 247, 74, 248, 237, 240, 113, 249, 21, 241, 162, 241, 214, 241, 245, 238, 14, 238, 15, 238, 29, 239, 114, 238, 212, 238, 36, 244, 161, 239, 49, 241, 3, 240, 202, 240, 83, 240, 180, 240, 195, 238, 71, 239, 28, 239, 132, 240, 32, 239, 10, 240, 38, 236, 49, 236, 20, 237, 169, 236, 254, 235, 37, 236, 77, 237, 106, 240, 195, 241, 33, 238, 53, 238, 161, 238, 57, 237, 29, 237, 23, 238, 194, 237, 129, 238, 104, 238, 10, 236, 180, 236, 227, 237, 104, 239, 117, 238, 155, 236, 8, 237, 217, 236, 158, 240, 26, 240, 230, 239, 58, 240, 144, 241, 126, 239, 45, 239, 83, 239, 162, 238, 76, 239, 134, 240, 210, 238, 33, 239, 78, 239, 3, 240, 197, 239, 195, 239, 122, 241, 183, 235, 24, 233, 162, 236, 98, 234, 160, 233, 215, 235, 172, 235, 186, 239, 165, 234, 134, 234, 18, 237, 238, 235, 184, 235, 85, 235, 150, 233, 45, 235, 244, 234, 2, 236, 246, 235, 19, 232, 217, 234, 219, 233, 162, 234, 213, 234, 25, 236, 169, 235, 205, 235, 172, 238, 49, 238, 131, 239, 43, 240, 73, 242, 223, 237, 138, 236, 58, 247, 64, 234, 33, 237, 14, 239, 238, 247, 17, 245, 107, 239, 196, 236, 118, 236, 195, 237, 44, 245, 74, 238, 120, 239, 53, 241, 208, 242, 166, 234, 215, 235, 61, 236, 45, 238, 168, 236, 38, 237, 117, 237, 211, 243, 158, 239, 122, 245, 38, 249, 149, 236, 26, 249, 203, 236, 7, 236, 145, 237, 32, 238, 177, 236, 86, 238, 24, 237, 214, 235, 134, 234, 64, 241, 84, 236, 110, 243, 98, 246, 228, 245, 40, 235, 237, 235, 114, 236, 239, 236, 242, 236, 10, 237, 251, 236, 106, 239, 66, 248, 133, 248, 0, 241, 148, 239, 172, 238, 68, 236, 49, 236, 176, 242, 183, 236, 152, 239, 238, 235, 109, 236, 96, 236, 77, 235, 215, 237, 123, 238, 198, 236, 114, 235, 213, 242, 122, 240, 220, 244, 191, 239, 97, 3, 160, 255, 16, 246, 159, 253, 242, 254, 236, 253, 83, 244, 203, 236, 72, 239, 242, 239, 57, 238, 119, 238, 167, 237, 157, 242, 65, 240, 194, 242, 215, 236, 253, 236, 17, 240, 149, 237, 73, 237, 31, 237, 225, 237, 71, 241, 3, 239, 248, 239, 184, 234, 44, 235, 157, 235, 211, 235, 132, 234, 121, 234, 173, 234, 169, 235, 31, 235, 195, 235, 8, 235, 115, 236, 164, 234, 121, 234, 24, 238, 16, 239, 81, 245, 162, 234, 143, 235, 215, 235, 0, 241, 98, 251, 145, 237, 60, 234, 192, 234, 140, 234, 1, 237, 41, 242, 56, 237, 134, 237, 67, 247, 22, 245, 116, 246, 186, 245, 195, 238, 10, 243, 44, 235, 152, 238, 240, 236, 105, 236, 158, 239, 3, 251, 201, 245, 85, 242, 130, 5, 49, 4, 236, 1, 72, 3, 21, 2, 255, 4, 26, 4, 22, 4, 126, 4, 160, 4, 179, 3, 104, 4, 244, 3, 22, 4, 67, 4, 156, 4, 141, 3, 161, 3, 225, 3, 157, 3, 152, 3, 192, 3, 253, 3, 205, 4, 79, 3, 7, 4, 32, 5, 99, 4, 76, 4, 98, 6, 51, 6, 170, 5, 242, 4, 226, 4, 134, 5, 141, 4, 196, 4, 115, 4, 25, 5, 24, 5, 181, 4, 190, 5, 69, 5, 22, 6, 55, 4, 121, 4, 24, 4, 196, 5, 58, 5, 237, 4, 139, 4, 251, 4, 35, 5, 187, 5, 93, 5, 130, 5, 190, 4, 108, 5, 225, 4, 215, 4, 154, 6, 170, 5, 52, 7, 231, 3, 28, 4, 149, 4, 170, 4, 225, 3, 91, 4, 0, 5, 72, 4, 163, 4, 113, 4, 102, 5, 215, 5, 105, 5, 178, 4, 46, 5, 242, 4, 200, 5, 96, 5, 80, 6, 41, 4, 106, 4, 29, 4, 247, 3, 222, 3, 126, 4, 146, 4, 132, 4, 144, 4, 148, 4, 221, 3, 197, 3, 186, 3, 183, 3, 70, 4, 74, 4, 56, 4, 7, 4, 184, 242, 251, 237, 105, 241, 112, 238, 197, 239, 69, 238, 111, 238, 46, 243, 118, 236, 32, 235, 55, 235, 248, 234, 36, 237, 112, 237, 127, 238, 58, 237, 90, 238, 95, 237, 16, 237, 48, 239, 101, 236, 146, 236, 163, 235, 177, 237, 57, 235, 199, 236, 46, 234, 25, 234, 12, 234, 63, 234, 101, 234, 77, 234, 75, 234, 205, 235, 246, 234, 204, 235, 72, 234, 127, 234, 94, 234, 76, 234, 210, 234, 73, 234, 6, 234, 202, 233, 68, 234, 230, 233, 7, 234, 218, 233, 13, 234, 64, 234, 64, 234, 64, 234, 48, 2, 5, 0, 170, 0, 38, 248, 26, 251, 212, 254, 52, 251, 129, 252, 252, 246, 126, 239, 228, 240, 47, 241, 209, 238, 214, 239, 128, 238, 49, 247, 35, 241, 191, 244, 49, 238, 149, 237, 198, 236, 72, 242, 245, 238, 226, 240, 52, 237, 136, 237, 17, 238, 229, 241, 72, 239, 89, 240, 250, 234, 166, 234, 128, 234, 145, 235, 150, 235, 221, 235, 179, 236, 30, 236, 54, 235, 204, 234, 78, 238, 47, 236, 48, 237, 231, 237, 30, 237, 60, 235, 33, 236, 117, 235, 98, 3, 36, 4, 169, 3, 252, 255, 186, 254, 86, 4, 120, 4, 68, 1, 233, 3, 113, 3, 191, 4, 52, 4, 74, 242, 88, 252, 38, 249, 34, 245, 207, 251, 113, 249, 215, 254, 150, 1, 147, 255, 86, 255, 144, 4, 126, 248, 146, 255, 111, 6, 209, 4, 95, 238, 39, 240, 177, 244, 1, 242, 54, 243, 246, 241, 107, 246, 127, 4, 100, 4, 15, 6, 254, 4, 224, 1, 91, 5, 83, 2, 5, 251, 110, 2, 236, 2, 99, 234, 152, 234, 125, 234, 169, 234, 120, 234, 18, 237, 202, 235, 253, 235, 176, 235, 178, 236, 1, 235, 195, 234, 209, 235, 18, 237, 146, 234, 233, 234, 225, 236, 199, 235, 136, 235, 181, 234, 254, 234, 160, 234, 98, 3, 141, 0, 30, 3, 148, 4, 160, 0, 218, 238, 167, 238, 128, 238, 228, 240, 177, 244, 231, 243, 138, 250, 89, 243, 92, 237, 157, 237, 223, 246, 205, 240, 51, 247, 183, 237, 19, 237, 122, 244, 233, 237, 249, 237, 14, 236, 251, 235, 25, 236, 250, 235, 251, 235, 35, 236, 139, 236, 67, 237, 107, 236, 64, 238, 21, 238, 15, 236, 27, 236, 56, 236, 134, 236, 204, 236, 33, 237, 22, 3, 57, 2, 253, 0, 133, 1, 209, 1, 114, 1, 203, 0, 69, 241, 229, 244, 55, 245, 217, 243, 52, 244, 84, 239, 136, 0, 147, 0, 165, 0, 51, 241, 229, 236, 118, 0, 209, 242, 79, 239, 136, 244, 170, 242, 144, 0, 200, 255, 118, 0, 96, 239, 68, 239, 165, 237, 76, 238, 165, 238, 112, 238, 250, 237, 88, 236, 50, 236, 150, 236, 94, 236, 126, 236, 124, 238, 17, 237, 218, 239, 71, 238, 40, 239, 136, 237, 145, 237, 38, 238, 73, 237, 90, 237, 244, 236, 16, 237, 251, 236, 136, 237, 249, 235, 222, 237, 8, 238, 11, 236, 31, 236, 22, 239, 14, 237, 124, 237, 91, 238, 170, 237, 21, 236, 26, 236, 57, 236, 54, 236, 79, 236, 178, 236, 107, 236, 32, 236, 79, 1, 157, 1, 138, 1, 134, 1, 148, 1, 22, 2, 214, 1, 140, 1, 135, 1, 144, 1, 225, 1, 228, 1, 244, 2, 216, 1, 134, 1, 134, 1, 240, 2, 146, 9, 50, 2, 14, 2, 210, 2, 166, 2, 224, 1, 192, 1, 180, 1, 188, 1, 175, 4, 21, 4, 77, 4, 239, 4, 10, 4, 32, 4, 242, 2, 237, 3, 221, 3, 112, 3, 241, 1, 51, 3, 253, 3, 164, 1, 218, 1, 179, 1, 105, 1, 116, 2, 155, 1, 159, 1, 147, 1, 226, 1, 174, 1, 183, 1, 237, 1, 162, 1, 53, 2, 45, 3, 206, 1, 220, 2, 204, 5, 115, 4, 148, 2, 147, 5, 24, 3, 140, 5, 129, 4, 113, 6, 238, 9, 65, 10, 132, 13, 114, 7, 50, 3, 138, 1, 176, 4, 34, 7, 142, 7, 195, 4, 91, 11, 25, 4, 69, 7, 172, 11, 180, 5, 111, 3, 62, 3, 36, 6, 148, 1, 163, 7, 243, 1, 233, 2, 126, 4, 121, 8, 170, 7, 54, 8, 149, 4, 96, 7, 10, 7, 71, 4, 185, 7, 179, 10, 84, 8, 102, 7, 11, 8, 146, 3, 157, 1, 97, 3, 135, 4, 14, 1, 225, 3, 9, 2, 160, 3, 168, 2, 215, 3, 113, 3, 220, 2, 107, 2, 137, 2, 225, 1, 60, 5, 234, 3, 3, 5, 247, 3, 120, 2, 140, 2, 220, 1, 86, 4, 220, 1, 103, 5, 5, 2, 59, 4, 55, 240, 33, 241, 23, 243, 90, 241, 46, 241, 77, 243, 188, 246, 246, 0, 255, 255, 79, 253, 244, 255, 248, 255, 52, 0, 7, 246, 166, 251, 87, 245, 3, 1, 188, 1, 50, 249, 55, 0, 145, 1, 61, 1, 2, 1, 255, 244, 83, 246, 146, 244, 121, 4, 110, 4, 110, 4, 203, 4, 146, 4, 124, 4, 49, 5, 110, 4, 135, 5, 81, 3, 189, 4, 32, 7, 19, 5, 196, 4, 255, 4, 99, 4, 74, 4, 139, 4, 60, 3, 21, 4, 222, 3, 85, 7, 177, 4, 136, 5, 181, 4, 168, 5, 172, 3, 211, 4, 150, 4, 19, 4, 135, 1, 223, 2, 191, 1, 39, 2, 246, 2, 88, 1, 248, 5, 249, 2, 155, 0, 104, 1, 149, 7, 227, 2, 132, 6, 4, 4, 52, 5, 11, 2, 20, 1, 221, 3, 135, 3, 134, 1, 177, 2, 199, 1, 249, 0, 45, 5, 181, 4, 111, 1, 58, 1, 143, 1, 190, 2, 208, 1, 66, 0, 236, 246, 166, 1, 182, 0, 141, 0, 191, 0, 71, 1, 88, 2, 251, 0, 58, 2, 110, 4, 126, 6, 82, 5, 220, 4, 114, 7, 29, 3, 82, 5, 223, 4, 87, 4, 5, 2, 130, 5, 255, 8, 123, 1, 158, 2, 222, 2, 175, 4, 114, 1, 28, 2, 106, 3, 222, 10, 156, 7, 138, 4, 171, 239, 227, 238, 68, 239, 65, 240, 52, 241, 110, 242, 33, 241, 172, 242, 213, 241, 100, 244, 47, 240, 165, 238, 177, 251, 186, 0, 60, 243, 51, 247, 218, 250, 244, 249, 255, 243, 127, 239, 137, 241, 30, 241, 14, 2, 228, 0, 31, 1, 235, 1, 184, 0, 193, 0, 35, 0, 11, 0, 215, 0, 24, 1, 33, 246, 54, 0, 28, 0, 137, 251, 16, 0, 152, 0, 80, 0, 76, 0, 230, 1, 133, 1, 90, 1, 150, 1, 158, 1, 90, 1, 4, 1, 78, 1, 2, 1, 83, 1, 119, 0, 132, 1, 93, 1, 237, 1, 128, 1, 78, 1, 251, 1, 188, 1, 211, 1, 117, 2, 144, 1, 222, 1, 61, 1, 94, 1, 244, 1, 223, 1, 126, 1, 132, 1, 201, 1, 105, 2, 47, 2, 10, 2, 107, 2, 105, 2, 44, 3, 131, 1, 19, 2, 212, 1, 130, 1, 100, 1, 194, 1, 134, 1, 27, 2, 177, 1, 111, 2, 101, 2, 99, 2, 148, 2, 218, 1, 192, 2, 178, 2, 206, 1, 116, 2, 89, 2, 35, 3, 235, 1, 7, 2, 111, 3, 47, 2, 45, 4, 7, 2, 51, 2, 216, 2, 185, 2, 171, 2, 29, 3, 229, 2, 240, 2, 48, 4, 80, 3, 193, 4, 27, 4, 224, 3, 21, 3, 153, 1, 189, 2, 248, 1, 243, 1, 187, 3, 246, 3, 198, 4, 69, 4, 94, 4, 50, 4, 182, 1, 139, 2, 216, 1, 58, 2, 173, 5, 18, 4, 39, 4, 121, 3, 100, 237, 151, 237, 123, 239, 137, 238, 226, 238, 42, 238, 148, 238, 26, 0, 5, 0, 231, 255, 54, 249, 117, 254, 246, 255, 153, 242, 122, 250, 52, 241, 79, 0, 234, 2, 249, 241, 5, 252, 50, 0, 225, 255, 29, 245, 225, 240, 123, 242, 107, 240, 88, 1, 6, 1, 71, 1, 7, 1, 66, 1, 187, 1, 203, 2, 226, 4, 150, 1, 59, 2, 55, 2, 143, 1, 250, 4, 59, 3, 133, 2, 194, 1, 13, 2, 116, 1, 128, 0, 91, 0, 174, 0, 80, 3, 180, 0, 216, 4, 222, 0, 122, 0, 157, 0, 224, 0, 229, 0, 191, 0, 253, 0, 61, 1, 12, 1, 30, 1, 0, 1, 237, 0, 206, 0, 117, 1, 16, 1, 65, 1, 180, 1, 142, 1, 205, 0, 209, 0, 156, 1, 99, 1, 231, 1, 241, 0, 11, 1, 36, 1, 192, 0, 66, 1, 174, 0, 39, 1, 210, 0, 185, 0, 21, 0, 53, 0, 77, 0, 144, 0, 211, 0, 71, 2, 239, 0, 123, 1, 82, 1, 83, 1, 210, 0, 146, 0, 187, 0, 83, 1, 67, 1, 203, 0, 177, 0, 250, 1, 76, 1, 97, 1, 172, 1, 142, 1, 172, 1, 121, 1, 236, 1, 183, 2, 251, 2, 49, 2, 104, 2, 244, 2, 61, 2, 117, 2, 225, 4, 36, 3, 127, 3, 214, 2, 52, 3, 136, 4, 5, 3, 172, 2, 110, 2, 76, 2, 39, 2, 27, 2, 197, 1, 211, 1, 142, 3, 21, 2, 200, 2, 230, 1, 1, 3, 106, 1, 58, 2, 172, 1, 153, 2, 46, 3, 26, 2, 247, 3, 175, 4, 50, 5, 65, 2, 74, 2, 82, 2, 58, 2, 36, 2, 16, 2, 158, 2, 116, 4, 171, 3, 59, 3, 84, 1, 77, 1, 69, 1, 171, 1, 106, 1, 159, 1, 39, 1, 55, 1, 36, 1, 160, 3, 225, 2, 62, 3, 127, 1, 204, 1, 206, 1, 229, 1, 195, 1, 158, 1, 243, 0, 31, 1, 201, 0, 35, 1, 40, 1, 67, 1, 48, 1, 25, 1, 84, 1, 87, 1, 87, 1, 47, 1, 135, 2, 241, 1, 98, 2, 207, 2, 176, 2, 60, 1, 108, 1, 193, 0, 108, 1, 163, 1, 62, 3, 93, 4, 39, 4, 148, 2, 208, 1, 178, 1, 206, 1, 16, 2, 81, 1, 36, 1, 18, 1, 84, 1, 70, 1, 149, 1, 143, 1, 20, 2, 195, 1, 234, 1, 54, 2, 105, 1, 166, 1, 144, 2, 84, 1, 114, 1, 121, 2, 133, 1, 137, 1, 142, 1, 175, 1, 108, 1, 81, 1, 28, 1, 39, 1, 98, 1, 109, 1, 76, 1, 67, 1, 87, 1, 100, 1, 108, 1, 97, 1, 59, 1, 100, 1, 159, 1, 113, 1, 93, 1, 160, 1, 94, 1, 89, 1, 25, 1, 44, 1, 52, 1, 69, 2, 12, 3, 120, 2, 44, 3, 97, 3, 180, 2, 17, 2, 195, 1, 199, 1, 158, 1, 35, 2, 1, 3, 241, 1, 175, 1, 44, 2, 19, 2, 224, 1, 179, 1, 239, 1, 48, 2, 181, 2, 224, 1, 208, 1, 168, 1, 209, 1, 235, 1, 245, 1, 195, 1, 176, 1, 201, 1, 186, 1, 172, 1, 203, 2, 16, 3, 195, 3, 3, 2, 156, 1, 152, 1, 161, 1, 18, 2, 209, 1, 196, 1, 57, 4, 182, 1, 101, 4, 224, 5, 182, 4, 53, 4, 139, 4, 57, 4, 183, 4, 50, 6, 172, 4, 67, 4, 150, 4, 146, 4, 160, 5, 163, 4, 7, 5, 111, 5, 234, 4, 141, 4, 156, 5, 95, 5, 243, 6, 152, 6, 36, 5, 16, 6, 75, 5, 169, 2, 56, 2, 6, 2, 7, 3, 164, 2, 111, 2, 31, 2, 73, 2, 195, 2, 148, 3, 255, 2, 65, 4, 76, 5, 147, 4, 255, 2, 19, 4, 168, 7, 112, 3, 226, 5, 194, 2, 238, 3, 70, 5, 151, 3, 104, 4, 33, 4, 24, 4, 230, 4, 53, 4, 27, 4, 89, 4, 74, 4, 78, 4, 195, 4, 33, 2, 13, 3, 211, 2, 210, 2, 169, 2, 68, 2, 220, 3, 68, 3, 122, 3, 90, 4, 201, 3, 61, 3, 59, 4, 228, 4, 129, 5, 157, 3, 182, 5, 46, 3, 65, 4, 121, 3, 94, 3, 181, 2, 111, 5, 188, 5, 97, 5, 21, 5, 154, 3, 119, 2, 141, 2, 15, 4, 241, 1, 213, 1, 197, 1, 83, 2, 203, 1, 132, 6, 55, 3, 255, 1, 82, 2, 248, 1, 211, 2, 237, 2, 38, 2, 147, 1, 251, 1, 86, 2, 212, 1, 194, 2, 47, 2, 48, 2, 81, 2, 51, 2, 166, 1, 131, 1, 158, 1, 116, 1, 153, 1, 117, 1, 157, 1, 69, 2, 175, 2, 39, 2, 143, 2, 218, 2, 196, 2, 13, 2, 114, 2, 194, 1, 63, 2, 239, 3, 185, 1, 231, 1, 232, 1, 225, 1, 232, 1, 204, 1, 209, 1, 154, 1, 176, 4, 32, 5, 127, 3, 252, 4, 137, 3, 97, 4, 42, 3, 144, 1, 155, 1, 70, 2, 168, 1, 170, 1, 180, 1, 92, 2, 71, 2, 85, 2, 66, 2, 222, 2, 128, 2, 167, 2, 108, 2, 173, 2, 51, 2, 123, 3, 174, 2, 206, 2, 234, 2, 7, 2, 10, 2, 224, 1, 184, 1, 144, 2, 102, 2, 215, 2, 171, 2, 204, 3, 138, 1, 160, 1, 148, 1, 148, 1, 212, 1, 93, 2, 238, 1, 168, 1, 222, 237, 56, 240, 25, 239, 247, 238, 255, 239, 160, 239, 117, 239, 28, 244, 144, 242, 46, 246, 248, 240, 171, 241, 90, 249, 73, 253, 252, 240, 68, 243, 137, 247, 129, 244, 47, 245, 43, 241, 77, 243, 208, 240, 222, 4, 9, 2, 231, 2, 126, 2, 233, 2, 80, 1, 56, 0, 20, 2, 37, 2, 93, 1, 231, 1, 31, 2, 8, 3, 190, 2, 138, 2, 209, 1, 3, 243, 65, 241, 7, 255, 215, 247, 115, 0, 113, 255, 246, 1, 93, 1, 93, 1, 41, 0, 6, 3, 246, 1, 98, 3, 110, 4, 175, 2, 167, 3, 66, 3, 214, 255, 3, 1, 149, 2, 160, 1, 133, 1, 247, 3, 13, 3, 3, 2, 105, 2, 6, 2, 118, 2, 85, 2, 158, 2, 131, 2, 101, 2, 147, 2, 204, 2, 205, 2, 199, 2, 42, 249, 64, 1, 38, 0, 140, 253, 237, 254, 19, 2, 63, 2, 29, 2, 102, 1, 190, 2, 238, 248, 248, 250, 85, 247, 187, 255, 235, 1, 87, 0, 167, 2, 27, 0, 248, 4, 233, 2, 211, 3, 255, 5, 230, 2, 194, 1, 188, 1, 155, 1, 237, 1, 127, 1, 64, 2, 18, 2, 249, 1, 210, 1, 106, 2, 244, 1, 146, 1, 18, 2, 206, 1, 3, 2, 198, 1, 69, 2, 197, 1, 132, 2, 180, 2, 245, 1, 235, 1, 81, 1, 120, 1, 91, 1, 104, 1, 71, 1, 60, 2, 126, 2, 54, 2, 200, 1, 40, 2, 247, 1, 157, 1, 135, 1, 119, 1, 50, 2, 134, 1, 6, 2, 194, 2, 123, 3, 143, 2, 243, 2, 8, 2, 238, 1, 48, 2, 121, 1, 223, 1, 189, 1, 157, 2, 250, 2, 32, 1, 54, 1, 100, 2, 193, 1, 62, 1, 59, 1, 46, 1, 241, 1, 159, 1, 222, 1, 242, 1, 113, 1, 220, 1, 165, 1, 205, 1, 57, 1, 85, 1, 81, 1, 75, 1, 97, 1, 62, 2, 176, 1, 169, 1, 209, 1, 113, 1, 131, 1, 128, 1, 153, 1, 207, 235, 13, 236, 201, 235, 47, 236, 246, 237, 34, 237, 44, 236, 50, 238, 28, 238, 37, 238, 124, 237, 13, 238, 53, 236, 132, 238, 248, 236, 149, 236, 2, 238, 158, 237, 11, 240, 79, 235, 131, 235, 100, 236, 248, 241, 5, 241, 38, 240, 213, 241, 74, 241, 61, 241, 158, 242, 5, 2, 80, 1, 98, 0, 99, 248, 106, 3, 145, 254, 141, 255, 1, 0, 150, 254, 222, 238, 4, 241, 66, 241, 196, 240, 59, 240, 136, 240, 218, 240, 123, 249, 245, 238, 189, 241, 6, 244, 64, 243, 68, 241, 103, 242, 228, 0, 82, 247, 9, 1, 168, 239, 122, 240, 110, 240, 13, 241, 221, 240, 175, 240, 239, 240, 183, 0, 141, 1, 109, 0, 153, 0, 32, 4, 252, 0, 233, 255, 20, 0, 226, 255, 117, 240, 71, 253, 212, 255, 53, 238, 96, 239, 166, 239, 164, 238, 74, 238, 0, 0, 155, 248, 189, 0, 126, 0, 156, 246, 89, 239, 45, 240, 162, 239, 47, 240, 58, 240, 46, 239, 175, 239, 92, 240, 191, 245, 7, 242, 216, 242, 176, 249, 4, 245, 165, 2, 30, 249, 196, 249, 33, 250, 72, 249, 93, 248, 87, 245, 26, 243, 44, 241, 216, 242, 121, 241, 47, 243, 50, 242, 192, 243, 108, 242, 112, 239, 150, 244, 172, 245, 139, 240, 101, 255, 171, 249, 233, 233, 209, 232, 46, 233, 72, 232, 88, 232, 35, 233, 198, 232, 72, 232, 77, 232, 71, 250, 123, 250, 12, 253, 203, 245, 35, 248, 198, 247, 219, 247, 17, 250, 198, 234, 130, 233, 194, 231, 159, 241, 74, 232, 53, 232, 204, 232, 23, 245, 215, 233, 11, 244, 177, 231, 194, 232, 104, 231, 144, 241, 130, 241, 21, 240, 40, 240, 76, 243, 6, 240, 93, 244, 209, 240, 112, 242, 232, 239, 43, 241, 254, 241, 51, 241, 155, 239, 185, 250, 227, 243, 42, 249, 168, 242, 240, 250, 174, 255, 192, 254, 190, 248, 244, 239, 148, 237, 186, 239, 208, 240, 45, 250, 248, 245, 233, 245, 36, 245, 115, 242, 164, 247, 64, 247, 161, 244, 62, 247, 220, 246, 195, 240, 119, 241, 104, 240, 105, 244, 37, 238, 110, 243, 81, 241, 20, 249, 173, 6, 178, 2, 112, 16, 48, 11, 3, 2, 53, 2, 190, 1, 89, 5, 96, 9, 235, 3, 182, 5, 178, 2, 112, 10, 216, 14, 105, 0, 201, 0, 142, 0, 237, 1, 59, 1, 38, 1, 254, 0, 77, 1, 50, 1, 105, 4, 53, 2, 210, 1, 118, 249, 230, 254, 29, 2, 77, 255, 178, 0, 169, 255, 122, 0, 25, 1, 142, 1, 109, 1, 197, 4, 34, 3, 137, 5, 122, 3, 26, 2, 214, 4, 216, 0, 17, 5, 137, 0, 116, 0, 31, 3, 177, 3, 101, 4, 71, 2, 158, 3, 12, 0, 87, 236, 48, 240, 145, 235, 146, 255, 173, 251, 124, 255, 16, 247, 71, 247, 139, 255, 5, 1, 76, 0, 242, 0, 10, 0, 246, 255, 37, 0, 198, 255, 217, 255, 179, 255, 169, 255, 223, 255, 209, 255, 174, 255, 149, 255, 152, 255, 159, 255, 187, 255, 197, 255, 170, 255, 182, 255, 152, 255, 215, 3, 73, 3, 1, 3, 226, 1, 160, 1, 141, 0, 0, 0, 31, 1, 91, 2, 45, 3, 184, 0, 27, 1, 21, 1, 136, 0, 71, 0, 132, 1, 211, 0, 199, 0, 77, 244, 35, 240, 109, 241, 187, 239, 91, 240, 198, 255, 36, 254, 42, 254, 69, 255, 122, 255, 154, 253, 103, 254, 160, 255, 221, 255, 187, 248, 164, 255, 79, 255, 110, 255, 60, 254, 118, 251, 191, 254, 8, 242, 16, 235, 2, 249, 198, 239, 211, 234, 185, 236, 147, 255, 185, 255, 199, 254, 137, 255, 123, 255, 129, 255, 78, 255, 146, 254, 123, 255, 91, 239, 16, 252, 129, 254, 245, 252, 193, 252, 165, 248, 160, 250, 206, 240, 250, 255, 112, 1, 163, 1, 60, 0, 44, 4, 251, 255, 94, 1, 160, 0, 67, 0, 17, 0, 188, 0, 50, 5, 255, 255, 151, 255, 36, 2, 6, 1, 191, 0, 61, 1, 36, 1, 85, 3, 103, 3, 14, 2, 110, 255, 48, 255, 64, 255, 210, 255, 53, 255, 147, 255, 162, 255, 205, 255, 139, 255, 77, 255, 158, 255, 97, 255, 107, 255, 156, 255, 164, 255, 128, 255, 134, 255, 113, 255, 211, 243, 50, 242, 37, 238, 18, 252, 238, 248, 90, 240, 16, 239, 177, 240, 189, 238, 52, 239, 75, 237, 168, 238, 198, 240, 254, 240, 20, 251, 170, 243, 158, 239, 80, 241, 44, 239, 88, 240, 188, 239, 93, 241, 45, 240, 34, 242, 0, 241, 155, 241, 229, 241, 17, 242, 177, 243, 144, 241, 60, 246, 245, 242, 203, 244, 6, 246, 200, 243, 237, 242, 35, 244, 175, 242, 61, 241, 142, 240, 240, 244, 86, 243, 252, 241, 239, 241, 199, 242, 28, 246, 213, 244, 30, 244, 166, 243, 179, 242, 206, 242, 55, 243, 226, 242, 136, 243, 76, 242, 236, 242, 98, 243, 181, 242, 85, 243, 121, 241, 175, 242, 71, 243, 243, 242, 95, 242, 124, 242, 186, 243, 79, 242, 199, 243, 18, 241, 205, 241, 141, 241, 88, 241, 108, 242, 130, 243, 115, 240, 26, 242, 90, 241, 171, 240, 2, 240, 48, 242, 236, 239, 94, 241, 207, 241, 94, 241, 247, 240, 66, 239, 39, 241, 143, 241, 147, 241, 229, 240, 21, 240, 102, 240, 80, 239, 214, 237, 120, 236, 216, 237, 89, 238, 180, 236, 96, 239, 5, 237, 148, 235, 190, 236, 12, 235, 96, 234, 34, 234, 2, 236, 72, 235, 152, 235, 143, 234, 86, 236, 164, 235, 39, 235, 8, 236, 114, 234, 47, 234, 17, 235, 39, 235, 131, 235, 92, 239, 109, 245, 198, 240, 82, 243, 202, 243, 201, 238, 247, 239, 56, 242, 26, 240, 121, 238, 100, 238, 163, 238, 10, 239, 134, 237, 36, 236, 16, 239, 187, 238, 167, 239, 52, 237, 152, 249, 99, 237, 221, 240, 79, 241, 97, 240, 220, 240, 139, 245, 188, 242, 1, 241, 26, 243, 250, 241, 1, 240, 134, 239, 239, 236, 32, 238, 216, 238, 188, 237, 204, 237, 14, 236, 49, 234, 90, 237, 142, 236, 245, 236, 116, 237, 17, 236, 81, 238, 198, 237, 97, 237, 42, 238, 14, 238, 179, 238, 128, 237, 171, 237, 210, 237, 89, 238, 1, 238, 200, 235, 184, 235, 254, 236, 19, 235, 220, 235, 36, 235, 195, 235, 24, 238, 8, 237, 47, 236, 84, 237, 140, 233, 253, 234, 241, 232, 64, 234, 3, 237, 55, 236, 158, 236, 35, 237, 214, 244, 135, 242, 89, 239, 90, 241, 22, 238, 182, 239, 96, 237, 139, 239, 72, 239, 76, 238, 103, 238, 224, 238, 253, 238, 42, 243, 192, 235, 66, 237, 111, 236, 166, 234, 171, 236, 237, 236, 190, 237, 14, 238, 129, 237, 177, 237, 92, 238, 112, 236, 12, 243, 234, 242, 163, 243, 100, 244, 23, 245, 223, 245, 190, 241, 96, 240, 34, 241, 166, 241, 109, 240, 16, 241, 150, 239, 220, 242, 195, 242, 122, 242, 72, 239, 143, 240, 154, 241, 30, 241, 98, 239, 127, 240, 226, 239, 173, 241, 37, 241, 176, 242, 225, 238, 61, 240, 198, 238, 224, 237, 17, 239, 112, 237, 105, 240, 194, 240, 149, 239, 224, 236, 171, 237, 195, 236, 193, 237, 46, 238, 2, 238, 118, 237, 131, 238, 48, 237, 230, 239, 158, 239, 207, 239, 44, 239, 204, 239, 118, 239, 149, 238, 144, 239, 112, 238, 103, 238, 108, 239, 250, 238, 97, 238, 136, 238, 171, 238, 186, 238, 97, 239, 178, 239, 22, 238, 176, 238, 74, 239, 138, 238, 188, 237, 152, 238, 135, 237, 237, 237, 34, 237, 132, 238, 107, 238, 119, 238, 244, 240, 109, 239, 218, 238, 42, 241, 77, 240, 223, 238, 200, 238, 117, 240, 157, 239, 107, 240, 84, 239, 212, 239, 209, 242, 248, 241, 150, 241, 16, 242, 218, 241, 131, 240, 217, 240, 17, 241, 81, 240, 91, 241, 78, 238, 121, 238, 47, 239, 207, 237, 154, 238, 185, 239, 159, 239, 74, 239, 182, 240, 135, 240, 84, 240, 6, 240, 39, 239, 161, 239, 108, 240, 17, 239, 160, 240, 204, 239, 180, 240, 104, 239, 126, 239, 111, 240, 241, 243, 221, 242, 123, 243, 4, 246, 16, 247, 237, 244, 215, 244, 156, 243, 111, 244, 64, 244, 50, 244, 62, 245, 101, 241, 237, 240, 36, 243, 96, 243, 59, 242, 200, 242, 212, 243, 154, 248, 43, 246, 59, 243, 127, 240, 148, 241, 71, 242, 208, 238, 118, 241, 251, 240, 218, 241, 86, 241, 39, 240, 140, 239, 67, 243, 215, 242, 119, 242, 237, 245, 29, 245, 180, 240, 168, 242, 201, 241, 72, 0, 31, 0, 36, 0, 81, 0, 64, 0, 118, 0, 71, 0, 58, 0, 199, 0, 120, 0, 80, 0, 47, 0, 159, 0, 188, 0, 121, 0, 110, 0, 13, 1, 227, 0, 248, 0, 66, 0, 159, 0, 83, 0, 247, 0, 11, 1, 6, 2, 205, 0, 10, 1, 187, 0, 218, 0, 90, 1, 103, 1, 157, 1, 241, 0, 91, 1, 42, 1, 156, 1, 100, 1, 45, 1, 135, 0, 126, 0, 232, 0, 142, 0, 251, 0, 131, 0, 2, 1, 70, 1, 58, 1, 68, 1, 20, 1, 165, 1, 184, 0, 216, 0, 200, 1, 200, 0, 217, 0, 245, 0, 73, 1, 57, 2, 226, 0, 71, 1, 48, 1, 169, 0, 51, 1, 47, 1, 59, 1, 212, 0, 225, 0, 195, 0, 87, 1, 28, 1, 68, 1, 213, 0, 104, 1, 192, 0, 107, 0, 185, 0, 198, 0, 150, 0, 78, 1, 96, 1, 81, 1, 201, 1, 251, 0, 23, 1, 19, 1, 229, 0, 239, 0, 250, 0, 98, 1, 180, 1, 77, 1, 34, 1, 207, 5, 60, 4, 173, 1, 224, 8, 255, 0, 19, 4, 32, 11, 73, 0, 85, 0, 60, 0, 215, 0, 190, 0, 163, 0, 99, 0, 133, 0, 136, 0, 41, 13, 59, 13, 237, 12, 235, 12, 10, 1, 98, 6, 50, 1, 10, 1, 1, 1, 103, 4, 243, 2, 223, 3, 85, 3, 102, 1, 244, 2, 250, 1, 232, 2, 198, 2, 255, 0, 169, 1, 75, 1, 5, 1, 119, 0, 203, 0, 121, 0, 123, 1, 193, 1, 24, 1, 67, 0, 66, 0, 60, 0, 246, 0, 112, 0, 123, 0, 78, 0, 81, 0, 66, 0, 38, 1, 253, 0, 40, 1, 235, 0, 253, 1, 80, 3, 110, 1, 49, 1, 10, 1, 16, 1, 227, 12, 190, 9, 95, 1, 234, 1, 23, 1, 177, 4, 102, 4, 81, 0, 94, 0, 80, 0, 111, 1, 241, 0, 191, 0, 139, 0, 135, 0, 216, 0, 126, 1, 123, 1, 116, 1, 88, 0, 103, 0, 99, 0, 118, 0, 151, 0, 84, 0, 156, 0, 116, 0, 91, 0, 102, 0, 137, 1, 188, 0, 230, 0, 241, 0, 210, 0, 124, 0, 161, 0, 160, 0, 189, 238, 255, 238, 212, 239, 45, 239, 228, 239, 143, 239, 120, 240, 144, 253, 255, 242, 77, 252, 225, 255, 67, 0, 72, 240, 179, 239, 66, 247, 223, 247, 207, 255, 75, 241, 125, 255, 237, 254, 245, 255, 191, 255, 199, 255, 210, 240, 228, 255, 35, 241, 39, 3, 153, 2, 198, 2, 204, 2, 62, 3, 165, 1, 181, 1, 34, 2, 19, 2, 176, 2, 211, 1, 100, 2, 251, 2, 45, 2, 1, 3, 240, 2, 69, 2, 240, 0, 127, 3, 61, 4, 229, 3, 175, 1, 87, 2, 212, 1, 175, 1, 168, 1, 37, 3, 211, 2, 167, 3, 77, 3, 198, 2, 236, 255, 228, 1, 11, 2, 34, 2, 27, 0, 218, 0, 243, 255, 249, 3, 43, 3, 106, 2, 214, 255, 67, 2, 69, 2, 192, 2, 146, 3, 45, 2, 77, 3, 26, 4, 11, 2, 108, 2, 42, 3, 242, 2, 168, 4, 39, 3, 162, 3, 233, 0, 48, 3, 78, 3, 135, 1, 3, 1, 189, 2, 177, 4, 17, 2, 70, 3, 128, 3, 240, 3, 203, 0, 204, 0, 128, 2, 182, 1, 9, 2, 58, 2, 53, 2, 35, 1, 213, 0, 0, 1, 250, 0, 130, 2, 114, 0, 99, 0, 121, 0, 107, 0, 134, 0, 198, 0, 130, 0, 212, 1, 162, 1, 142, 2, 129, 1, 149, 2, 247, 0, 199, 0, 154, 0, 160, 1, 241, 0, 228, 1, 174, 1, 31, 2, 124, 1, 112, 1, 88, 2, 128, 3, 104, 1, 242, 1, 246, 1, 93, 2, 24, 2, 69, 2, 238, 0, 137, 1, 111, 1, 152, 2, 186, 1, 150, 1, 122, 1, 72, 1, 92, 1, 180, 1, 49, 1, 247, 1, 162, 1, 99, 1, 66, 1, 92, 1, 36, 1, 236, 0, 244, 0, 211, 0, 192, 0, 171, 4, 192, 3, 215, 3, 253, 3, 121, 2, 44, 2, 127, 1, 16, 1, 153, 1, 176, 1, 165, 0, 74, 3, 68, 1, 137, 1, 58, 1, 37, 3, 97, 1, 179, 2, 33, 2, 93, 3, 229, 1, 18, 2, 185, 2, 0, 2, 34, 1, 78, 2, 132, 1, 69, 2, 40, 247, 167, 236, 14, 248, 10, 238, 108, 237, 139, 235, 50, 235, 178, 233, 93, 234, 69, 233, 52, 234, 192, 237, 236, 243, 255, 232, 169, 236, 133, 240, 180, 233, 99, 235, 29, 234, 29, 236, 234, 235, 90, 237, 5, 238, 192, 237, 168, 236, 197, 236, 186, 236, 197, 238, 227, 235, 191, 235, 184, 235, 219, 235, 117, 235, 155, 235, 186, 235, 126, 235, 159, 235, 97, 236, 126, 236, 84, 235, 70, 236, 63, 236, 194, 235, 64, 236, 221, 235, 77, 237, 114, 236, 52, 236, 16, 234, 107, 233, 117, 234, 23, 234, 127, 233, 100, 235, 254, 234, 225, 232, 26, 233, 71, 236, 65, 235, 79, 235, 197, 233, 90, 234, 244, 235, 226, 235, 183, 235, 182, 235, 83, 236, 75, 236, 195, 235, 244, 235, 50, 236, 111, 235, 88, 236, 188, 235, 38, 235, 72, 235, 54, 235, 162, 234, 224, 234, 186, 235, 160, 235, 218, 235, 223, 235, 221, 235, 68, 234, 124, 234, 65, 233, 156, 233, 235, 234, 232, 235, 211, 236, 152, 235, 40, 240, 238, 253, 175, 239, 29, 239, 131, 238, 99, 246, 173, 242, 203, 239, 12, 241, 86, 240, 29, 240, 100, 239, 91, 237, 67, 237, 69, 237, 6, 237, 83, 239, 171, 237, 131, 239, 119, 238, 120, 239, 35, 238, 247, 255, 203, 255, 229, 246, 130, 254, 33, 250, 181, 255, 137, 255, 1, 242, 33, 241, 215, 240, 118, 246, 4, 244, 66, 243, 54, 241, 217, 241, 47, 245, 130, 255, 235, 248, 16, 255, 128, 254, 239, 244, 22, 247, 34, 246, 35, 246, 253, 246, 251, 247, 79, 240, 174, 238, 68, 249, 252, 241, 1, 238, 51, 239, 3, 241, 194, 237, 165, 243, 137, 244, 72, 242, 250, 238, 251, 241, 149, 248, 142, 241, 245, 241, 248, 242, 175, 242, 10, 240, 126, 238, 45, 240, 112, 246, 168, 249, 82, 245, 142, 252, 82, 245, 194, 243, 60, 240, 74, 242, 117, 241, 250, 239, 182, 240, 25, 239, 135, 238, 176, 239, 80, 240, 64, 241, 102, 239, 56, 239, 148, 239, 172, 238, 85, 240, 238, 237, 63, 239, 113, 2, 220, 2, 131, 1, 210, 0, 166, 1, 83, 0, 107, 0, 90, 0, 124, 0, 86, 0, 147, 0, 201, 1, 56, 0, 35, 0, 77, 0, 83, 0, 17, 0, 65, 0, 66, 0, 114, 1, 137, 0, 204, 0, 123, 234, 22, 238, 41, 243, 201, 239, 11, 236, 12, 250, 158, 255, 201, 255, 118, 255, 230, 246, 235, 255, 197, 255, 240, 255, 135, 240, 69, 249, 141, 246, 229, 0, 131, 0, 167, 255, 60, 0, 9, 0, 89, 0, 3, 0, 80, 254, 178, 255, 165, 255, 143, 4, 74, 3, 121, 1, 202, 2, 93, 4, 138, 3, 35, 2, 50, 0, 69, 0, 121, 0, 65, 0, 147, 0, 113, 0, 14, 1, 185, 255, 244, 255, 239, 255, 39, 0, 15, 0, 20, 0, 116, 0, 128, 1, 255, 0, 173, 1, 89, 0, 23, 2, 64, 0, 5, 0, 25, 0, 58, 0, 2, 0, 78, 0, 113, 0, 96, 0, 224, 0, 0, 0, 70, 0, 64, 0, 69, 0, 50, 0, 127, 0, 156, 0, 79, 0, 17, 0, 143, 238, 165, 237, 203, 237, 63, 237, 38, 237, 59, 240, 224, 237, 195, 237, 169, 237, 211, 237, 203, 239, 64, 238, 43, 236, 22, 236, 255, 236, 126, 236, 127, 236, 108, 236, 207, 236, 85, 237, 197, 236, 176, 236, 62, 0, 207, 255, 184, 0, 119, 255, 154, 249, 218, 246, 151, 251, 244, 242, 173, 244, 27, 242, 239, 250, 137, 255, 100, 241, 71, 241, 122, 243, 4, 242, 56, 240, 187, 242, 1, 242, 222, 254, 45, 244, 152, 247, 61, 234, 93, 234, 124, 233, 119, 234, 89, 235, 26, 236, 248, 235, 165, 235, 176, 235, 210, 235, 214, 235, 114, 235, 117, 240, 61, 242, 204, 236, 125, 238, 241, 236, 211, 236, 255, 235, 203, 234, 57, 235, 21, 235, 192, 239, 224, 239, 26, 239, 185, 238, 84, 237, 84, 240, 158, 236, 163, 237, 84, 239, 88, 239, 4, 236, 171, 236, 97, 236, 24, 236, 67, 236, 56, 237, 223, 236, 6, 237, 176, 237, 13, 235, 188, 227, 35, 226, 210, 232, 254, 232, 220, 233, 44, 234, 26, 234, 59, 234, 54, 234, 66, 235, 11, 235, 5, 234, 78, 233, 203, 232, 125, 234, 4, 233, 235, 232, 129, 233, 31, 234, 36, 233, 171, 236, 52, 237, 10, 237, 28, 237, 101, 236, 124, 238, 175, 237, 165, 236, 248, 240, 56, 235, 188, 236, 189, 237, 204, 236, 32, 236, 29, 237, 214, 234, 16, 236, 102, 234, 243, 237, 7, 238, 132, 235, 238, 236, 204, 234, 88, 240, 85, 237, 204, 237, 211, 234, 37, 234, 160, 234, 248, 235, 128, 235, 5, 235, 195, 235, 71, 235, 179, 234, 98, 235, 132, 235, 182, 237, 192, 235, 167, 236, 243, 232, 116, 236, 56, 236, 246, 232, 17, 235, 228, 234, 4, 234, 108, 236, 250, 234, 2, 235, 82, 234, 237, 234, 202, 234, 120, 239, 220, 235, 133, 235, 112, 233, 240, 234, 121, 234, 13, 235, 86, 236, 126, 236, 212, 233, 184, 239, 210, 233, 197, 233, 130, 234, 118, 235, 241, 234, 76, 234, 176, 239, 220, 237, 54, 238, 214, 237, 60, 239, 93, 238, 241, 236, 31, 236, 132, 237, 237, 235, 145, 237, 145, 237, 187, 236, 202, 238, 151, 237, 223, 236, 196, 235, 75, 236, 28, 237, 199, 236, 94, 237, 191, 237, 26, 237, 232, 237, 19, 238, 46, 238, 1, 235, 146, 234, 50, 235, 23, 235, 129, 234, 120, 234, 131, 235, 35, 234, 152, 234, 159, 236, 99, 236, 223, 237, 195, 236, 112, 236, 68, 236, 25, 236, 226, 236, 215, 235, 201, 234, 154, 236, 94, 235, 211, 235, 200, 235, 159, 234, 136, 235, 106, 235, 79, 236, 9, 236, 194, 235, 115, 237, 138, 235, 120, 235, 211, 234, 167, 234, 72, 236, 54, 236, 14, 236, 18, 236, 16, 236, 101, 236, 146, 236, 96, 236, 248, 235, 123, 235, 54, 236, 186, 236, 63, 237, 229, 235, 105, 236, 64, 235, 174, 236, 123, 238, 123, 235, 16, 236, 97, 237, 226, 236, 214, 236, 14, 236, 207, 235, 71, 236, 85, 236, 140, 236, 102, 236, 27, 236, 162, 236, 247, 235, 114, 236, 138, 238, 199, 236, 156, 236, 213, 238, 201, 240, 224, 240, 194, 238, 236, 243, 39, 239, 250, 239, 135, 237, 84, 237, 32, 238, 109, 237, 166, 236, 148, 238, 240, 237, 11, 240, 186, 236, 151, 237, 241, 238, 146, 238, 243, 237, 70, 238, 126, 239, 235, 236, 99, 238, 76, 237, 192, 240, 189, 236, 195, 237, 17, 241, 30, 238, 171, 234, 134, 235, 31, 236, 89, 235, 96, 237, 7, 236, 198, 236, 67, 235, 234, 236, 65, 235, 40, 235, 178, 235, 240, 234, 224, 233, 235, 234, 17, 236, 19, 237, 70, 237, 72, 237, 233, 236, 245, 236, 50, 237, 126, 236, 43, 236, 118, 235, 116, 236, 169, 234, 186, 234, 204, 235, 24, 235, 34, 235, 91, 236, 143, 234, 208, 235, 122, 235, 183, 237, 98, 238, 155, 237, 26, 237, 242, 237, 219, 237, 120, 238, 217, 238, 43, 238, 240, 235, 33, 236, 8, 236, 115, 237, 193, 240, 224, 234, 75, 236, 14, 236, 86, 236, 56, 238, 213, 235, 170, 235, 76, 237, 192, 236, 139, 238, 5, 236, 60, 237, 177, 234, 141, 237, 108, 235, 194, 234, 234, 234, 122, 238, 172, 237, 152, 237, 76, 238, 125, 237, 118, 235, 19, 237, 171, 236, 152, 238, 110, 238, 235, 235, 181, 236, 204, 235, 76, 237, 60, 236, 4, 236, 209, 235, 235, 236, 3, 236, 240, 235, 165, 236, 131, 235, 37, 237, 142, 235, 62, 234, 255, 234, 47, 235, 23, 236, 162, 235, 74, 235, 1, 235, 59, 235, 36, 234, 159, 234, 192, 234, 57, 235, 46, 238, 73, 234, 168, 236, 135, 235, 121, 235, 46, 235, 39, 237, 35, 237, 1, 235, 224, 235, 249, 235, 13, 235, 53, 235, 81, 234, 56, 234, 241, 236, 222, 234, 124, 235, 117, 235, 97, 236, 171, 234, 104, 234, 74, 234, 14, 235, 51, 235, 248, 235, 240, 234, 35, 236, 194, 235, 252, 235, 243, 234, 188, 235, 118, 235, 14, 236, 206, 235, 154, 235, 212, 235, 120, 235, 66, 236, 187, 233, 26, 236, 154, 236, 16, 235, 112, 235, 37, 235, 117, 235, 185, 235, 184, 234, 217, 234, 127, 235, 118, 235, 75, 236, 253, 235, 100, 233, 52, 236, 209, 235, 155, 236, 39, 237, 150, 239, 206, 241, 60, 237, 158, 238, 92, 238, 210, 239, 249, 238, 88, 239, 206, 238, 12, 237, 14, 238, 28, 238, 136, 236, 248, 236, 229, 238, 79, 239, 74, 238, 10, 239, 187, 237, 56, 238, 170, 241, 196, 240, 161, 240, 41, 240, 220, 240, 111, 239, 115, 239, 255, 240, 159, 241, 4, 242, 146, 239, 29, 240, 202, 239, 242, 240, 100, 240, 58, 240, 167, 238, 199, 236, 45, 239, 73, 239, 50, 239, 115, 238, 94, 240, 9, 240, 19, 240, 2, 240, 38, 238, 27, 238, 70, 235, 228, 236, 0, 239, 129, 238, 69, 239, 198, 230, 45, 237, 109, 239, 250, 237, 76, 239, 43, 237, 143, 235, 156, 241, 245, 241, 146, 241, 186, 240, 123, 241, 164, 241, 68, 240, 2, 241, 200, 239, 135, 238, 36, 239, 160, 240, 81, 238, 68, 240, 180, 238, 32, 239, 73, 237, 98, 240, 5, 240, 244, 240, 97, 240, 180, 239, 47, 237, 157, 238, 37, 239, 183, 237, 64, 239, 105, 240, 57, 239, 225, 238, 59, 245, 49, 247, 65, 245, 188, 245, 10, 246, 231, 243, 6, 244, 131, 240, 118, 243, 150, 240, 170, 243, 162, 250, 96, 243, 204, 242, 190, 242, 93, 242, 77, 243, 155, 242, 19, 244, 1, 244, 58, 248, 107, 245, 15, 244, 253, 245, 82, 243, 106, 244, 225, 238, 158, 238, 12, 242, 255, 239, 30, 240, 145, 239, 83, 240, 7, 239, 150, 239, 65, 242, 93, 241, 29, 242, 1, 242, 9, 242, 173, 242, 224, 241, 227, 240, 91, 240, 53, 240, 110, 240, 129, 240, 151, 239, 2, 241, 227, 238, 94, 241, 211, 238, 213, 240, 65, 240, 179, 240, 203, 239, 130, 241, 166, 241, 152, 242, 152, 242, 4, 243, 252, 241, 11, 243, 73, 242, 49, 242, 106, 243, 160, 242, 213, 243, 64, 242, 71, 241, 158, 244, 186, 244, 173, 243, 236, 242, 18, 244, 97, 243, 146, 245, 8, 245, 84, 244, 86, 242, 2, 243, 35, 243, 9, 241, 205, 242, 15, 242, 32, 243, 202, 242, 104, 243, 227, 243, 69, 243, 169, 243, 86, 244, 157, 243, 39, 247, 11, 246, 94, 244, 57, 245, 83, 243, 83, 244, 51, 243, 154, 241, 75, 241, 192, 241, 219, 240, 71, 241, 20, 242, 27, 244, 25, 243, 71, 245, 33, 246, 203, 245, 37, 244, 63, 245, 22, 244, 222, 238, 86, 240, 26, 238, 158, 242, 184, 238, 164, 238, 118, 239, 73, 239, 224, 240, 116, 243, 134, 245, 139, 243, 253, 237, 249, 237, 22, 240, 146, 239, 166, 236, 240, 238, 24, 240, 46, 242, 211, 241, 219, 242, 170, 245, 217, 241, 168, 241, 247, 243, 63, 243, 41, 244, 189, 242, 199, 242, 236, 242, 176, 241, 144, 241, 155, 241, 148, 241, 204, 239, 224, 240, 134, 239, 78, 237, 172, 239, 55, 238, 12, 239, 68, 238, 96, 237, 106, 239, 141, 238, 59, 239, 101, 237, 141, 237, 109, 237, 22, 239, 164, 237, 179, 238, 26, 238, 5, 238, 6, 238, 228, 241, 206, 241, 205, 241, 137, 240, 172, 240, 199, 241, 151, 240, 148, 240, 54, 240, 54, 238, 105, 239, 206, 239, 70, 243, 115, 242, 173, 242, 198, 243, 94, 243, 36, 241, 185, 239, 232, 239, 25, 241, 218, 240, 11, 237, 221, 239, 216, 237, 19, 238, 230, 238, 32, 240, 14, 240, 161, 239, 92, 243, 39, 243, 189, 242, 70, 242, 153, 241, 191, 244, 239, 245, 74, 245, 239, 244, 254, 245, 243, 243, 155, 243, 135, 241, 143, 241, 90, 241, 124, 242, 128, 244, 68, 243, 219, 243, 101, 243, 120, 243, 185, 242, 184, 238, 179, 239, 120, 240, 184, 239, 23, 240, 8, 242, 189, 241, 96, 241, 33, 242, 193, 242, 97, 241, 23, 240, 127, 243, 48, 243, 66, 241, 205, 243, 82, 242, 66, 243, 143, 241, 214, 239, 1, 240, 162, 240, 168, 237, 134, 242, 134, 238, 147, 239, 129, 244, 143, 242, 19, 242, 40, 244, 69, 242, 22, 243, 148, 242, 32, 242, 95, 244, 171, 242, 59, 245, 68, 243, 185, 245, 166, 243, 177, 244, 80, 243, 62, 245, 24, 245, 10, 244, 58, 243, 74, 243, 102, 244, 6, 245, 107, 243, 127, 245, 235, 244, 163, 243, 229, 243, 243, 241, 104, 246, 250, 242, 166, 242, 233, 243, 17, 246, 79, 245, 14, 244, 248, 238, 8, 239, 96, 238, 215, 238, 170, 238, 85, 237, 114, 238, 182, 238, 254, 238, 71, 239, 83, 238, 31, 238, 239, 238, 57, 239, 114, 239, 60, 239, 118, 238, 77, 239, 5, 239, 245, 238, 253, 238, 115, 239, 144, 238, 131, 237, 11, 241, 179, 238, 13, 239, 221, 237, 234, 237, 159, 241, 127, 240, 152, 240, 3, 238, 186, 240, 95, 239, 73, 240, 10, 240, 141, 239, 94, 238, 33, 238, 252, 237, 101, 238, 138, 237, 212, 238, 177, 238, 74, 238, 232, 237, 223, 237, 246, 241, 33, 242, 160, 241, 67, 241, 203, 241, 29, 242, 128, 242, 17, 239, 5, 240, 37, 240, 143, 238, 110, 240, 175, 242, 136, 240, 83, 240, 57, 241, 237, 241, 102, 243, 40, 241, 227, 241, 134, 242, 178, 242, 135, 240, 195, 240, 17, 241, 11, 241, 120, 238, 64, 238, 61, 239, 159, 238, 90, 238, 180, 240, 39, 240, 77, 240, 215, 240, 177, 239, 121, 238, 145, 237, 118, 239, 250, 238, 173, 240, 91, 238, 248, 238, 19, 238, 159, 238, 198, 239, 81, 238, 61, 239, 55, 238, 255, 255, 241, 255, 159, 238, 84, 243, 17, 241, 91, 241, 160, 246, 158, 239, 193, 238, 56, 239, 144, 239, 31, 245, 56, 244, 203, 248, 206, 244, 83, 243, 165, 245, 34, 248, 78, 239, 122, 246, 244, 249, 195, 241, 254, 240, 235, 240, 97, 241, 36, 243, 82, 241, 112, 239, 246, 241, 185, 239, 109, 238, 7, 241, 237, 238, 153, 241, 118, 246, 74, 246, 121, 241, 101, 242, 229, 240, 69, 244, 177, 244, 67, 239, 239, 240, 145, 241, 79, 239, 196, 240, 138, 244, 25, 240, 126, 241, 239, 240, 139, 247, 91, 241, 43, 238, 238, 239, 197, 239, 148, 239, 72, 239, 154, 238, 196, 241, 56, 239, 106, 239, 56, 240, 91, 240, 174, 239, 1, 240, 171, 239, 38, 239, 0, 239, 19, 240, 48, 239, 57, 239, 199, 238, 223, 241, 92, 238, 73, 239, 51, 239, 247, 238, 30, 251, 135, 241, 104, 238, 243, 245, 30, 241, 252, 238, 232, 238, 234, 239, 69, 242, 0, 0, 10, 247, 111, 244, 58, 247, 206, 241, 60, 241, 158, 244, 251, 242, 214, 246, 22, 245, 20, 244, 127, 246, 220, 245, 251, 242, 188, 243, 190, 242, 33, 244, 179, 242, 147, 246, 32, 243, 184, 245, 25, 243, 171, 244, 112, 244, 194, 241, 236, 241, 141, 242, 31, 243, 163, 242, 225, 244, 175, 242, 25, 245, 235, 247, 5, 244, 252, 243, 145, 242, 145, 242, 77, 242, 128, 242, 161, 244, 254, 241, 210, 242, 20, 242, 149, 243, 99, 242, 65, 242, 153, 241, 42, 242, 187, 241, 212, 241, 35, 242, 240, 243, 165, 243, 60, 243, 61, 243, 55, 243, 197, 242, 223, 242, 66, 242, 241, 241, 166, 242, 84, 241, 47, 242, 136, 241, 226, 241, 75, 242, 170, 240, 69, 241, 40, 243, 196, 242, 153, 242, 11, 242, 196, 242, 6, 245, 168, 242, 113, 245, 151, 241, 218, 241, 135, 241, 182, 239, 228, 240, 106, 241, 114, 241, 146, 241, 155, 240, 226, 242, 6, 241, 40, 242, 173, 241, 100, 243, 127, 243, 58, 243, 147, 243, 31, 243, 233, 242, 218, 243, 232, 242, 226, 242, 214, 242, 38, 243, 57, 242, 178, 242, 57, 244, 185, 243, 110, 243, 163, 243, 18, 242, 205, 243, 202, 244, 58, 240, 103, 240, 236, 239, 82, 240, 61, 240, 174, 239, 144, 240, 79, 240, 162, 240, 152, 240, 202, 239, 40, 240, 57, 240, 153, 240, 215, 239, 220, 239, 175, 240, 229, 241, 108, 240, 98, 240, 151, 240, 200, 240, 85, 242, 0, 240, 143, 241, 42, 242, 22, 241, 126, 241, 210, 240, 247, 240, 64, 241, 215, 239, 105, 240, 75, 240, 238, 238, 49, 239, 239, 240, 54, 241, 75, 239, 126, 239, 118, 241, 105, 239, 54, 239, 222, 238, 7, 242, 193, 241, 167, 241, 66, 241, 75, 241, 186, 240, 231, 240, 2, 241, 154, 241, 233, 241, 148, 241, 140, 241, 96, 242, 19, 242, 242, 241, 12, 241, 75, 241, 25, 241, 21, 242, 81, 241, 148, 241, 101, 241, 90, 240, 2, 240, 163, 239, 219, 240, 121, 240, 119, 241, 87, 241, 144, 242, 107, 242, 102, 240, 217, 240, 40, 240, 247, 239, 250, 240, 245, 240, 120, 240, 59, 241, 107, 240, 154, 239, 160, 240, 60, 240, 198, 239, 50, 238, 235, 237, 48, 237, 174, 237, 239, 238, 102, 236, 138, 238, 47, 238, 149, 236, 17, 236, 126, 239, 48, 237, 16, 236, 0, 237, 133, 237, 219, 237, 20, 238, 143, 238, 129, 237, 23, 237, 72, 236, 162, 236, 51, 236, 74, 236, 187, 237, 70, 235, 91, 235, 192, 235, 246, 235, 10, 237, 21, 236, 138, 236, 253, 235, 182, 236, 33, 237, 133, 238, 1, 238, 223, 236, 169, 236, 4, 237, 161, 237, 227, 236, 246, 235, 135, 238, 106, 235, 174, 235, 19, 234, 45, 236, 251, 233, 170, 235, 143, 234, 197, 235, 119, 235, 143, 235, 146, 234, 41, 235, 215, 234, 74, 233, 20, 236, 206, 234, 172, 235, 31, 234, 43, 235, 76, 235, 254, 234, 209, 234, 226, 234, 10, 234, 52, 235, 175, 234, 27, 237, 152, 235, 70, 238, 177, 235, 117, 235, 196, 235, 219, 234, 222, 234, 160, 234, 218, 234, 93, 236, 50, 236, 0, 236, 139, 235, 249, 234, 135, 235, 131, 234, 26, 236, 133, 244, 162, 244, 227, 247, 37, 241, 21, 243, 230, 242, 157, 241, 146, 242, 221, 241, 230, 242, 98, 241, 59, 242, 195, 240, 213, 240, 190, 243, 183, 241, 124, 241, 28, 243, 71, 242, 157, 242, 213, 242, 39, 243, 116, 241, 226, 240, 140, 240, 222, 240, 28, 241, 158, 241, 64, 240, 202, 240, 8, 239, 131, 241, 204, 241, 216, 241, 201, 241, 39, 240, 11, 243, 58, 240, 213, 241, 91, 243, 1, 242, 32, 242, 7, 242, 195, 241, 23, 241, 54, 240, 203, 240, 202, 240, 16, 238, 97, 237, 138, 240, 154, 240, 203, 238, 183, 239, 49, 238, 40, 240, 173, 239, 145, 239, 5, 242, 189, 239, 176, 240, 136, 239, 181, 239, 228, 239, 142, 239, 69, 238, 206, 238, 139, 237, 241, 240, 146, 238, 43, 239, 155, 239, 124, 240, 11, 239, 87, 241, 64, 243, 113, 241, 105, 242, 176, 241, 191, 239, 14, 240, 225, 242, 164, 239, 66, 246, 182, 240, 196, 240, 32, 241, 96, 240, 204, 239, 77, 241, 126, 240, 162, 241, 46, 239, 33, 237, 235, 237, 57, 238, 225, 240, 117, 240, 126, 239, 149, 236, 0, 252, 194, 239, 88, 241, 0, 237, 212, 239, 109, 239, 0, 238, 47, 240, 249, 237, 91, 238, 93, 237, 76, 237, 205, 235, 181, 237, 139, 236, 99, 236, 51, 236, 242, 237, 144, 235, 241, 238, 79, 236, 46, 239, 148, 239, 97, 238, 100, 237, 207, 236, 181, 238, 119, 236, 46, 236, 132, 236, 8, 238, 99, 238, 235, 236, 40, 238, 61, 239, 241, 237, 109, 237, 3, 236, 101, 237, 168, 236, 239, 240, 122, 239, 100, 240, 176, 240, 230, 239, 94, 240, 89, 239, 148, 238, 92, 239, 171, 239, 52, 239, 200, 238, 39, 240, 180, 239, 151, 240, 18, 241, 144, 239, 73, 239, 123, 239, 135, 238, 42, 239, 7, 239, 74, 239, 125, 239, 216, 239, 199, 239, 177, 249, 13, 246, 193, 246, 84, 242, 224, 238, 135, 240, 186, 238, 37, 241, 116, 240, 25, 246, 201, 238, 151, 238, 109, 237, 125, 238, 71, 238, 217, 242, 219, 239, 194, 239, 192, 236, 46, 237, 150, 238, 242, 236, 146, 236, 99, 243, 99, 239, 226, 236, 227, 238, 251, 238, 226, 236, 37, 238, 0, 236, 71, 235, 34, 236, 232, 236, 101, 236, 40, 236, 247, 236, 20, 238, 73, 237, 48, 236, 80, 242, 23, 240, 197, 239, 96, 240, 47, 240, 56, 240, 15, 240, 56, 239, 56, 239, 0, 239, 20, 240, 12, 239, 148, 247, 19, 241, 44, 239, 61, 240, 36, 239, 41, 240, 8, 242, 103, 239, 97, 240, 93, 239, 37, 236, 149, 235, 52, 235, 92, 236, 92, 235, 79, 236, 129, 236, 49, 237, 252, 235, 240, 236, 54, 235, 215, 236, 199, 236, 3, 238, 191, 237, 208, 236, 146, 238, 46, 237, 16, 237, 153, 234, 188, 235, 251, 237, 18, 241, 111, 238, 218, 238, 121, 239, 132, 237, 223, 238, 111, 237, 6, 238, 201, 237, 222, 237, 115, 236, 231, 236, 250, 236, 72, 238, 54, 238, 12, 239, 160, 237, 168, 237, 53, 244, 74, 245, 220, 242, 164, 1, 67, 2, 205, 252, 186, 245, 247, 255, 220, 252, 120, 252, 204, 243, 218, 255, 19, 247, 1, 247, 164, 247, 187, 248, 221, 255, 70, 248, 152, 254, 17, 248, 78, 245, 174, 247, 166, 255, 161, 255, 69, 242, 237, 255, 27, 0, 168, 254, 16, 251, 10, 247, 164, 0, 76, 254, 237, 0, 196, 255, 37, 0, 31, 1, 172, 0, 236, 252, 145, 245, 99, 247, 248, 229, 19, 234, 226, 252, 183, 243, 23, 252, 54, 250, 6, 251, 64, 254, 176, 243, 207, 253, 236, 236, 57, 239, 68, 235, 159, 243, 222, 242, 169, 234, 125, 236, 92, 240, 16, 241, 247, 238, 61, 234, 224, 234, 241, 238, 91, 240, 161, 240, 153, 243, 62, 237, 158, 237, 171, 239, 168, 242, 231, 239, 11, 246, 87, 247, 23, 239, 129, 0, 209, 255, 34, 252, 163, 252, 123, 249, 37, 237, 148, 243, 240, 239, 196, 3, 112, 0, 72, 238, 66, 254, 246, 245, 231, 241, 101, 239, 1, 0, 87, 250, 227, 253, 29, 252, 243, 250, 210, 249, 53, 251, 145, 250, 58, 248, 206, 255, 79, 0, 87, 246, 18, 0, 138, 246, 185, 248, 175, 250, 186, 240, 52, 242, 132, 239, 144, 0, 51, 0, 225, 0, 243, 255, 207, 255, 236, 255, 246, 243, 221, 247, 39, 244, 54, 245, 86, 245, 83, 250, 67, 247, 130, 247, 186, 255, 129, 248, 1, 252, 47, 251, 248, 249, 178, 4, 93, 0, 61, 0, 51, 8, 44, 2, 82, 8, 223, 246, 15, 0, 56, 249, 91, 251, 0, 253, 149, 10, 10, 250, 197, 10, 204, 255, 199, 4, 13, 3, 130, 7, 230, 247, 139, 0, 230, 248, 208, 255, 217, 255, 198, 255, 211, 255, 240, 255, 225, 255, 9, 0, 219, 255, 187, 255, 230, 255, 201, 255, 246, 255, 194, 255, 203, 255, 16, 2, 45, 0, 70, 0, 0, 0, 14, 0, 18, 0, 33, 0, 40, 0, 10, 0, 211, 255, 231, 255, 224, 255, 227, 255, 207, 255, 213, 253, 6, 249, 231, 249, 143, 0, 55, 0, 54, 0, 164, 3, 34, 0, 18, 0, 0, 0, 232, 255, 245, 255, 243, 255, 245, 255, 248, 255, 253, 255, 59, 242, 180, 230, 74, 253, 158, 238, 171, 233, 53, 234, 151, 226, 37, 247, 215, 236, 88, 226, 85, 241, 61, 225, 230, 240, 225, 242, 222, 251, 111, 235, 192, 237, 6, 234, 114, 234, 236, 233, 34, 241, 235, 233, 217, 231, 18, 243, 145, 231, 74, 228, 237, 236, 215, 237, 187, 240, 100, 248, 223, 228, 174, 237, 74, 239, 239, 242, 127, 241, 47, 240, 238, 241, 63, 245, 189, 240, 227, 240, 157, 244, 58, 244, 43, 241, 201, 246, 66, 230, 21, 244, 165, 240, 66, 237, 36, 253, 208, 249, 94, 243, 106, 239, 46, 239, 194, 238, 242, 237, 105, 239, 111, 238, 27, 239, 56, 238, 219, 237, 36, 238, 165, 244, 193, 247, 85, 252, 142, 238, 72, 248, 241, 255, 7, 242, 130, 239, 170, 240, 79, 244, 14, 243, 33, 247, 235, 239, 155, 239, 179, 237, 24, 249, 52, 241, 153, 239, 17, 239, 26, 238, 160, 238, 80, 243, 58, 242, 61, 232, 31, 218, 72, 236, 89, 248, 145, 248, 150, 243, 63, 240, 126, 247, 58, 245, 48, 246, 234, 241, 220, 249, 215, 250, 48, 240, 115, 240, 54, 238, 224, 255, 211, 255, 213, 255, 213, 255, 187, 255, 253, 0, 70, 9, 204, 3, 116, 6, 157, 0, 19, 0, 255, 255, 160, 254, 240, 254, 207, 6, 11, 255, 3, 0, 19, 0, 176, 0, 249, 255, 52, 15, 21, 0, 155, 239, 107, 239, 41, 240, 151, 246, 171, 247, 139, 245, 95, 243, 158, 244, 199, 244, 178, 243, 55, 240, 133, 239, 110, 249, 146, 0, 47, 253, 155, 245, 165, 241, 124, 245, 177, 243, 217, 242, 192, 244, 43, 242, 60, 243, 91, 237, 220, 237, 226, 236, 41, 239, 124, 238, 142, 239, 190, 238, 51, 240, 6, 239, 61, 239, 84, 237, 136, 239, 116, 240, 111, 239, 48, 239, 0, 239, 53, 239, 40, 238, 85, 239, 21, 238, 211, 238, 164, 0, 213, 243, 40, 242, 1, 255, 217, 252, 251, 240, 214, 238, 197, 239, 56, 242, 192, 243, 114, 236, 148, 245, 240, 238, 220, 239, 11, 240, 146, 243, 251, 241, 47, 241, 55, 242, 216, 241, 176, 242, 200, 240, 146, 239, 70, 241, 191, 242, 19, 239, 183, 239, 204, 238, 191, 240, 65, 242, 35, 244, 248, 244, 250, 238, 248, 239, 237, 239, 80, 241, 86, 237, 8, 241, 56, 239, 220, 238, 56, 0, 172, 255, 63, 244, 217, 0, 50, 251, 205, 246, 10, 241, 24, 244, 130, 244, 108, 243, 46, 249, 234, 242, 155, 245, 136, 244, 108, 244, 3, 245, 127, 241, 18, 242, 156, 241, 19, 241, 196, 238, 177, 239, 190, 240, 36, 246, 36, 246, 102, 242, 187, 241, 199, 244, 103, 253, 234, 241, 83, 245, 144, 245, 58, 252, 169, 243, 255, 244, 20, 245, 178, 241, 107, 240, 74, 243, 27, 244, 246, 247, 89, 239, 51, 244, 133, 248, 196, 243, 251, 249, 196, 241, 236, 240, 31, 240, 193, 247, 17, 248, 160, 248, 56, 239, 158, 238, 5, 239, 115, 238, 147, 238, 151, 246, 182, 237, 128, 239, 210, 243, 27, 239, 247, 244, 4, 238, 6, 239, 188, 238, 207, 238, 141, 238, 245, 237, 77, 238, 179, 234, 158, 234, 51, 236, 94, 236, 142, 236, 92, 235, 93, 235, 220, 236, 170, 235, 216, 238, 115, 235, 51, 235, 183, 234, 0, 236, 179, 235, 177, 235, 12, 235, 199, 243, 99, 234, 218, 233, 29, 234, 243, 234, 150, 234, 123, 235, 119, 235, 76, 235, 97, 245, 105, 243, 207, 242, 116, 241, 124, 247, 21, 247, 53, 240, 237, 237, 83, 242, 33, 247, 198, 241, 171, 242, 32, 237, 126, 239, 69, 236, 183, 242, 116, 244, 251, 242, 153, 241, 118, 239, 167, 236, 128, 237, 170, 238, 102, 241, 239, 234, 183, 235, 207, 234, 179, 237, 194, 235, 72, 240, 208, 247, 49, 246, 122, 244, 232, 243, 75, 245, 209, 246, 219, 244, 113, 255, 149, 237, 152, 237, 32, 237, 91, 236, 214, 238, 215, 243, 40, 244, 223, 246, 134, 239, 96, 245, 124, 245, 151, 243, 27, 242, 243, 245, 75, 243, 232, 243, 93, 245, 68, 245, 174, 234, 164, 237, 201, 234, 78, 234, 120, 233, 249, 243, 81, 236, 223, 236, 110, 236, 160, 234, 135, 237, 10, 236, 73, 237, 128, 236, 79, 236, 148, 235, 86, 237, 161, 234, 137, 252, 92, 253, 67, 253, 214, 249, 218, 251, 173, 253, 208, 251, 153, 250, 168, 243, 64, 249, 229, 243, 216, 247, 189, 245, 230, 250, 198, 246, 236, 242, 193, 239, 210, 242, 180, 238, 63, 238, 137, 246, 85, 242, 213, 245, 246, 246, 226, 244, 98, 248, 160, 247, 255, 250, 82, 248, 23, 248, 245, 245, 11, 252, 149, 246, 211, 255, 9, 243, 186, 241, 218, 255, 99, 242, 101, 243, 33, 242, 102, 242, 246, 245, 165, 249, 43, 250, 161, 247, 77, 246, 153, 254, 105, 253, 64, 248, 20, 250, 19, 254, 21, 248, 59, 243, 130, 239, 166, 241, 41, 241, 0, 232, 151, 236, 156, 238, 168, 240, 168, 239, 103, 239, 32, 243, 217, 243, 84, 244, 182, 242, 223, 242, 155, 237, 72, 243, 29, 253, 51, 239, 178, 240, 154, 238, 118, 241, 53, 239, 33, 239, 213, 238, 34, 238, 175, 238, 156, 244, 101, 246, 252, 245, 250, 247, 245, 255, 48, 246, 108, 245, 119, 243, 199, 240, 85, 238, 148, 238, 182, 243, 71, 243, 94, 243, 173, 244, 204, 245, 200, 242, 216, 245, 28, 244, 81, 242, 66, 242, 27, 243, 197, 244, 82, 251, 189, 249, 5, 242, 26, 240, 16, 244, 127, 244, 178, 243, 233, 242, 78, 244, 39, 245, 140, 245, 0, 244, 68, 245, 40, 245, 97, 243, 150, 244, 255, 244, 142, 244, 71, 249, 171, 247, 248, 248, 121, 240, 235, 235, 241, 250, 76, 245, 186, 237, 120, 241, 254, 251, 168, 244, 249, 252, 26, 241, 56, 250, 52, 243, 246, 242, 66, 244, 206, 243, 133, 243, 195, 240, 165, 247, 56, 234, 108, 250, 48, 248, 6, 245, 255, 248, 195, 241, 90, 245, 47, 242, 20, 243, 220, 246, 147, 240, 201, 232, 30, 248, 70, 249, 197, 249, 74, 247, 197, 237, 0, 0, 139, 245, 195, 239, 235, 243, 243, 240, 48, 1, 211, 249, 223, 1, 212, 245, 129, 243, 172, 242, 14, 243, 104, 242, 87, 239, 245, 241, 136, 237, 60, 239, 75, 0, 66, 244, 20, 244, 109, 244, 9, 247, 208, 253, 215, 245, 186, 249, 206, 243, 78, 236, 202, 235, 205, 234, 172, 235, 224, 234, 69, 232, 239, 233, 255, 233, 228, 232, 232, 232, 41, 234, 202, 235, 220, 233, 160, 233, 75, 235, 53, 234, 142, 233, 155, 234, 199, 234, 3, 236, 183, 234, 208, 236, 26, 233, 231, 231, 65, 233, 86, 232, 105, 231, 148, 232, 80, 233, 116, 236, 87, 234, 144, 233, 40, 233, 197, 232, 111, 233, 142, 233, 127, 232, 7, 233, 230, 232, 131, 232, 119, 233, 171, 232, 90, 232, 245, 231, 174, 232, 109, 231, 218, 232, 134, 232, 241, 236, 136, 236, 89, 237, 96, 238, 235, 238, 90, 241, 191, 239, 153, 233, 15, 235, 15, 251, 245, 241, 241, 236, 146, 245, 81, 243, 9, 236, 197, 240, 228, 235, 18, 243, 34, 240, 160, 241, 206, 243, 160, 244, 54, 244, 206, 237, 102, 243, 151, 240, 42, 232, 133, 232, 183, 232, 114, 232, 212, 232, 109, 236, 9, 235, 73, 234, 145, 233, 27, 233, 194, 234, 232, 232, 31, 233, 118, 233, 243, 234, 3, 233, 79, 234, 34, 233, 29, 235, 19, 235, 195, 243, 101, 240, 114, 232, 118, 234, 67, 234, 60, 232, 177, 237, 192, 231, 32, 234, 11, 233, 92, 233, 248, 233, 50, 234, 121, 233, 99, 233, 170, 233, 209, 234, 140, 236, 87, 236, 158, 233, 61, 234, 16, 252, 36, 234, 237, 233, 236, 237, 227, 236, 225, 235, 201, 234, 82, 235, 141, 236, 151, 241, 43, 243, 29, 238, 186, 237, 98, 250, 113, 235, 25, 235, 207, 233, 213, 233, 104, 233, 146, 239, 47, 245, 95, 232, 22, 233, 34, 233, 170, 233, 168, 233, 11, 236, 139, 236, 69, 234, 41, 239, 2, 235, 89, 237, 185, 236, 127, 234, 11, 234, 96, 234, 228, 234, 13, 235, 64, 243, 85, 236, 125, 239, 232, 234, 186, 233, 230, 236, 222, 234, 170, 234, 80, 234, 146, 235, 7, 237, 46, 235, 69, 243, 176, 237, 8, 241, 74, 236, 24, 239, 11, 250, 116, 235, 168, 239, 253, 235, 243, 232, 119, 233, 90, 233, 35, 233, 132, 233, 109, 234, 180, 233, 248, 233, 45, 234, 181, 233, 225, 239, 80, 233, 95, 237, 207, 234, 190, 233, 164, 233, 154, 233, 171, 233, 131, 234, 201, 234, 137, 234, 114, 234, 240, 234, 234, 234, 1, 234, 54, 234, 132, 233, 132, 233, 73, 234, 174, 234, 181, 233, 157, 233, 124, 238, 32, 236, 28, 237, 164, 238, 103, 236, 89, 236, 121, 235, 229, 235, 26, 238, 186, 233, 31, 232, 41, 234, 28, 235, 151, 234, 160, 234, 82, 247, 137, 237, 229, 241, 144, 232, 153, 235, 159, 233, 124, 233, 77, 235, 244, 233, 98, 235, 86, 235, 153, 233, 237, 234, 204, 231, 197, 231, 218, 234, 86, 233, 92, 236, 52, 235, 235, 233, 163, 233, 101, 234, 243, 233, 56, 237, 103, 238, 215, 236, 90, 239, 94, 239, 163, 236, 72, 239, 145, 238, 104, 237, 6, 246, 227, 238, 69, 238, 169, 242, 144, 241, 54, 237, 215, 240, 208, 238, 53, 241, 119, 235, 75, 238, 222, 235, 185, 237, 192, 238, 89, 239, 141, 236, 49, 237, 176, 237, 201, 238, 72, 243, 210, 245, 86, 233, 19, 235, 120, 236, 76, 235, 128, 239, 108, 234, 70, 236, 245, 235, 139, 234, 110, 235, 225, 241, 149, 234, 105, 235, 216, 235, 115, 236, 206, 234, 45, 235, 80, 236, 214, 232, 125, 234, 61, 233, 82, 233, 236, 232, 138, 234, 114, 246, 28, 237, 224, 246, 45, 242, 189, 236, 178, 234, 186, 233, 5, 234, 183, 233, 241, 234, 47, 235, 158, 234, 108, 235, 22, 234, 105, 235, 243, 232, 12, 238, 218, 246, 164, 251, 140, 243, 150, 235, 220, 234, 12, 235, 92, 235, 97, 234, 130, 240, 14, 237, 49, 236, 65, 235, 220, 234, 107, 235, 79, 235, 198, 235, 11, 238, 181, 233, 96, 236, 49, 243, 252, 235, 139, 239, 35, 241, 20, 239, 223, 239, 83, 240, 189, 245, 211, 242, 141, 236, 235, 240, 6, 246, 79, 240, 47, 240, 46, 234, 183, 233, 71, 235, 184, 234, 41, 235, 244, 233, 179, 234, 86, 237, 23, 235, 71, 237, 103, 236, 216, 234, 141, 237, 255, 247, 159, 236, 235, 233, 15, 235, 206, 233, 186, 233, 133, 234, 198, 237, 8, 235, 15, 235, 73, 248, 250, 240, 213, 234, 185, 234, 118, 235, 13, 253, 17, 245, 131, 251, 130, 251, 199, 239, 137, 247, 213, 240, 176, 238, 81, 238, 167, 242, 244, 237, 50, 238, 149, 248, 55, 0, 92, 237, 19, 243, 188, 252, 210, 247, 167, 239, 236, 237, 0, 238, 233, 237, 195, 248, 149, 245, 35, 245, 101, 243, 11, 249, 111, 249, 215, 233, 104, 247, 178, 242, 200, 248, 158, 0, 217, 252, 185, 244, 45, 246, 249, 245, 59, 250, 88, 247, 3, 248, 84, 245, 92, 243, 187, 243, 117, 248, 244, 240, 212, 249, 40, 246, 233, 242, 13, 250, 11, 233, 243, 247, 2, 248, 95, 247, 125, 255, 138, 0, 0, 255, 79, 232, 248, 230, 43, 231, 40, 237, 50, 252, 196, 249, 202, 247, 100, 252, 20, 243, 149, 255, 158, 244, 26, 245, 152, 234, 57, 243, 101, 230, 143, 247, 220, 0, 43, 248, 72, 245, 218, 242, 145, 249, 46, 252, 201, 244, 101, 0, 202, 237, 137, 224, 20, 243, 190, 243, 0, 0, 138, 249, 208, 246, 208, 254, 10, 237, 10, 239, 199, 239, 236, 243, 218, 234, 71, 236, 120, 235, 137, 234, 9, 239, 212, 238, 238, 238, 1, 243, 21, 240, 250, 239, 224, 240, 25, 236, 224, 239, 242, 239, 40, 239, 112, 237, 162, 239, 76, 238, 192, 237, 73, 237, 80, 237, 202, 236, 219, 235, 190, 235, 144, 237, 14, 236, 221, 236, 91, 236, 197, 236, 247, 238, 132, 239, 14, 239, 145, 238, 230, 239, 213, 238, 206, 238, 137, 239, 86, 238, 232, 238, 161, 238, 195, 236, 142, 239, 36, 239, 104, 239, 200, 238, 134, 237, 140, 237, 23, 237, 19, 243, 240, 241, 195, 242, 248, 240, 254, 241, 96, 241, 190, 247, 23, 242, 164, 242, 45, 242, 26, 243, 139, 242, 254, 243, 87, 245, 229, 238, 119, 238, 175, 238, 191, 242, 153, 239, 6, 244, 80, 240, 130, 239, 144, 241, 111, 244, 84, 243, 153, 243, 188, 239, 153, 238, 135, 240, 58, 239, 178, 238, 225, 238, 135, 239, 86, 239, 39, 239, 180, 239, 114, 240, 207, 238, 45, 240, 15, 240, 205, 239, 226, 238, 103, 239, 99, 238, 183, 244, 56, 233, 234, 233, 71, 233, 69, 232, 98, 235, 122, 233, 201, 232, 249, 232, 102, 233, 55, 233, 186, 232, 81, 232, 40, 232, 85, 232, 115, 232, 221, 232, 122, 232, 152, 232, 74, 232, 147, 232, 124, 232, 44, 244, 167, 240, 50, 237, 40, 237, 77, 236, 76, 239, 229, 235, 205, 242, 96, 242, 20, 243, 168, 237, 251, 243, 206, 241, 30, 240, 222, 239, 124, 238, 229, 255, 0, 242, 27, 240, 165, 244, 96, 244, 225, 238, 61, 238, 210, 238, 221, 237, 10, 240, 179, 236, 62, 237, 173, 248, 165, 240, 190, 241, 209, 236, 176, 243, 247, 248, 200, 232, 2, 235, 246, 233, 16, 236, 248, 233, 155, 234, 36, 243, 168, 246, 8, 241, 9, 237, 188, 247, 134, 238, 124, 236, 224, 237, 122, 236, 60, 235, 112, 235, 175, 237, 93, 243, 74, 240, 252, 255, 5, 235, 93, 234, 165, 239, 253, 235, 216, 255, 25, 238, 194, 237, 209, 232, 106, 233, 22, 233, 145, 233, 236, 234, 243, 235, 182, 234, 105, 234, 37, 243, 191, 243, 106, 242, 112, 244, 73, 246, 151, 238, 29, 239, 235, 245, 246, 239, 87, 245, 177, 239, 20, 246, 141, 249, 201, 249, 187, 248, 0, 0, 107, 247, 173, 248, 231, 246, 3, 245, 88, 248, 193, 248, 38, 236, 172, 237, 133, 238, 195, 236, 149, 237, 44, 244, 40, 244, 219, 241, 32, 241, 195, 242, 107, 240, 81, 239, 231, 238, 225, 238, 153, 238, 176, 238, 91, 241, 130, 239, 117, 241, 17, 239, 85, 242, 151, 239, 186, 236, 135, 237, 48, 238, 117, 238, 244, 239, 217, 248, 182, 247, 189, 247, 16, 248, 102, 248, 117, 244, 253, 255, 144, 245, 46, 244, 159, 242, 188, 244, 229, 246, 100, 245, 21, 245, 163, 239, 147, 245, 12, 241, 192, 238, 245, 243, 255, 240, 197, 241, 140, 245, 83, 244, 104, 247, 114, 246, 148, 245, 208, 245, 47, 249, 113, 247, 121, 248, 129, 249, 28, 248, 192, 245, 102, 247, 210, 245, 86, 238, 148, 236, 26, 239, 248, 238, 30, 239, 226, 241, 61, 242, 94, 241, 3, 243, 96, 243, 199, 239, 66, 241, 52, 243, 61, 242, 178, 240, 113, 242, 77, 244, 187, 245, 26, 244, 11, 241, 119, 243, 226, 239, 94, 250, 204, 242, 155, 239, 76, 240, 171, 241, 145, 240, 183, 240, 228, 238, 87, 240, 83, 238, 29, 242, 83, 241, 157, 240, 200, 239, 4, 241, 101, 241, 69, 244, 116, 243, 74, 241, 51, 241, 190, 242, 8, 244, 131, 241, 32, 240, 237, 240, 141, 239, 214, 239, 86, 240, 255, 238, 107, 239, 160, 239, 151, 239, 73, 239, 123, 240, 56, 239, 123, 238, 198, 238, 2, 239, 90, 238, 156, 238, 255, 237, 228, 237, 97, 237, 233, 238, 92, 238, 229, 238, 211, 237, 35, 238, 0, 238, 219, 238, 125, 238, 187, 238, 197, 242, 162, 243, 174, 244, 123, 243, 177, 244, 138, 237, 119, 237, 84, 242, 172, 241, 103, 241, 252, 241, 39, 241, 77, 242, 151, 238, 187, 237, 114, 241, 94, 237, 242, 239, 246, 243, 201, 238, 96, 239, 136, 239, 245, 238, 172, 238, 114, 238, 230, 240, 126, 240, 230, 240, 196, 239, 21, 240, 6, 240, 58, 240, 92, 240, 200, 239, 217, 238, 107, 238, 116, 238, 109, 238, 75, 239, 218, 238, 52, 239, 108, 239, 109, 239, 88, 239, 10, 0, 101, 255, 216, 244, 3, 0, 252, 255, 189, 0, 109, 242, 193, 242, 220, 241, 203, 250, 194, 252, 35, 1, 130, 0, 148, 253, 75, 0, 26, 1, 247, 255, 25, 0, 129, 241, 104, 241, 42, 241, 225, 241, 175, 241, 1, 242, 160, 242, 55, 241, 244, 244, 62, 255, 249, 250, 210, 241, 12, 241, 106, 245, 123, 237, 70, 239, 38, 244, 38, 241, 88, 241, 78, 238, 19, 238, 179, 239, 89, 239, 232, 238, 4, 238, 131, 237, 37, 248, 109, 246, 229, 245, 116, 242, 47, 243, 239, 245, 169, 239, 166, 244, 126, 240, 255, 238, 93, 243, 39, 240, 181, 240, 246, 255, 181, 240, 35, 240, 226, 239, 147, 244, 93, 239, 32, 243, 210, 255, 29, 2, 169, 238, 128, 239, 44, 239, 204, 238, 7, 239, 172, 241, 19, 239, 165, 239, 74, 0, 246, 0, 29, 0, 57, 0, 159, 0, 114, 0, 234, 0, 69, 255, 230, 255, 3, 0, 59, 0, 226, 255, 6, 0, 28, 0, 164, 0, 225, 0, 189, 0, 93, 0, 222, 0, 186, 0, 69, 0, 52, 0, 29, 0, 9, 0, 36, 0, 133, 0, 204, 240, 61, 241, 40, 241, 130, 241, 216, 240, 0, 242, 114, 242, 142, 246, 131, 241, 9, 245, 181, 242, 43, 242, 111, 244, 179, 240, 188, 241, 12, 244, 246, 246, 180, 248, 99, 243, 39, 245, 156, 243, 143, 244, 52, 243, 233, 241, 193, 242, 43, 244, 150, 0, 99, 2, 231, 0, 60, 2, 136, 2, 23, 2, 155, 1, 131, 1, 180, 1, 86, 2, 242, 0, 15, 1, 31, 3, 18, 2, 107, 2, 255, 1, 76, 2, 129, 1, 27, 255, 218, 255, 121, 252, 29, 2, 172, 2, 85, 2, 254, 255, 156, 0, 89, 2, 139, 2, 242, 1, 244, 1, 137, 253, 126, 253, 249, 246, 203, 255, 58, 0, 232, 250, 202, 255, 160, 255, 152, 255, 124, 255, 229, 0, 166, 0, 253, 255, 23, 0, 0, 0, 166, 255, 221, 255, 36, 0, 22, 247, 212, 245, 145, 246, 251, 254, 103, 249, 17, 250, 103, 248, 107, 247, 160, 244, 39, 245, 207, 246, 193, 245, 113, 240, 243, 237, 61, 241, 4, 241, 234, 244, 183, 240, 127, 252, 152, 246, 0, 0, 125, 254, 219, 1, 54, 2, 241, 1, 12, 3, 76, 2, 234, 247, 172, 255, 235, 255, 216, 255, 214, 250, 177, 0, 82, 2, 178, 0, 199, 255, 173, 0, 108, 1, 247, 254, 18, 0, 249, 255, 71, 3, 72, 3, 145, 2, 116, 240, 165, 239, 35, 240, 143, 240, 101, 240, 222, 237, 58, 238, 251, 238, 178, 238, 136, 238, 185, 238, 56, 239, 68, 243, 170, 248, 49, 240, 15, 240, 202, 242, 31, 240, 64, 239, 143, 239, 48, 239, 196, 239, 93, 250, 23, 247, 92, 246, 78, 245, 16, 249, 123, 249, 54, 249, 206, 252, 196, 248, 197, 247, 182, 239, 128, 247, 200, 240, 144, 239, 124, 242, 168, 248, 206, 247, 235, 248, 9, 251, 132, 238, 110, 241, 80, 246, 12, 0, 179, 255, 192, 255, 13, 0, 22, 0, 250, 0, 206, 255, 107, 241, 213, 2, 38, 3, 225, 0, 74, 0, 140, 2, 219, 4, 119, 0, 153, 242, 249, 255, 225, 255, 27, 239, 48, 239, 90, 251, 217, 238, 247, 238, 52, 242, 172, 255, 114, 248, 230, 247, 64, 250, 64, 247, 52, 251, 0, 255, 57, 245, 167, 247, 162, 249, 2, 255, 119, 255, 54, 250, 173, 254, 104, 251, 145, 255, 211, 247, 141, 248, 128, 249, 85, 248, 0, 0, 208, 255, 86, 0, 227, 255, 170, 255, 206, 255, 0, 0, 0, 1, 49, 0, 15, 0, 132, 0, 38, 0, 161, 1, 142, 0, 77, 250, 63, 253, 217, 248, 167, 255, 165, 255, 153, 255, 183, 255, 160, 255, 202, 255, 241, 255, 225, 255, 202, 255, 253, 255, 85, 255, 20, 0, 55, 1, 108, 2, 34, 251, 175, 255, 78, 248, 145, 248, 171, 246, 36, 3, 106, 4, 242, 1, 149, 1, 13, 0, 189, 255, 226, 255, 201, 0, 14, 2, 237, 1, 106, 2, 32, 1, 16, 2, 47, 1, 252, 0, 38, 1, 137, 2, 177, 3, 127, 0, 53, 1, 137, 0, 97, 3, 213, 2, 7, 3, 109, 1, 39, 0, 219, 0, 143, 1, 9, 1, 62, 0, 33, 0, 207, 0, 203, 0, 37, 1, 93, 0, 70, 2, 30, 0, 134, 0, 212, 0, 182, 0, 52, 1, 11, 1, 181, 0, 173, 0, 42, 2, 195, 4, 170, 0, 57, 2, 198, 255, 133, 0, 150, 0, 188, 0, 196, 2, 137, 3, 222, 0, 198, 1, 215, 3, 45, 4, 243, 255, 65, 2, 4, 0, 156, 0, 251, 2, 157, 0, 134, 239, 35, 239, 227, 241, 33, 245, 13, 241, 223, 255, 136, 246, 228, 255, 180, 255, 14, 255, 119, 255, 157, 255, 88, 254, 100, 249, 150, 255, 35, 252, 153, 255, 139, 252, 100, 251, 18, 251, 134, 255, 23, 250, 62, 248, 117, 248, 130, 246, 205, 250, 84, 1, 227, 255, 0, 0, 160, 3, 34, 0, 169, 255, 124, 1, 212, 255, 174, 255, 194, 255, 250, 255, 70, 0, 28, 0, 211, 255, 8, 0, 201, 255, 4, 0, 238, 255, 177, 238, 96, 238, 215, 238, 181, 238, 162, 239, 85, 239, 113, 239, 168, 0, 130, 235, 252, 255, 92, 247, 182, 251, 254, 238, 240, 238, 120, 248, 22, 248, 249, 248, 183, 239, 171, 250, 27, 239, 145, 1, 85, 247, 49, 252, 75, 238, 207, 251, 223, 237, 215, 255, 3, 0, 238, 255, 0, 0, 193, 255, 0, 0, 5, 0, 213, 255, 6, 0, 205, 255, 29, 0, 226, 0, 85, 0, 192, 255, 19, 2, 39, 0, 51, 1, 206, 255, 18, 0, 75, 0, 6, 0, 12, 0, 225, 255, 146, 0, 69, 0, 217, 255, 74, 2, 221, 0, 5, 0, 52, 0, 97, 0, 246, 255, 230, 255, 16, 0, 210, 255, 98, 253, 24, 254, 45, 246, 70, 0, 249, 254, 138, 254, 30, 254, 185, 254, 222, 255, 185, 255, 207, 255, 204, 255, 199, 255, 200, 255, 188, 255, 17, 1, 236, 255, 77, 0, 195, 0, 64, 0, 207, 255, 196, 255, 215, 255, 253, 4, 36, 0, 203, 8, 29, 0, 206, 255, 203, 0, 48, 0, 198, 255, 57, 252, 136, 5, 15, 251, 177, 251, 83, 255, 173, 255, 170, 255, 251, 255, 41, 239, 172, 243, 185, 239, 15, 239, 40, 239, 54, 3, 249, 254, 123, 246, 88, 248, 11, 0, 56, 250, 208, 246, 36, 248, 175, 250, 84, 239, 91, 240, 75, 250, 58, 241, 121, 246, 127, 247, 157, 245, 53, 239, 167, 0, 242, 255, 200, 0, 173, 1, 213, 0, 216, 255, 214, 255, 43, 0, 10, 0, 4, 0, 205, 255, 213, 255, 219, 0, 11, 1, 164, 0, 139, 0, 25, 0, 92, 0, 13, 0, 214, 3, 58, 0, 8, 0, 194, 255, 184, 255, 199, 255, 0, 0, 214, 255, 161, 253, 109, 252, 209, 255, 162, 255, 166, 255, 124, 255, 228, 255, 195, 255, 221, 255, 173, 255, 195, 255, 214, 255, 215, 255, 211, 255, 165, 255, 180, 255, 171, 255, 138, 1, 48, 0, 222, 2, 17, 4, 247, 0, 239, 255, 229, 255, 237, 255, 2, 0, 2, 0, 204, 251, 149, 255, 255, 252, 186, 255, 203, 255, 5, 0, 227, 255, 230, 255, 220, 0, 61, 2, 32, 1, 2, 1, 210, 1, 83, 2, 214, 0, 39, 3, 231, 1, 207, 5, 247, 0, 93, 1, 227, 3, 20, 5, 205, 1, 30, 2, 217, 5, 10, 5, 208, 4, 169, 3, 24, 4, 80, 1, 149, 3, 209, 1, 124, 4, 147, 3, 108, 3, 224, 1, 73, 2, 17, 3, 87, 2, 230, 2, 111, 2, 118, 4, 238, 1, 29, 1, 88, 1, 235, 5, 107, 1, 22, 7, 60, 3, 46, 2, 14, 6, 244, 2, 91, 3, 170, 2, 162, 2, 217, 4, 112, 6, 163, 7, 52, 11, 93, 8, 97, 10, 110, 5, 127, 11, 198, 4, 46, 9, 14, 6, 224, 7, 23, 8, 205, 7, 93, 10, 176, 4, 239, 6, 176, 4, 166, 4, 70, 7, 251, 4, 145, 8, 230, 6, 7, 5, 157, 10, 179, 6, 47, 7, 165, 5, 81, 9, 118, 4, 204, 8, 68, 10, 219, 6, 182, 6, 255, 7, 193, 8, 51, 11, 126, 7, 52, 5, 99, 8, 165, 3, 130, 4, 13, 10, 190, 6, 161, 10, 181, 1, 148, 0, 191, 0, 151, 0, 165, 0, 186, 0, 11, 1, 157, 14, 23, 13, 235, 9, 164, 10, 241, 14, 30, 14, 233, 0, 78, 2, 222, 0, 169, 17, 72, 17, 76, 2, 149, 8, 202, 17, 1, 15, 141, 7, 215, 0, 90, 3, 252, 1, 228, 18, 248, 21, 189, 17, 54, 21, 1, 19, 155, 19, 48, 19, 32, 19, 188, 19, 89, 5, 59, 16, 214, 6, 6, 20, 134, 19, 13, 19, 21, 19, 162, 19, 10, 20, 224, 19, 238, 18, 152, 16, 0, 18, 13, 20, 227, 22, 66, 20, 123, 17, 235, 19, 141, 19, 147, 19, 213, 19, 77, 15, 219, 1, 241, 11, 149, 9, 134, 13, 30, 14, 216, 6, 137, 18, 60, 15, 164, 4, 168, 10, 134, 6, 33, 8, 253, 14, 86, 4, 96, 4, 183, 4, 21, 4, 43, 4, 233, 3, 211, 4, 119, 4, 147, 4, 80, 10, 114, 4, 248, 6, 81, 16, 241, 20, 156, 21, 137, 20, 206, 18, 91, 5, 192, 5, 18, 5, 97, 7, 124, 20, 195, 14, 247, 12, 63, 21, 42, 14, 168, 11, 183, 18, 152, 21, 177, 20, 41, 2, 19, 2, 157, 1, 79, 7, 40, 2, 103, 2, 232, 1, 27, 7, 90, 5, 13, 6, 177, 6, 159, 7, 140, 5, 46, 6, 223, 11, 7, 15, 197, 15, 134, 2, 219, 6, 7, 2, 130, 13, 233, 14, 61, 11, 32, 2, 55, 6, 171, 4, 238, 4, 32, 5, 236, 3, 30, 4, 158, 3, 39, 5, 105, 4, 250, 15, 128, 15, 166, 16, 43, 9, 162, 9, 221, 15, 24, 6, 109, 5, 96, 4, 6, 5, 253, 4, 199, 5, 181, 4, 96, 6, 58, 5, 75, 5, 65, 4, 26, 5, 26, 5, 138, 19, 107, 19, 231, 18, 80, 18, 125, 20, 41, 17, 226, 17, 53, 19, 72, 17, 74, 16, 225, 15, 176, 14, 7, 18, 75, 16, 12, 17, 194, 16, 98, 18, 27, 17, 249, 12, 126, 10, 232, 12, 161, 18, 127, 15, 216, 16, 141, 17, 172, 15, 4, 17, 25, 19, 73, 17, 4, 18, 107, 8, 57, 14, 160, 9, 67, 7, 7, 10, 55, 13, 46, 18, 127, 14, 150, 13, 137, 13, 186, 15, 16, 14, 178, 13, 161, 17, 206, 16, 67, 14, 190, 13, 255, 11, 1, 2, 24, 16, 118, 11, 218, 3, 70, 5, 51, 4, 214, 3, 133, 3, 155, 3, 122, 3, 189, 3, 176, 6, 176, 1, 43, 2, 105, 2, 141, 1, 223, 12, 219, 7, 78, 10, 133, 14, 104, 10, 203, 3, 80, 19, 238, 18, 85, 20, 229, 19, 135, 20, 231, 13, 129, 10, 15, 19, 173, 11, 165, 10, 237, 12, 55, 19, 253, 15, 146, 4, 95, 19, 174, 18, 222, 11, 51, 16, 100, 15, 23, 19, 37, 18, 48, 19, 18, 5, 170, 4, 171, 5, 12, 4, 254, 3, 127, 3, 124, 4, 55, 3, 191, 6, 159, 0, 116, 2, 0, 6, 1, 7, 6, 20, 163, 5, 162, 6, 40, 5, 25, 6, 184, 5, 81, 5, 22, 5, 36, 5, 244, 3, 68, 3, 70, 3, 100, 3, 87, 3, 160, 18, 234, 4, 105, 3, 171, 7, 120, 7, 132, 7, 47, 4, 113, 255, 6, 1, 97, 4, 25, 3, 43, 3, 69, 4, 81, 246, 96, 242, 49, 248, 4, 243, 241, 240, 12, 255, 148, 247, 253, 246, 3, 241, 248, 242, 97, 239, 189, 240, 10, 241, 60, 241, 140, 240, 179, 240, 142, 241, 40, 241, 236, 242, 10, 244, 164, 245, 161, 240, 225, 1, 236, 255, 159, 255, 137, 255, 228, 255, 246, 255, 63, 254, 71, 245, 48, 245, 210, 245, 233, 255, 210, 252, 192, 245, 107, 254, 184, 250, 205, 255, 223, 248, 139, 243, 183, 246, 237, 244, 197, 251, 132, 243, 213, 252, 93, 252, 12, 247, 188, 246, 19, 243, 181, 246, 174, 242, 213, 242, 215, 243, 117, 243, 128, 243, 121, 241, 227, 241, 251, 242, 100, 242, 114, 242, 57, 242, 119, 242, 58, 245, 157, 244, 223, 244, 46, 244, 110, 244, 230, 244, 141, 243, 30, 244, 136, 243, 253, 242, 76, 243, 154, 243, 184, 254, 96, 250, 94, 252, 168, 241, 192, 242, 164, 244, 123, 243, 7, 244, 46, 244, 27, 243, 209, 241, 133, 242, 15, 242, 91, 242, 219, 242, 76, 243, 21, 243, 229, 242, 77, 3, 56, 1, 62, 5, 154, 3, 177, 4, 163, 16, 14, 9, 187, 3, 23, 9, 45, 9, 164, 1, 134, 1, 171, 4, 103, 6, 185, 4, 198, 3, 104, 9, 33, 6, 105, 9, 220, 1, 194, 4, 136, 3, 116, 18, 236, 20, 66, 19, 105, 20, 120, 18, 91, 20, 156, 19, 229, 2, 111, 3, 210, 0, 132, 2, 148, 7, 55, 2, 77, 0, 104, 2, 210, 7, 35, 18, 9, 17, 18, 18, 211, 18, 158, 11, 238, 17, 30, 15, 236, 7, 51, 5, 86, 12, 56, 0, 230, 1, 26, 4, 196, 2, 39, 4, 33, 1, 245, 2, 249, 5, 153, 3, 179, 3, 130, 3, 25, 4, 230, 2, 93, 4, 101, 0, 210, 3, 230, 0, 118, 2, 236, 5, 120, 3, 34, 7, 119, 4, 126, 4, 95, 1, 165, 3, 62, 2, 236, 16, 213, 12, 191, 14, 82, 12, 243, 9, 245, 0, 46, 5, 138, 3, 246, 0, 138, 4, 0, 6, 222, 5, 97, 7, 104, 6, 181, 5, 116, 12, 88, 9, 228, 9, 102, 0, 230, 0, 114, 0, 136, 0, 171, 0, 185, 1, 243, 1, 113, 1, 61, 1, 219, 0, 59, 2, 28, 1, 29, 1, 21, 4, 206, 0, 237, 0, 195, 0, 224, 0, 38, 1, 60, 1, 134, 1, 219, 0, 10, 0, 136, 0, 44, 2, 245, 1, 192, 0, 226, 0, 205, 0, 68, 4, 78, 1, 112, 1, 40, 2, 46, 2, 13, 3, 28, 1, 51, 1, 190, 1, 97, 1, 16, 2, 43, 1, 58, 1, 79, 1, 248, 1, 117, 2, 138, 1, 124, 1, 245, 0, 78, 19, 1, 21, 154, 18, 229, 18, 147, 19, 179, 20, 71, 17, 178, 15, 222, 21, 217, 11, 98, 11, 49, 1, 42, 20, 63, 23, 35, 1, 58, 0, 187, 0, 176, 4, 66, 0, 130, 0, 86, 0, 79, 0, 110, 0, 61, 18, 247, 23, 193, 20, 154, 1, 206, 1, 139, 1, 99, 1, 68, 1, 176, 0, 112, 0, 92, 0, 47, 1, 248, 1, 186, 3, 163, 0, 174, 0, 172, 0, 132, 0, 228, 0, 122, 0, 142, 0, 26, 0, 186, 0, 13, 1, 250, 255, 3, 0, 198, 0, 165, 0, 255, 255, 166, 0, 2, 0, 63, 1, 91, 0, 166, 246, 129, 246, 12, 0, 250, 245, 210, 247, 221, 246, 117, 248, 36, 0, 7, 0, 33, 0, 150, 19, 240, 13, 178, 18, 119, 20, 198, 13, 239, 0, 221, 0, 15, 0, 18, 0, 13, 0, 36, 0, 137, 0, 58, 1, 245, 3, 83, 0, 6, 3, 26, 0, 42, 0, 13, 0, 103, 0, 92, 0, 121, 0, 229, 255, 104, 244, 193, 245, 11, 0, 233, 1, 35, 246, 197, 245, 29, 247, 161, 246, 76, 247, 168, 245, 31, 245, 141, 0, 27, 1, 217, 0, 67, 2, 254, 255, 48, 0, 194, 252, 139, 245, 126, 247, 182, 255, 125, 5, 7, 0, 28, 0, 195, 0, 202, 255, 108, 0, 154, 255, 254, 255, 5, 0, 3, 0, 20, 247, 135, 249, 39, 248, 212, 247, 190, 249, 253, 255, 130, 255, 174, 255];
exports.default = _default;
},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"planet/globe.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _icosphere = _interopRequireDefault(require("./icosphere.js"));

var _data = _interopRequireDefault(require("../data/data.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var elevation_buffer = Buffer.from(_data.default);

var Globe =
/*#__PURE__*/
function () {
  function Globe(config) {
    _classCallCheck(this, Globe);

    this.config = config;
    var header = new Int16Array(elevation_buffer.buffer, 0, 1);
    var recursion_level = config.recursion_level;
    var icosphere = (0, _icosphere.default)(recursion_level);
    this.points = icosphere.points;
    this.triangles = icosphere.triangles;
    this.max_recursion_level = recursion_level;
    var elevation_ints = new Int16Array(elevation_buffer.buffer, 2, this.points.length);
    this.points.forEach(function (point, i) {
      point.elevation = elevation_ints[i];
    });
  } // Regenerate faces based on the current recursion level


  _createClass(Globe, [{
    key: "generateTriangles",
    value: function generateTriangles() {
      var icosphere = (0, _icosphere.default)(this.config.recursion_level);
      this.triangles = icosphere.triangles;
    }
  }]);

  return Globe;
}();

exports.default = Globe;
},{"./icosphere.js":"planet/icosphere.js","../data/data.js":"data/data.js","buffer":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"planet/ColorGradient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _fs = require("fs");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var color_data = "5000    255 255 255 255\n4000    201 122  52 255\n2000    217 166  39 255\n1000    102  51   0 255\n500      30  56   8 255\n100      60 110   9 255\n0        51 102   0 255\n-50     100 200 255 255\n-500     80 100 190 255\n-1000    60  90 180 255\n-2000    21  70 170 255\n-4000    21  65 150 255\n-6000    12  68 120 255\n-8000     0  14 100 255\n-11000   16   6 50 255"; // import color_data from './color_gradients/GMT_simple.pg';

console.log(color_data);

var ColorGradient =
/*#__PURE__*/
function () {
  function ColorGradient(name) {
    var _this = this;

    _classCallCheck(this, ColorGradient);

    this.colors = color_data.split("\n").reverse().filter(function (line) {
      return line.length > 1;
    }).map(function (line) {
      var values = line.split(/\s+/);
      return {
        color: {
          r: parseInt(values[1]),
          g: parseInt(values[2]),
          b: parseInt(values[3])
        },
        elevation: parseInt(values[0])
      };
    });
    this.min_elevation = this.colors[0].elevation;
    this.max_elevation = this.colors[this.colors.length - 1].elevation;
    this.elevation_range = this.max_elevation - this.min_elevation;
    this.colors.forEach(function (color) {
      color.percent = "".concat((100.0 * (_this.min_elevation - color.elevation) / _this.elevation_range).toFixed(2), "%");
    });
  } // Gets a color based on an elevation
  // Uses a color gradient. See color_gradient/build_color_gradiant.js for more info


  _createClass(ColorGradient, [{
    key: "getColorRGB",
    value: function getColorRGB(elevation) {
      var i = 0;

      while (i < this.colors.length && elevation > this.colors[i].elevation) {
        i++;
      }

      if (i == 0) {
        return this.colors[0].color;
      }

      if (i == this.colors.length) {
        return this.colors[this.colors.length - 1].color;
      }

      var min = this.colors[i - 1];
      var max = this.colors[i];

      if (max.elevation - min.elevation == 0) {
        return min.color;
      }

      var percent = (elevation - min.elevation) / (max.elevation - min.elevation);
      return {
        r: min.color.r + (max.color.r - min.color.r) * percent,
        g: min.color.g + (max.color.g - min.color.g) * percent,
        b: min.color.b + (max.color.b - min.color.b) * percent
      };
    } // Converts a js object with keys r, g, and b into a THREE.Color object

  }, {
    key: "getColor",
    value: function getColor(elevation) {
      var c = this.getColorRGB(elevation);
      return new THREE.Color(c.r / 255.0, c.g / 255.0, c.b / 255.0);
    }
  }]);

  return ColorGradient;
}();

exports.default = ColorGradient;
},{"three":"node_modules/three/build/three.module.js","fs":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/_empty.js"}],"planet/config.json":[function(require,module,exports) {
module.exports = [{
  "name": "recursion_level",
  "label": "Polygon Count",
  "type": "integer",
  "min": 1,
  "max": 6,
  "default": 5
}, {
  "name": "elevation_scale",
  "label": "Elevation Scale",
  "type": "integer",
  "min": 1,
  "max": 800,
  "default": 375
}, {
  "name": "compute_vertex_normals",
  "label": "Use Vertex Normals",
  "type": "boolean",
  "default": false
}, {
  "name": "render_globe_interior",
  "label": "Render Globe Interior",
  "type": "boolean",
  "default": false
}, {
  "name": "triangle_coloring",
  "label": "Triangle Coloring",
  "type": "enum",
  "default": "min",
  "options": [{
    "name": "max",
    "localized": "Highest Vertex Color"
  }, {
    "name": "min",
    "localized": "Lowest Vertex Color"
  }, {
    "name": "avg",
    "localized": "Average Vertex Color"
  }, {
    "name": "all",
    "localized": "All Vertex Colors (gradient)"
  }]
}, {
  "name": "color_gradient",
  "label": "Color Gradient",
  "type": "enum",
  "default": "GMT_simple",
  "options": [{
    "name": "GMT_globe",
    "localized": "Standard"
  }, {
    "name": "GMT_simple",
    "localized": "Simple"
  }, {
    "name": "GMT_dem4",
    "localized": "High Contrast"
  }, {
    "name": "GMT_sealand",
    "localized": "Relief"
  }, {
    "name": "GMT_topo",
    "localized": "Strange"
  }]
}, {
  "name": "material",
  "label": "Material",
  "type": "enum",
  "default": "lambert",
  "options": [{
    "name": "lambert",
    "localized": "Lambert"
  }, {
    "name": "standard",
    "localized": "Standard"
  }, {
    "name": "basic",
    "localized": "Basic"
  }]
}, {
  "name": "rotation",
  "label": "Rotation",
  "type": "boolean",
  "default": false
}, {
  "name": "ambient_light_intensity",
  "label": "Ambient Light",
  "type": "float",
  "min": 0,
  "max": 1,
  "default": 0.75
}, {
  "name": "camera_light_intensity",
  "label": "Camera Light",
  "type": "float",
  "min": 0,
  "max": 1,
  "default": 0.75
}, {
  "name": "sunlight_intensity",
  "label": "Sunlight",
  "type": "float",
  "min": 0,
  "max": 1,
  "default": 0
}];
},{}],"planet/planet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var THREE = _interopRequireWildcard(require("three"));

var _globe = _interopRequireDefault(require("./globe.js"));

var _ColorGradient = _interopRequireDefault(require("./ColorGradient.js"));

var _config = _interopRequireDefault(require("./config.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var config = _config.default.reduce(function (c, item) {
  // console.log(item, c)
  return Object.assign(c, _defineProperty({}, item.name, item.default));
}, {});

console.log(config);
var colorGradient = new _ColorGradient.default();
var globe = new _globe.default(config);

function _default(scene, camera, renderer) {
  var canvas_element = renderer.domElement; // Ambient light

  var ambient_light = new THREE.AmbientLight(0xffffff, config.ambient_light_intensity);
  scene.add(ambient_light);
  var sunlight = new THREE.DirectionalLight(0xffffff, config.sunlight_intensity);
  sunlight.position.set(1, 0, 0);
  scene.add(sunlight); // Follows the camera

  var light = new THREE.PointLight(0xffffff, config.camera_light_intensity);
  scene.add(light);
  var material = getGlobeMaterial();
  var ocean_geometry = new THREE.Geometry();
  var geometry = new THREE.Geometry();
  geometry.dynamic = true;
  var globe_object;
  var clock = new THREE.Clock();
  var zoom_start = 4;
  camera.position.z = zoom_start;
  light.position.z = zoom_start;
  loadGlobe(); // These shall be used to hold information for controlling the camera position

  var controls = {
    x: null,
    y: null,
    theta: 0,
    phi: 0,
    actual_theta: 0,
    actual_phi: 0,
    zoom: zoom_start,
    actual_zoom: zoom_start,
    touch_delta: 0,
    rotation_speed: 0
  }; // Creates and adds the globe to the scene

  function loadGlobe() {
    //// Ocean
    globe.points.forEach(function (point) {
      ocean_geometry.vertices.push(pointToVector(point, false));
    });
    globe.triangles.forEach(function (triangle, index) {
      ocean_geometry.faces.push(triangleToFace(index, false));
    });
    var ocean_material = new THREE.MeshPhongMaterial({
      color: 0x0000ff,
      transparent: true,
      opacity: 0.8
    });
    ocean_geometry.computeFaceNormals();
    var ocean = new THREE.Mesh(ocean_geometry, ocean_material);
    scene.add(ocean);
    console.time("computing vertex colors");
    globe.points.forEach(function (point) {
      point.color = colorGradient.getColor(point.elevation);
    });
    console.timeEnd("computing vertex colors");
    console.time("adding vertices");
    globe.points.forEach(function (point) {
      geometry.vertices.push(pointToVector(point));
    });
    console.timeEnd("adding vertices");
    console.time("adding triangles");
    globe.triangles.forEach(function (triangle, index) {
      geometry.faces.push(triangleToFace(index));
    });
    console.timeEnd("adding triangles");

    if (config.render_globe_interior) {
      material.side = THREE.DoubleSide;
    }

    globe_object = new THREE.Mesh(geometry, material);
    scene.add(globe_object);
    console.time("computing face normals");
    geometry.computeFaceNormals();
    console.timeEnd("computing face normals");

    if (config.compute_vertex_normals) {
      console.time("computing vertex normals");
      geometry.computeVertexNormals();
      console.timeEnd("computing vertex normals");
    }

    console.timeEnd("entire globe initialization");
  } // Finds an x, y, z position on a globe given a theta, phi, and radius


  function degreesToPosition(theta, phi, radius) {
    return [radius * Math.sin(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360), radius * Math.sin(phi * Math.PI / 360), radius * Math.cos(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360)];
  } //// Controls / Events
  // The main function of animate at this point is to control the camera position


  var animate = function animate() {
    requestAnimationFrame(animate);
    var clock_delta = clock.getDelta();
    var smoothing = Math.min(12 * clock_delta, 1);
    var threshold = 0.05;
    var zoom_smoothing = Math.min(9 * clock_delta, 1);
    var zoom_threshold = 0.0005;
    var camera_changed = false;
    var rotation_acceleration = Math.min(2 * clock_delta, 1);
    var rotation_full_speed = 0.01;

    if (controls.zoom != controls.actual_zoom) {
      controls.actual_zoom += (controls.zoom - controls.actual_zoom) * zoom_smoothing;

      if (controls.actual_zoom < controls.zoom + zoom_threshold && controls.actual_zoom > controls.zoom - zoom_threshold) {
        controls.actual_zoom = controls.zoom;
      }

      camera_changed = true;
    }

    if (controls.actual_theta != controls.theta || controls.actual_phi != controls.phi) {
      controls.actual_theta += (controls.theta - controls.actual_theta) * smoothing;
      controls.actual_phi += (controls.phi - controls.actual_phi) * smoothing;

      if (controls.actual_phi < controls.phi + threshold && controls.actual_phi > controls.phi - threshold) {
        controls.actual_phi = controls.phi;
      }

      if (controls.actual_theta < controls.theta + threshold && controls.actual_theta > controls.theta - threshold) {
        controls.actual_theta = controls.theta;
      }

      camera_changed = true;
    }

    if (camera_changed) {
      var _camera$position;

      (_camera$position = camera.position).set.apply(_camera$position, _toConsumableArray(degreesToPosition(controls.actual_theta, controls.actual_phi, controls.actual_zoom))); // light.position.set(...degreesToPosition(
      // 	45 + controls.actual_theta,
      // 	45 + controls.actual_phi,
      // 	2.5
      // ));


      light.position.set(camera.position.x, camera.position.y, camera.position.z);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      camera.updateMatrix();
    }

    if (config.rotation && controls.rotation_speed != 1) {
      controls.rotation_speed = Math.min(controls.rotation_speed + rotation_acceleration, 1);
    } else if (!config.rotation && controls.rotation_speed != 0) {
      controls.rotation_speed = Math.max(controls.rotation_speed - rotation_acceleration, 0);
    }

    if (controls.rotation_speed > 0) {
      globe_object.rotation.y += controls.rotation_speed * rotation_full_speed;
    }

    renderer.render(scene, camera);
  };

  animate();

  function pressMove(x, y) {
    // drawing is based on the height, so this scales with size of drawing
    var moveScaling = 500.0 / canvas_element.clientHeight; // make movescaling less when youre more zoomed in

    moveScaling *= Math.max(controls.zoom, 1) / zoom_start;
    controls.theta += -((x - controls.x) * moveScaling);
    controls.phi += (y - controls.y) * moveScaling;
    controls.phi = Math.min(180, Math.max(-180, controls.phi));
  }

  function pressDown(x, y) {
    controls.x = x;
    controls.y = y;
  }

  function zoomChange(delta) {
    var zoom_scaling = 0.1;
    controls.zoom += delta * zoom_scaling;
    controls.zoom = Math.max(0.1, controls.zoom);
  } // Called on touchstart or touchend if there are 2 or more touches


  function touchesUpdate(x1, y1, x2, y2) {
    controls.touch_delta = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  } // Called on touchmove if there are 2 or more touches


  function touchesMove(x1, y1, x2, y2) {
    var touch_zoom_scaling = 0.03;
    var new_delta = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    zoomChange((controls.touch_delta - new_delta) * touch_zoom_scaling);
  }

  canvas_element.addEventListener("mousedown", function (event) {
    event.preventDefault();
    canvas_element.style.cursor = "grabbing";

    if (event.button == 0) {
      pressDown(event.clientX, event.clientY);
    }
  }, false); // for if the user lets go out of the canvas

  window.addEventListener("mouseup", function (event) {
    canvas_element.style.cursor = "grab";
  });
  canvas_element.addEventListener("mousemove", function (event) {
    event.preventDefault();

    if (event.buttons & 1) {
      pressMove(event.clientX, event.clientY);
    }

    pressDown(event.clientX, event.clientY);
  }, false);
  canvas_element.addEventListener("touchstart", function (event) {
    event.preventDefault();

    if (event.touches) {
      if (event.touches.length > 1) {
        touchesUpdate(event.touches[0].clientX, event.touches[0].clientY, event.touches[1].clientX, event.touches[1].clientY);
      } else {
        pressDown(event.touches[0].clientX, event.touches[0].clientY);
      }
    }
  });
  canvas_element.addEventListener("touchend", function (event) {
    event.preventDefault();

    if (event.touches && event.touches.length > 0) {
      if (event.touches.length > 1 && event.touches[1]) {
        touchesUpdate(event.touches[0].clientX, event.touches[0].clientY, event.touches[1].clientX, event.touches[1].clientY);
      } else {
        pressDown(event.touches[0].clientX, event.touches[0].clientY);
      }
    }
  });
  canvas_element.addEventListener("touchmove", function (event) {
    event.preventDefault();

    if (event.touches) {
      if (event.touches.length > 1) {
        touchesMove(event.touches[0].clientX, event.touches[0].clientY, event.touches[1].clientX, event.touches[1].clientY);
        touchesUpdate(event.touches[0].clientX, event.touches[0].clientY, event.touches[1].clientX, event.touches[1].clientY);
      } else {
        pressMove(event.touches[0].clientX, event.touches[0].clientY);
        pressDown(event.touches[0].clientX, event.touches[0].clientY);
      }
    }
  });
  canvas_element.addEventListener("wheel", function (event) {
    event.preventDefault();
    var divisor = {
      0: 100,
      1: 3,
      2: 1
    }[event.deltaMode]; // based on the usual values for these modes

    zoomChange(event.deltaY / divisor);
  }); //// Globe stuff
  // Converts a point from globe.json into a THREE.Vector3
  // Takes elevation into account, adjusting for what we've configured

  function pointToVector(point) {
    var use_elevation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var radius = 1; // corresponds to 20903520 feet

    var elevation = config.elevation_scale * (point.elevation / 20903520); // To prevent the earth havin a z-fight with the ocean when elevation_scale is low

    var threshold = 0.001;

    if (Math.abs(elevation) < threshold) {
      elevation = elevation > 0 ? threshold : -threshold;
    }

    if (!use_elevation) {
      elevation = 0;
    }

    return new THREE.Vector3((radius + elevation) * point.x, (radius + elevation) * point.y, (radius + elevation) * point.z);
  } // Colors a face when given its index


  function colorFace(face, index) {
    var triangle = globe.triangles[index];
    var points = [globe.points[triangle.p1], globe.points[triangle.p2], globe.points[triangle.p3]];

    switch (config.triangle_coloring) {
      case "max":
        var color = points.reduce(function (p1, p2) {
          return p1.elevation > p2.elevation ? p1 : p2;
        }).color;
        face.vertexColors[0] = color;
        face.vertexColors[1] = color;
        face.vertexColors[2] = color;
        break;

      case "min":
        var color = points.reduce(function (p1, p2) {
          return p1.elevation < p2.elevation ? p1 : p2;
        }).color;
        face.vertexColors[0] = color;
        face.vertexColors[1] = color;
        face.vertexColors[2] = color;
        break;

      case "avg":
        var color = colorGradient.getColor(points.map(function (p) {
          return p.elevation;
        }).reduce(function (e1, e2) {
          return e1 + e2;
        }) / points.length);
        face.vertexColors[0] = color;
        face.vertexColors[1] = color;
        face.vertexColors[2] = color;
        break;

      case "all":
        face.vertexColors[0] = points[0].color;
        face.vertexColors[1] = points[1].color;
        face.vertexColors[2] = points[2].color;
        break;

      default:
        console.error("bad triangle color setting");
    }
  }

  function getGlobeMaterial() {
    var init = {
      lambert: function lambert(options) {
        return new THREE.MeshLambertMaterial(options);
      },
      standard: function standard(options) {
        return new THREE.MeshStandardMaterial(options);
      },
      basic: function basic(options) {
        return new THREE.MeshBasicMaterial(options);
      }
    }[config.material];
    return init({
      vertexColors: THREE.VertexColors,
      side: config.render_globe_interior ? THREE.DoubleSide : THREE.FrontSide
    });
  } // Converts a triangle from globe.json into a THREE.Vector3
  // Passed the index of the triangle instead of the triangle itself, to allow for freedom


  function triangleToFace(index) {
    var add_colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var triangle = globe.triangles[index];
    var face = new THREE.Face3(triangle.p1, triangle.p2, triangle.p3);

    if (add_colors) {
      colorFace(face, index);
    }

    return face;
  }

  return globe_object;
}
},{"three":"node_modules/three/build/three.module.js","./globe.js":"planet/globe.js","./ColorGradient.js":"planet/ColorGradient.js","./config.json":"planet/config.json"}],"earth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _planet = _interopRequireDefault(require("./planet/planet.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Earth = function Earth(scene, camera, renderer) {
  _classCallCheck(this, Earth);

  // this.planet = new THREE.SphereGeometry(10, 32, 32);
  // this.crust = new THREE.MeshBasicMaterial({
  //     color: 0xff0000,
  // });
  // this.earth = new THREE.Mesh(this.planet, this.crust);
  // scene.add(this.earth);
  // console.log(this)
  this.earth = (0, _planet.default)(scene, camera, renderer);
};

exports.default = Earth;
},{"./planet/planet.js":"planet/planet.js"}],"cubesat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _three2 = require("three.interaction");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Cubesat =
/*#__PURE__*/
function () {
  function Cubesat(scene, earth) {
    var _this = this;

    _classCallCheck(this, Cubesat);

    this.earth = earth;
    this.cube = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), new THREE.MeshBasicMaterial({
      color: 0x888888
    }));
    this.cube.cursor = 'pointer';
    this.cube.on('mouseover', function () {
      _this.cube.material.color.setHex(0xffffff);
    });
    this.cube.on('mouseout', function () {
      _this.cube.material.color.setHex(0x888888);
    });
    this.cube.position.y = 1.5; // let radius = 1.5,
    //     segments = 64,
    //     material = new THREE.LineBasicMaterial({
    //         color: 0xffffff
    //     }),
    //     geometry = new THREE.CircleGeometry(radius, segments);
    // // Remove center vertex
    // geometry.vertices.shift();
    // // Non closed circle with one open segment:
    // scene.add(new THREE.Line(geometry, material));
    // // To get a closed circle use LineLoop instead (see also @jackrugile his comment):
    // scene.add(new THREE.LineLoop(geometry, material));

    scene.add(this.cube);
    console.log(scene);
  }

  _createClass(Cubesat, [{
    key: "update",
    value: function update(t) {
      this.cube.position.z = -Math.sin(t / 10000) * 1.5;
      this.cube.position.y = -Math.cos(t / 10000) * 1.5;
      this.cube.lookAt(this.earth.position);
    }
  }]);

  return Cubesat;
}();

exports.default = Cubesat;
},{"three":"node_modules/three/build/three.module.js","three.interaction":"node_modules/three.interaction/build/three.interaction.module.js"}],"main.js":[function(require,module,exports) {
"use strict";

var THREE = _interopRequireWildcard(require("three"));

var _threeOrbitcontrols = _interopRequireDefault(require("three-orbitcontrols"));

var _three2 = require("three.interaction");

var _earth = _interopRequireDefault(require("./earth.js"));

var _cubesat = _interopRequireDefault(require("./cubesat.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var renderer,
    scene,
    camera,
    controls,
    interaction,
    clock,
    start = performance.now();
var earth, cubesat;
var container = document.getElementById('container');
var SPACE_COLOR = 0x0f0f0f;
var SUN_COLOR = 0xffffff;
var AMBIENT_COLOR = 0xffffff;

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function init() {
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(SPACE_COLOR, 1);
  container.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
  interaction = new _three2.Interaction(renderer, scene, camera); // clock = new THREE.Clock();
  // clock.start()
  // let sun = new THREE.PointLight(SUN_COLOR, 1, 4000);
  // sun.position.set(50, 0, 0);
  // let lightAmbient = new THREE.AmbientLight(AMBIENT_COLOR);
  // scene.add(sun, lightAmbient);

  var starsGeometry = new THREE.Geometry();

  for (var i = 0; i < 10000; i++) {
    var star = new THREE.Vector3();
    star.x = THREE.Math.randFloatSpread(1500);
    star.y = THREE.Math.randFloatSpread(1500);
    star.z = THREE.Math.randFloatSpread(1500);
    starsGeometry.vertices.push(star);
  }

  var starsMaterial = new THREE.PointsMaterial({
    color: 0xaaaaaa
  });
  var starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);
  earth = new _earth.default(scene, camera, renderer);
  cubesat = new _cubesat.default(scene, earth.earth); // camera.lookAt(e.earth.position)

  renderer.render(scene, camera);
}

function animate() {
  requestAnimationFrame(animate);
  cubesat.update(performance.now() - start);
  renderer.render(scene, camera);
}

init();
animate();
window.addEventListener('resize', onWindowResize, false);
},{"three":"node_modules/three/build/three.module.js","three-orbitcontrols":"node_modules/three-orbitcontrols/OrbitControls.js","three.interaction":"node_modules/three.interaction/build/three.interaction.module.js","./earth.js":"earth.js","./cubesat.js":"cubesat.js"}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "63584" + '/');

  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      console.clear();
      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},["../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","main.js"], null)
//# sourceMappingURL=/main.1f19ae8e.map